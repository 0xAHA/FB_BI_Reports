<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Part, Product & Vendor Pricing Validator</title>
    <style>
        {% Style fishbowl-theme %}
    </style>
    <style>
        /* Minimal page-specific overrides */
        h1 {
            text-align: center;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Part, Product & Vendor Pricing Validator</h1>
        <p class="subtitle">Validate your PPP import CSV before importing to Fishbowl</p>

        <!-- Upload Section -->
        <div class="upload-section" id="uploadSection">
            <h3>üìÑ Upload PPP Import CSV</h3>
            <p>Drag and drop file here, or <button type="button" class="btn-primary" onclick="document.getElementById('fileInput').click()">Choose File</button></p>
            <input type="file" id="fileInput" accept=".csv" onchange="handleFileSelect(event)" />
            <p id="fileName"></p>
        </div>

        <!-- Summary Stats (hidden until file loaded) -->
        <div class="summary-stats hidden" id="summaryStats">
            <div class="stat-card total">
                <span class="stat-number" id="statTotal">0</span>
                <span class="stat-label">Total</span>
            </div>
            <div class="stat-card valid">
                <span class="stat-number" id="statValid">0</span>
                <span class="stat-label">Valid</span>
            </div>
            <div class="stat-card warning">
                <span class="stat-number" id="statWarning">0</span>
                <span class="stat-label">Warnings</span>
            </div>
            <div class="stat-card error">
                <span class="stat-number" id="statError">0</span>
                <span class="stat-label">Errors</span>
            </div>
        </div>

        <!-- Consolidated Issues Summary -->
        <div class="consolidated-issues hidden" id="consolidatedIssues">
            <h3>‚ö†Ô∏è Issues Summary</h3>
            <div id="consolidatedIssuesContent"></div>
        </div>

        <!-- Filter Controls -->
        <div class="filter-controls hidden" id="filterControls">
            <label>Show:</label>
            <select id="filterStatus" onchange="applyFilters()">
                <option value="all">All Rows</option>
                <option value="errors" selected>Errors Only</option>
                <option value="warnings">Warnings Only</option>
                <option value="valid">Valid Only</option>
            </select>

            <div class="search-box">
                <input type="text" id="searchInput" placeholder="Search by Part Number, Vendor, etc..." oninput="applyFilters()" />
            </div>
        </div>

        <!-- Results Table -->
        <div class="results-section hidden" id="resultsSection">
            <div class="results-table-container">
                <table class="results-table" id="resultsTable">
                    <thead id="tableHeader">
                        <!-- Dynamic headers -->
                    </thead>
                    <tbody id="tableBody">
                        <!-- Dynamic rows -->
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Action Buttons -->
        <div class="action-buttons hidden" id="actionButtons">
            <button type="button" class="action-btn btn-revalidate" onclick="revalidateData()">
                <span>üîÑ</span> Re-validate
            </button>
            <button type="button" class="action-btn btn-export" onclick="exportValidRows()" id="exportValidBtn">
                <span>‚úÖ</span> Export Valid Rows
            </button>
            <button type="button" class="action-btn btn-export" onclick="exportAllWithFixes()" id="exportAllBtn" style="background-color: var(--fb-warning);">
                <span>üìù</span> Export All (with suggestions)
            </button>
            <button type="button" class="action-btn btn-import" onclick="importToFishbowl()" id="importBtn" style="background-color: var(--fb-success);">
                <span>üì•</span> Import to Fishbowl
            </button>
            <button type="button" class="action-btn btn-clear" onclick="clearData()">
                <span>üóëÔ∏è</span> Clear
            </button>
        </div>

        <!-- Column Reference -->
        <div class="column-reference">
            <h3 onclick="toggleColumnReference()">
                <span id="refToggle">‚ñ∂</span> PPP Import Column Reference
            </h3>
            <div class="column-grid hidden" id="columnGrid">
                <!-- Will be populated dynamically -->
            </div>
        </div>

        <!-- Debug Console -->
        <div class="debug-console">
            <h3 onclick="toggleDebugConsole()" style="cursor: pointer; margin: 0; padding: 10px; background: #1e1e1e; color: #00ff00; font-family: 'Courier New', monospace; font-size: 14px;">
                <span id="debugToggle">‚ñ∂</span> Debug Console
                <button type="button" onclick="clearDebugConsole(); event.stopPropagation();" style="float: right; padding: 2px 8px; font-size: 11px; background: #333; color: #fff; border: 1px solid #555; cursor: pointer;">Clear</button>
            </h3>
            <div id="debugConsoleContent" class="hidden" style="background: #1e1e1e; color: #d4d4d4; font-family: 'Courier New', monospace; font-size: 12px; padding: 10px; max-height: 300px; overflow-y: auto; border-top: 1px solid #333;">
                <!-- Debug messages will appear here -->
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay hidden" id="loadingOverlay">
        <div class="loading-spinner"></div>
        <div class="loading-text" id="loadingText">Processing file...</div>
        <div id="progressBarContainer" class="hidden" style="width: 300px; margin-top: 15px; background: rgba(255,255,255,0.2); border-radius: 10px; overflow: hidden;">
            <div id="progressBar" style="height: 20px; background: var(--fb-success); width: 0%; transition: width 0.3s;"></div>
        </div>
        <div id="progressText" class="hidden" style="margin-top: 10px; font-size: 14px; color: white;">0 / 0 rows</div>
    </div>

    <script>
    // ============================================
    // Debug Console Functions
    // ============================================

    function debugLog(message, type = 'log') {
        const timestamp = new Date().toLocaleTimeString();
        const colors = {
            log: '#d4d4d4',
            info: '#4fc3f7',
            warn: '#ffb74d',
            error: '#ff6b6b',
            success: '#66bb6a'
        };

        const consoleContent = document.getElementById('debugConsoleContent');
        if (consoleContent) {
            const logEntry = document.createElement('div');
            logEntry.style.color = colors[type] || colors.log;
            logEntry.style.marginBottom = '4px';
            logEntry.style.borderBottom = '1px solid #2a2a2a';
            logEntry.style.paddingBottom = '4px';

            // Create type label mapping without toUpperCase
            const typeLabels = {
                log: 'LOG    ',
                info: 'INFO   ',
                warn: 'WARN   ',
                error: 'ERROR  ',
                success: 'SUCCESS'
            };
            const typeLabel = typeLabels[type] || 'LOG    ';

            logEntry.innerHTML = `<span style="color: #666;">[${timestamp}]</span> <span style="color: ${colors[type]};">[${typeLabel}]</span> ${escapeHtml(String(message))}`;

            consoleContent.appendChild(logEntry);
            consoleContent.scrollTop = consoleContent.scrollHeight;
        }
    }

    function toggleDebugConsole() {
        const content = document.getElementById('debugConsoleContent');
        const toggle = document.getElementById('debugToggle');

        if (content.classList.contains('hidden')) {
            content.classList.remove('hidden');
            toggle.textContent = '‚ñº';
        } else {
            content.classList.add('hidden');
            toggle.textContent = '‚ñ∂';
        }
    }

    function clearDebugConsole() {
        const consoleContent = document.getElementById('debugConsoleContent');
        if (consoleContent) {
            consoleContent.innerHTML = '';
        }
    }

    // Override console methods to also write to debug console
    const originalConsole = {
        log: console.log,
        error: console.error,
        warn: console.warn,
        info: console.info
    };

    console.log = function(...args) {
        debugLog(args.join(' '), 'log');
        originalConsole.log.apply(console, args);
    };

    console.error = function(...args) {
        debugLog(args.join(' '), 'error');
        originalConsole.error.apply(console, args);
    };

    console.warn = function(...args) {
        debugLog(args.join(' '), 'warn');
        originalConsole.warn.apply(console, args);
    };

    console.info = function(...args) {
        debugLog(args.join(' '), 'info');
        originalConsole.info.apply(console, args);
    };

    // Global error handler
    window.onerror = function(message, source, lineno, colno, error) {
        debugLog(`JavaScript Error: ${message} at line ${lineno}:${colno}`, 'error');
        if (error && error.stack) {
            debugLog(`Stack: ${error.stack}`, 'error');
        }
        return false; // Allow default error handling
    };

    // Unhandled promise rejection handler
    window.onunhandledrejection = function(event) {
        debugLog(`Unhandled Promise Rejection: ${event.reason}`, 'error');
    };

    // ============================================
    // Performance Utility Functions
    // ============================================

    function showProgress(current, total) {
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const progressBarContainer = document.getElementById('progressBarContainer');

        if (progressBar && progressText && progressBarContainer) {
            progressBarContainer.classList.remove('hidden');
            progressText.classList.remove('hidden');

            const percent = Math.round((current / total) * 100);
            progressBar.style.width = percent + '%';
            progressText.textContent = `${current} / ${total} rows (${percent}%)`;
        }
    }

    function hideProgress() {
        const progressBarContainer = document.getElementById('progressBarContainer');
        const progressText = document.getElementById('progressText');

        if (progressBarContainer && progressText) {
            progressBarContainer.classList.add('hidden');
            progressText.classList.add('hidden');
        }
    }

    // Debounce function to delay execution
    function debounce(func, delay) {
        return function(...args) {
            if (debounceTimer) {
                clearTimeout(debounceTimer);
            }
            debounceTimer = setTimeout(() => {
                func.apply(this, args);
            }, delay);
        };
    }

    // Sleep function for batch processing
    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    // ============================================
    // Configuration & Column Definitions
    // ============================================

    const PPP_COLUMNS = {
        // Part Information - Core (Required fields marked)
        'PartNumber': { type: 'Text', required: true, desc: 'Unique part identifier (70 chars max) - REQUIRED' },
        'PartDescription': { type: 'Text', required: true, desc: 'Part description (252 chars max) - REQUIRED' },
        'PartDetails': { type: 'Text', required: false, desc: 'Additional part details (no limit)' },
        'UOM': { type: 'Text', required: true, desc: 'Default Unit of Measure (10 chars max) - REQUIRED', validateUOM: true },
        'UPC': { type: 'Text', required: false, desc: 'Universal Product Code (31 chars max)' },
        'PartTypeID': { type: 'Integer', required: true, desc: 'Part type ID - REQUIRED: 10=INVENTORY, 20=SERVICE, 21=LABOR, 22=OVERHEAD, 30=NON_INVENTORY, 40=INTERNAL_USE, 50=CAPITAL, 60=SHIPPING', validValues: ['10', '20', '21', '22', '30', '40', '50', '60'] },
        'Active': { type: 'Text', required: true, desc: 'Whether part is active (text field) - REQUIRED' },
        'PartTaxCode': { type: 'Text', required: true, desc: 'Tax code for the part - REQUIRED', validateTaxCode: true },
        'StdCost': { type: 'Decimal', required: false, desc: 'Standard cost (numeric)' },

        // Part - Tracking Flags (all Text type in Fishbowl)
        'Tracks-Lot Number': { type: 'Text', required: false, desc: 'Indicates if the part tracks lot numbers' },
        'Tracks-Revision Level': { type: 'Text', required: false, desc: 'Indicates if the part tracks revision levels' },
        'Tracks-Expiration Date': { type: 'Text', required: false, desc: 'Indicates if the part tracks expiration dates' },
        'Tracks-Serial Number': { type: 'Text', required: false, desc: 'Indicates if the part tracks serial numbers' },
        'Tracks-Batch Number': { type: 'Text', required: false, desc: 'Indicates if the part tracks batch numbers' },
        'Tracks-BoxID-Qty': { type: 'Text', required: false, desc: 'Indicates if the part tracks BoxID quantity' },
        'Tracks-BoxID-count': { type: 'Text', required: false, desc: 'Indicates if the part tracks BoxID count' },
        'Tracks-BoxID-money': { type: 'Text', required: false, desc: 'Indicates if the part tracks BoxID money' },
        'Tracks-Consignment': { type: 'Text', required: false, desc: 'Indicates if the part tracks consignment' },
        'Next Value-': { type: 'Text', required: false, desc: 'The next value for tracking' },

        // Accounting
        'AssetAccount': { type: 'Text', required: false, desc: 'Inventory asset account' },
        'COGSAccount': { type: 'Text', required: false, desc: 'Cost of goods sold account' },
        'AdjustmentAccount': { type: 'Text', required: false, desc: 'Adjustment account' },
        'ScrapAccount': { type: 'Text', required: false, desc: 'Scrap account' },
        'VarianceAccount': { type: 'Text', required: false, desc: 'Variance account' },
        'ABCCode': { type: 'Text', required: false, desc: 'ABC code classification' },

        // Part - Physical Properties (all Text type)
        'Weight': { type: 'Text', required: false, desc: 'Part weight' },
        'WeightUOM': { type: 'Text', required: false, desc: 'Weight unit of measure', validateUOM: true },
        'Width': { type: 'Text', required: false, desc: 'Part width' },
        'Height': { type: 'Text', required: false, desc: 'Part height' },
        'Len': { type: 'Text', required: false, desc: 'Part length' },
        'SizeUOM': { type: 'Text', required: false, desc: 'Size unit of measure', validateUOM: true },
        'ConsumptionRate': { type: 'Decimal', required: false, desc: 'Consumption rate (numeric)' },

        // Part - Other
        'PartURL': { type: 'Text', required: false, desc: 'URL for the part' },
        'PartRevision': { type: 'Text', required: false, desc: 'Part revision' },
        'PartPictureURL': { type: 'Text', required: false, desc: 'URL to part picture (import only)' },

        // Product Information
        'ProductNumber': { type: 'Text', required: false, desc: 'Product number (70 chars max)' },
        'ProductDescription': { type: 'Text', required: false, desc: 'Product description (252 chars max)' },
        'ProductDetails': { type: 'Text', required: false, desc: 'Additional product details (no limit)' },
        'Price': { type: 'Decimal', required: false, desc: 'Product price (numeric)' },
        'ProductSKU': { type: 'Text', required: false, desc: 'Product SKU (31 chars max)' },
        'ProductUPC': { type: 'Text', required: false, desc: 'Product UPC code (31 chars max)' },
        'ProductActive': { type: 'Text', required: false, desc: 'Whether product is active' },
        'ProductTaxable': { type: 'Text', required: false, desc: 'Whether product is taxable' },
        'ProductSOItemTypeID': { type: 'Integer', required: false, desc: 'Product SO item type ID: 10=Sale, 12=Drop Ship, 20=Credit Return', validValues: ['10', '12', '20'] },
        'IncomeAccount': { type: 'Text', required: false, desc: 'Income account' },

        // Product - Physical Properties (all Text type)
        'ProductWeight': { type: 'Text', required: false, desc: 'Product weight' },
        'ProductWeightUOM': { type: 'Text', required: false, desc: 'Product weight UOM', validateUOM: true },
        'ProductWidth': { type: 'Text', required: false, desc: 'Product width' },
        'ProductHeight': { type: 'Text', required: false, desc: 'Product height' },
        'ProductLen': { type: 'Text', required: false, desc: 'Product length' },
        'ProductSizeUOM': { type: 'Text', required: false, desc: 'Product size UOM', validateUOM: true },
        'ProductPictureURL': { type: 'Text', required: false, desc: 'Product picture URL (import only)' },

        // Vendor Pricing Information
        'Vendor': { type: 'Text', required: false, desc: 'Vendor name (41 chars / 30 chars max)', validateVendor: true },
        'DefaultVendor': { type: 'Text', required: false, desc: 'Whether this is the default vendor' },
        'VendorPartNumber': { type: 'Text', required: false, desc: 'Vendor part number (70 chars / 30 chars max)' },
        'Cost': { type: 'Decimal', required: false, desc: 'Vendor cost (numeric)' },
        'VendorUOM': { type: 'Text', required: false, desc: 'Vendor UOM (10 chars max)', validateUOM: true }
    };

    // Global state
    let csvData = [];
    let csvHeaders = [];
    let validationResults = [];
    let consolidatedIssues = {};
    let fishbowlData = {
        uoms: [],
        vendors: [],
        customFields: [],
        uomConversions: [],
        taxCodes: [],
        partTypes: []
    };

    // Performance optimization settings
    const BATCH_SIZE = 200; // Process 200 rows at a time
    const ROW_HEIGHT = 35; // Approximate height of each table row in pixels
    const BUFFER_ROWS = 20; // Extra rows to render above/below viewport

    // Virtual scrolling state
    let virtualScrollState = {
        enabled: false,
        scrollTop: 0,
        viewportHeight: 500,
        totalRows: 0,
        visibleStartIndex: 0,
        visibleEndIndex: 0
    };

    // Sorting state
    let sortState = {
        column: null,
        direction: 'asc' // 'asc' or 'desc'
    };

    // Debounce timer
    let debounceTimer = null;

    // ============================================
    // Initialization
    // ============================================

    window.onload = function() {
        loadFishbowlReferenceData();
        populateColumnReference();
        setupDragAndDrop();
    };

    function setupDragAndDrop() {
        const uploadSection = document.getElementById('uploadSection');

        uploadSection.addEventListener('dragover', function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.add('dragover');
        });

        uploadSection.addEventListener('dragleave', function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.remove('dragover');
        });

        uploadSection.addEventListener('drop', function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.remove('dragover');

            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].name.endsWith('.csv')) {
                processFile(files[0]);
            } else {
                alert('Please drop a CSV file.');
            }
        });
    }

    // ============================================
    // Fishbowl Data Loading
    // ============================================

    function loadFishbowlReferenceData() {
        try {
            // Load UOMs
            console.log('Loading UOMs...');
            let uomQuery = `SELECT code FROM uom WHERE activeflag = 1 ORDER BY code`;
            let uomResult = runQuery(uomQuery);
            console.log('UOM query result:', uomResult);
            let uoms = uomResult ? JSON.parse(uomResult) : [];
            if (uoms && !Array.isArray(uoms)) uoms = [uoms];
            fishbowlData.uoms = uoms.map(u => u.code);

            // Load Vendors
            console.log('Loading Vendors...');
            let vendorQuery = `SELECT name FROM vendor WHERE activeflag = 1 ORDER BY name`;
            let vendorResult = runQuery(vendorQuery);
            console.log('Vendor query result:', vendorResult);
            let vendors = vendorResult ? JSON.parse(vendorResult) : [];
            if (vendors && !Array.isArray(vendors)) vendors = [vendors];
            fishbowlData.vendors = vendors.map(v => v.name);

            // Load Custom Fields (for Part)
            console.log('Loading Custom Fields...');
            let cfQuery = `SELECT name FROM customfield WHERE tableid IN (SELECT id FROM systables WHERE name = 'Part') AND activeflag = 1`;
            let cfResult = runQuery(cfQuery);
            console.log('Custom Field query result:', cfResult);
            let customFields = cfResult ? JSON.parse(cfResult) : [];
            if (customFields && !Array.isArray(customFields)) customFields = [customFields];
            fishbowlData.customFields = customFields.map(cf => cf.name);

            // Load UOM Conversions
            console.log('Loading UOM Conversions...');
            let convQuery = `SELECT
                u1.code as fromUom,
                u2.code as toUom
            FROM uomconversion uc
            INNER JOIN uom u1 ON uc.touomid = u1.id
            INNER JOIN uom u2 ON uc.fromuomid = u2.id`;
            let convResult = runQuery(convQuery);
            console.log('UOM Conversion query result:', convResult);
            let conversions = convResult ? JSON.parse(convResult) : [];
            if (conversions && !Array.isArray(conversions)) conversions = [conversions];
            fishbowlData.uomConversions = conversions.map(c => c.fromUom + '->' + c.toUom);

            // Load Tax Codes
            console.log('Loading Tax Codes...');
            let taxQuery = `SELECT code, name FROM taxrate WHERE activeflag = 1 ORDER BY name`;
            console.log('Tax query:', taxQuery);
            let taxResult = runQuery(taxQuery);
            console.log('Tax Code query result (raw):', taxResult);
            console.log('Tax Code result type:', typeof taxResult);

            if (!taxResult) {
                console.warn('Tax query returned null or undefined');
                fishbowlData.taxCodes = [];
            } else {
                let taxCodes = JSON.parse(taxResult);
                console.log('Tax Code query result (parsed):', taxCodes);
                if (taxCodes && !Array.isArray(taxCodes)) taxCodes = [taxCodes];
                fishbowlData.taxCodes = taxCodes; // Keep objects with code and name
            }

            // Load Part Types
            console.log('Loading Part Types...');
            let partTypeQuery = `SELECT id, name FROM parttype ORDER BY name`;
            console.log('Part Type query:', partTypeQuery);
            let partTypeResult = runQuery(partTypeQuery);
            console.log('Part Type query result (raw):', partTypeResult);

            if (!partTypeResult) {
                console.warn('Part Type query returned null or undefined');
                fishbowlData.partTypes = [];
            } else {
                let partTypes = JSON.parse(partTypeResult);
                console.log('Part Type query result (parsed):', partTypes);
                if (partTypes && !Array.isArray(partTypes)) partTypes = [partTypes];
                fishbowlData.partTypes = partTypes; // Keep objects with id and name
            }

            console.log('Loaded Fishbowl reference data:', {
                uoms: fishbowlData.uoms.length,
                vendors: fishbowlData.vendors.length,
                customFields: fishbowlData.customFields.length,
                uomConversions: fishbowlData.uomConversions.length,
                taxCodes: fishbowlData.taxCodes.length,
                partTypes: fishbowlData.partTypes.length
            });

        } catch (e) {
            console.error('Error loading Fishbowl reference data:', e);
            alert('Error loading reference data from Fishbowl: ' + e.message + '\n\nCheck console for details.');
            // Continue with empty data - validation will still work for format checks
        }
    }

    // ============================================
    // File Processing
    // ============================================

    function handleFileSelect(event) {
        const file = event.target.files[0];
        if (file) {
            processFile(file);
        }
    }

    function processFile(file) {
        showLoading('Reading file...');
        document.getElementById('fileName').textContent = file.name;

        const reader = new FileReader();
        reader.onload = async function(e) {
            try {
                showLoading('Parsing CSV...');
                parseCSV(e.target.result);

                showLoading('Validating data...');
                await validateData(); // Now async!

                showLoading('Rendering results...');
                renderResults();

                hideLoading();

            } catch (err) {
                hideLoading();
                hideProgress();
                alert('Error processing file: ' + err.message);
                console.error(err);
            }
        };
        reader.onerror = function() {
            hideLoading();
            alert('Error reading file');
        };
        reader.readAsText(file);
    }

    function parseCSV(text) {
        csvData = [];
        csvHeaders = [];

        // Handle different line endings
        const lines = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');

        if (lines.length === 0) {
            throw new Error('Empty file');
        }

        // Parse header row
        csvHeaders = parseCSVLine(lines[0]);

        // Parse data rows
        for (let i = 1; i < lines.length; i++) {
            const line = lines[i].trim();
            if (line === '') continue;

            const values = parseCSVLine(line);
            const row = { _rowNum: i + 1 };

            csvHeaders.forEach((header, index) => {
                row[header] = values[index] !== undefined ? values[index] : '';
            });

            csvData.push(row);
        }

        console.log('Parsed ' + csvData.length + ' rows with ' + csvHeaders.length + ' columns');
    }

    function parseCSVLine(line) {
        const result = [];
        let current = '';
        let inQuotes = false;

        for (let i = 0; i < line.length; i++) {
            const char = line[i];
            const nextChar = line[i + 1];

            if (inQuotes) {
                if (char === '"' && nextChar === '"') {
                    // Escaped quote
                    current += '"';
                    i++;
                } else if (char === '"') {
                    // End of quoted field
                    inQuotes = false;
                } else {
                    current += char;
                }
            } else {
                if (char === '"') {
                    inQuotes = true;
                } else if (char === ',') {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
        }

        result.push(current.trim());
        return result;
    }

    // ============================================
    // Validation
    // ============================================

    // Validate a single row - helper function
    function validateRow(row, index, missingDeps) {
        const rowResult = {
            rowNum: row._rowNum,
            rowIndex: index,
            status: 'valid',
            errors: [],
            warnings: [],
            cellErrors: {},
            cellWarnings: {}
        };

        // Check all required fields - these generate WARNINGS
        const requiredFields = ['PartNumber', 'PartDescription', 'UOM', 'PartTypeID', 'Active', 'PartTaxCode'];
        requiredFields.forEach(field => {
            if (!row[field] || row[field].trim() === '') {
                rowResult.warnings.push({
                    field: field,
                    message: `Required field is missing`,
                    suggestion: `Provide a value for ${field}`
                });
                rowResult.cellWarnings[field] = true;
            }
        });

        // Validate each column - validation failures generate ERRORS
        csvHeaders.forEach(header => {
            const value = row[header];
            if (!value || value.trim() === '') return; // Skip empty values

            // Check if it's a custom field
            if (header.startsWith('CF-')) {
                const cfName = header.substring(3);
                if (fishbowlData.customFields.length > 0 && !fishbowlData.customFields.includes(cfName)) {
                    rowResult.errors.push({
                        field: header,
                        message: `Custom field "${cfName}" does not exist in Fishbowl`,
                        suggestion: 'Create this custom field in Fishbowl first, or remove this column'
                    });
                    rowResult.cellErrors[header] = true;
                    missingDeps.customFields.add(cfName);
                }
                return;
            }

            const colDef = PPP_COLUMNS[header];
            if (!colDef) {
                // Unknown column - Fishbowl will ignore it, we'll skip validation
                return;
            }

            // Type validation (only if value is not empty)
            const typeError = validateType(value, colDef.type, header);
            if (typeError) {
                rowResult.errors.push(typeError);
                rowResult.cellErrors[header] = true;
            }

            // Valid values check
            if (colDef.validValues && !colDef.validValues.includes(value)) {
                rowResult.errors.push({
                    field: header,
                    message: `Invalid value "${value}"`,
                    suggestion: `Valid values: ${colDef.validValues.join(', ')}`
                });
                rowResult.cellErrors[header] = true;
            }

            // UOM validation
            if (colDef.validateUOM && fishbowlData.uoms.length > 0) {
                if (!fishbowlData.uoms.includes(value)) {
                    rowResult.errors.push({
                        field: header,
                        message: `UOM "${value}" does not exist in Fishbowl`,
                        suggestion: 'Create this UOM first, or use an existing one'
                    });
                    rowResult.cellErrors[header] = true;
                    missingDeps.uoms.add(value);
                }
            }

            // Vendor validation
            if (colDef.validateVendor && fishbowlData.vendors.length > 0) {
                if (!fishbowlData.vendors.some(v => v.toLowerCase() === value.toLowerCase())) {
                    rowResult.errors.push({
                        field: header,
                        message: `Vendor "${value}" does not exist in Fishbowl`,
                        suggestion: 'Create this vendor first, or check spelling'
                    });
                    rowResult.cellErrors[header] = true;
                    missingDeps.vendors.add(value);
                }
            }

            // Tax Code validation
            if (colDef.validateTaxCode && fishbowlData.taxCodes.length > 0) {
                if (!fishbowlData.taxCodes.some(tc => tc.code.toLowerCase() === value.toLowerCase())) {
                    rowResult.errors.push({
                        field: header,
                        message: `Tax code "${value}" does not exist in Fishbowl`,
                        suggestion: 'Select a valid tax code or create this tax code first'
                    });
                    rowResult.cellErrors[header] = true;
                }
            }
        });

        // Check UOM conversions if multiple UOMs are specified
        const partUom = row['UOM'] ? row['UOM'] : null;
        const productUom = row['ProductUOM'] ? row['ProductUOM'] : null;
        const vendorUom = row['VendorUOM'] ? row['VendorUOM'] : null;

        if (partUom && productUom && partUom !== productUom) {
            const convKey = partUom + '->' + productUom;
            const revConvKey = productUom + '->' + partUom;
            if (fishbowlData.uomConversions.length > 0 &&
                !fishbowlData.uomConversions.includes(convKey) &&
                !fishbowlData.uomConversions.includes(revConvKey)) {
                rowResult.warnings.push({
                    field: 'ProductUOM',
                    message: `UOM conversion from ${partUom} to ${productUom} may not exist`,
                    suggestion: 'Ensure UOM conversion exists in Fishbowl'
                });
                rowResult.cellWarnings['ProductUOM'] = true;
                missingDeps.uomConversions.add(partUom + ' <-> ' + productUom);
            }
        }

        if (partUom && vendorUom && partUom !== vendorUom) {
            const convKey = partUom + '->' + vendorUom;
            const revConvKey = vendorUom + '->' + partUom;
            if (fishbowlData.uomConversions.length > 0 &&
                !fishbowlData.uomConversions.includes(convKey) &&
                !fishbowlData.uomConversions.includes(revConvKey)) {
                rowResult.warnings.push({
                    field: 'VendorUOM',
                    message: `UOM conversion from ${partUom} to ${vendorUom} may not exist`,
                    suggestion: 'Ensure UOM conversion exists in Fishbowl'
                });
                rowResult.cellWarnings['VendorUOM'] = true;
                missingDeps.uomConversions.add(partUom + ' <-> ' + vendorUom);
            }
        }

        // Set overall status
        if (rowResult.errors.length > 0) {
            rowResult.status = 'error';
        } else if (rowResult.warnings.length > 0) {
            rowResult.status = 'warning';
        }

        return rowResult;
    }

    // Batched async validation with progress indicator
    async function validateData() {
        validationResults = [];

        const missingDeps = {
            uoms: new Set(),
            vendors: new Set(),
            customFields: new Set(),
            uomConversions: new Set()
        };

        const totalRows = csvData.length;
        const enableVirtualScroll = totalRows > 500; // Enable virtual scroll for large datasets

        console.log(`Validating ${totalRows} rows (batch size: ${BATCH_SIZE})...`);

        // Process rows in batches
        for (let i = 0; i < totalRows; i += BATCH_SIZE) {
            const batchEnd = Math.min(i + BATCH_SIZE, totalRows);
            const batch = csvData.slice(i, batchEnd);

            // Validate batch
            batch.forEach((row, batchIndex) => {
                const globalIndex = i + batchIndex;
                const rowResult = validateRow(row, globalIndex, missingDeps);
                validationResults.push(rowResult);
            });

            // Update progress
            showProgress(batchEnd, totalRows);

            // Allow UI to update between batches (prevents freezing)
            if (batchEnd < totalRows) {
                await sleep(10);
            }
        }

        // Enable/disable virtual scrolling based on dataset size
        virtualScrollState.enabled = enableVirtualScroll;
        virtualScrollState.totalRows = totalRows;

        console.log(`Validation complete. Virtual scrolling: ${enableVirtualScroll ? 'enabled' : 'disabled'}`);
        hideProgress();
    }

    function validateType(value, type, field) {
        switch (type) {
            case 'Integer':
                if (!/^-?\d+$/.test(value)) {
                    return {
                        field: field,
                        message: `"${value}" is not a valid integer`,
                        suggestion: 'Use whole numbers only (e.g., 1, 10, 100)'
                    };
                }
                break;

            case 'Decimal':
            case 'Currency':
            case 'Percentage':
                // Remove currency symbols and commas for validation
                const cleanValue = value.replace(/[$,]/g, '');
                if (!/^-?\d*\.?\d+$/.test(cleanValue)) {
                    return {
                        field: field,
                        message: `"${value}" is not a valid number`,
                        suggestion: 'Use numeric format (e.g., 10.50)'
                    };
                }
                break;

            case 'Boolean':
                const boolValues = ['true', 'false', '1', '0', 'yes', 'no'];
                if (!boolValues.includes(value.toLowerCase())) {
                    return {
                        field: field,
                        message: `"${value}" is not a valid boolean`,
                        suggestion: 'Use true/false, 1/0, or yes/no'
                    };
                }
                break;

            case 'Date':
                // Basic date validation - could be enhanced
                const dateRegex = /^\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}$|^\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2}$/;
                if (!dateRegex.test(value)) {
                    return {
                        field: field,
                        message: `"${value}" is not a valid date format`,
                        suggestion: 'Use MM/DD/YYYY or YYYY-MM-DD format'
                    };
                }
                break;
        }
        return null;
    }

    // ============================================
    // Rendering
    // ============================================

    function renderResults() {
        // Show sections
        document.getElementById('summaryStats').classList.remove('hidden');
        document.getElementById('filterControls').classList.remove('hidden');
        document.getElementById('resultsSection').classList.remove('hidden');
        document.getElementById('actionButtons').classList.remove('hidden');

        // Update stats
        const totalRows = validationResults.length;
        const validRows = validationResults.filter(r => r.status === 'valid').length;
        const warningRows = validationResults.filter(r => r.status === 'warning').length;
        const errorRows = validationResults.filter(r => r.status === 'error').length;

        document.getElementById('statTotal').textContent = totalRows;
        document.getElementById('statValid').textContent = validRows;
        document.getElementById('statWarning').textContent = warningRows;
        document.getElementById('statError').textContent = errorRows;

        // Enable/disable export buttons
        document.getElementById('exportValidBtn').disabled = validRows === 0;

        // Consolidate and render issues
        consolidateIssues();
        renderConsolidatedIssues();

        // Render table with default filter (errors only)
        applyFilters();
    }

    // ============================================
    // Consolidated Issues
    // ============================================

    function consolidateIssues() {
        consolidatedIssues = {};

        validationResults.forEach(result => {
            // Consolidate errors
            result.errors.forEach(error => {
                const key = `${error.field}:${error.message}`;
                if (!consolidatedIssues[key]) {
                    consolidatedIssues[key] = {
                        type: 'error',
                        field: error.field,
                        message: error.message,
                        suggestion: error.suggestion,
                        values: new Set(),
                        rowCount: 0
                    };
                }
                // Track unique values that caused the issue
                const row = csvData[result.rowIndex];
                if (row[error.field]) {
                    consolidatedIssues[key].values.add(row[error.field]);
                }
                consolidatedIssues[key].rowCount++;
            });

            // Consolidate warnings
            result.warnings.forEach(warning => {
                const key = `${warning.field}:${warning.message}`;
                if (!consolidatedIssues[key]) {
                    consolidatedIssues[key] = {
                        type: 'warning',
                        field: warning.field,
                        message: warning.message,
                        suggestion: warning.suggestion,
                        values: new Set(),
                        rowCount: 0
                    };
                }
                const row = csvData[result.rowIndex];
                if (row[warning.field]) {
                    consolidatedIssues[key].values.add(row[warning.field]);
                }
                consolidatedIssues[key].rowCount++;
            });
        });
    }

    function renderConsolidatedIssues() {
        const panel = document.getElementById('consolidatedIssues');
        const content = document.getElementById('consolidatedIssuesContent');

        // Sort issues by row count (most frequent first)
        const sortedIssues = Object.values(consolidatedIssues).sort((a, b) => b.rowCount - a.rowCount);

        if (sortedIssues.length === 0) {
            panel.classList.add('hidden');
            return;
        }

        panel.classList.remove('hidden');

        let html = '';
        sortedIssues.forEach(issue => {
            const groupClass = issue.type === 'warning' ? 'warning-group' : '';
            const valuesArray = Array.from(issue.values);

            // Determine action buttons based on issue type
            let actionButtons = '';

            // Missing required fields (warnings)
            if (issue.field === 'Active' && issue.message.includes('Required field is missing')) {
                actionButtons = `
                    <button class="issue-action-btn fix" onclick="setActiveToTrue()" title="Set all empty Active cells to TRUE">
                        ‚úì Set to TRUE
                    </button>
                    <button class="issue-action-btn fix" onclick="setActiveToFalse()" title="Set all empty Active cells to FALSE">
                        ‚úó Set to FALSE
                    </button>
                `;
            } else if (issue.field === 'PartTaxCode' && issue.message.includes('Required field is missing')) {
                actionButtons = `
                    <button class="issue-action-btn fix" onclick="fillPartTaxCode()" title="Fill in tax codes from dropdown">
                        üìã Select Tax Code
                    </button>
                `;
            } else if (issue.field === 'PartTypeID' && issue.message.includes('Required field is missing')) {
                actionButtons = `
                    <button class="issue-action-btn fix" onclick="fillPartTypeID()" title="Fill in part type from dropdown">
                        üìã Select Part Type
                    </button>
                `;
            } else if (issue.field === 'UOM' && issue.message.includes('Required field is missing')) {
                actionButtons = `
                    <button class="issue-action-btn fix" onclick="fillUOM()" title="Fill in UOM from dropdown">
                        üìã Select UOM
                    </button>
                `;
            }
            // Validation errors
            else if (issue.message.includes('UOM') && issue.message.includes('does not exist')) {
                actionButtons = `
                    <button class="issue-action-btn create" onclick="createUOM()" title="Create missing UOM(s) in Fishbowl">
                        ‚ûï Create UOM
                    </button>
                    <button class="issue-action-btn map" onclick="mapUOM()" title="Map to existing UOM">
                        üîó Map to Existing
                    </button>
                `;
            } else if (issue.message.includes('Vendor') && issue.message.includes('does not exist')) {
                actionButtons = `
                    <button class="issue-action-btn create" onclick="createVendor()" title="Create missing vendor(s) in Fishbowl">
                        ‚ûï Create Vendor
                    </button>
                    <button class="issue-action-btn map" onclick="mapVendor()" title="Map to existing vendor">
                        üîó Map to Existing
                    </button>
                `;
            } else if (issue.message.includes('Tax code') && issue.message.includes('does not exist')) {
                actionButtons = `
                    <button class="issue-action-btn map" onclick="mapTaxCode()" title="Map to existing tax code">
                        üîó Map to Existing
                    </button>
                `;
            } else if (issue.message.includes('Custom field') && issue.message.includes('does not exist')) {
                actionButtons = `
                    <button class="issue-action-btn create" onclick="createCustomField()" title="Create missing custom field in Fishbowl">
                        ‚ûï Create Custom Field
                    </button>
                `;
            } else if (issue.message.includes('Invalid value') || issue.message.includes('not a valid')) {
                actionButtons = `
                    <button class="issue-action-btn fix" onclick="fixValues()" title="Fix invalid values">
                        üîß Fix Values
                    </button>
                `;
            } else if (issue.message.includes('conversion') && issue.message.includes('may not exist')) {
                actionButtons = `
                    <button class="issue-action-btn create" onclick="createUOMConversion()" title="Create UOM conversion in Fishbowl">
                        ‚ûï Create Conversion
                    </button>
                `;
            }

            html += `
                <div class="issue-group ${groupClass}">
                    <div class="issue-group-header">
                        <div>
                            <span class="issue-group-title">${issue.field}: ${issue.message}</span>
                            <span class="issue-count">${issue.rowCount} row${issue.rowCount > 1 ? 's' : ''}</span>
                        </div>
                        ${actionButtons ? `<div class="issue-actions">${actionButtons}</div>` : ''}
                    </div>
                    ${valuesArray.length > 0 ? `
                        <div class="issue-items">
                            ${valuesArray.slice(0, 10).map(v => `<span class="issue-value">${escapeHtml(v)}</span>`).join('')}
                            ${valuesArray.length > 10 ? `<span class="issue-value">+${valuesArray.length - 10} more</span>` : ''}
                        </div>
                    ` : ''}
                    ${issue.suggestion ? `<div style="color: var(--fb-success); font-size: 12px; margin-top: 5px;">üí° ${issue.suggestion}</div>` : ''}
                </div>
            `;
        });

        content.innerHTML = html;
    }

    // Action button handlers - Fill missing required fields

    function setActiveToTrue() {
        if (csvData.length === 0) {
            alert('No data loaded.');
            return;
        }

        let count = 0;
        csvData.forEach(row => {
            if (!row['Active'] || row['Active'].trim() === '') {
                row['Active'] = 'TRUE';
                count++;
            }
        });

        if (count > 0) {
            alert(`Set ${count} empty Active cells to TRUE`);
            revalidateData();
        } else {
            alert('No empty Active cells found.');
        }
    }

    function setActiveToFalse() {
        if (csvData.length === 0) {
            alert('No data loaded.');
            return;
        }

        let count = 0;
        csvData.forEach(row => {
            if (!row['Active'] || row['Active'].trim() === '') {
                row['Active'] = 'FALSE';
                count++;
            }
        });

        if (count > 0) {
            alert(`Set ${count} empty Active cells to FALSE`);
            revalidateData();
        } else {
            alert('No empty Active cells found.');
        }
    }

    function fillPartTaxCode() {
        if (csvData.length === 0) {
            alert('No data loaded.');
            return;
        }

        if (fishbowlData.taxCodes.length === 0) {
            alert('No tax codes loaded from Fishbowl. Please check your database connection.');
            return;
        }

        // Count empty cells
        const emptyCount = csvData.filter(row => !row['PartTaxCode'] || row['PartTaxCode'].trim() === '').length;
        if (emptyCount === 0) {
            alert('No empty PartTaxCode cells found.');
            return;
        }

        // Build dropdown options (show name, but use code)
        const options = fishbowlData.taxCodes
            .map(tc => `<option value="${escapeHtml(tc.code)}">${escapeHtml(tc.name)} (${escapeHtml(tc.code)})</option>`)
            .join('');

        showModal(
            'Fill PartTaxCode',
            `
                <p>Select a tax code to fill ${emptyCount} empty PartTaxCode cells:</p>
                <select id="modalSelect" style="width: 100%; padding: 8px; font-size: 14px; margin-top: 10px;">
                    <option value="">-- Select Tax Code --</option>
                    ${options}
                </select>
            `,
            function() {
                const selectedCode = document.getElementById('modalSelect').value;
                if (!selectedCode) {
                    alert('Please select a tax code.');
                    return false;
                }

                let count = 0;
                csvData.forEach(row => {
                    if (!row['PartTaxCode'] || row['PartTaxCode'].trim() === '') {
                        row['PartTaxCode'] = selectedCode;
                        count++;
                    }
                });

                alert(`Filled ${count} empty PartTaxCode cells with "${selectedCode}"`);
                revalidateData();
                return true;
            }
        );
    }

    function fillPartTypeID() {
        if (csvData.length === 0) {
            alert('No data loaded.');
            return;
        }

        if (fishbowlData.partTypes.length === 0) {
            alert('No part types loaded from Fishbowl. Please check your database connection.');
            return;
        }

        // Count empty cells
        const emptyCount = csvData.filter(row => !row['PartTypeID'] || row['PartTypeID'].trim() === '').length;
        if (emptyCount === 0) {
            alert('No empty PartTypeID cells found.');
            return;
        }

        // Build dropdown options (show name, but use id)
        const options = fishbowlData.partTypes
            .map(pt => `<option value="${pt.id}">${escapeHtml(pt.name)} (${pt.id})</option>`)
            .join('');

        showModal(
            'Fill PartTypeID',
            `
                <p>Select a part type to fill ${emptyCount} empty PartTypeID cells:</p>
                <select id="modalSelect" style="width: 100%; padding: 8px; font-size: 14px; margin-top: 10px;">
                    <option value="">-- Select Part Type --</option>
                    ${options}
                </select>
            `,
            function() {
                const selectedId = document.getElementById('modalSelect').value;
                if (!selectedId) {
                    alert('Please select a part type.');
                    return false;
                }

                let count = 0;
                csvData.forEach(row => {
                    if (!row['PartTypeID'] || row['PartTypeID'].trim() === '') {
                        row['PartTypeID'] = selectedId;
                        count++;
                    }
                });

                alert(`Filled ${count} empty PartTypeID cells with "${selectedId}"`);
                revalidateData();
                return true;
            }
        );
    }

    function fillUOM() {
        if (csvData.length === 0) {
            alert('No data loaded.');
            return;
        }

        if (fishbowlData.uoms.length === 0) {
            alert('No UOMs loaded from Fishbowl. Please check your database connection.');
            return;
        }

        // Count empty cells
        const emptyCount = csvData.filter(row => !row['UOM'] || row['UOM'].trim() === '').length;
        if (emptyCount === 0) {
            alert('No empty UOM cells found.');
            return;
        }

        // Build dropdown options (use UOM code/name)
        const options = fishbowlData.uoms
            .map(uom => `<option value="${escapeHtml(uom)}">${escapeHtml(uom)}</option>`)
            .join('');

        showModal(
            'Fill UOM',
            `
                <p>Select a UOM to fill ${emptyCount} empty UOM cells:</p>
                <select id="modalSelect" style="width: 100%; padding: 8px; font-size: 14px; margin-top: 10px;">
                    <option value="">-- Select UOM --</option>
                    ${options}
                </select>
            `,
            function() {
                const selectedUom = document.getElementById('modalSelect').value;
                if (!selectedUom) {
                    alert('Please select a UOM.');
                    return false;
                }

                let count = 0;
                csvData.forEach(row => {
                    if (!row['UOM'] || row['UOM'].trim() === '') {
                        row['UOM'] = selectedUom;
                        count++;
                    }
                });

                alert(`Filled ${count} empty UOM cells with "${selectedUom}"`);
                revalidateData();
                return true;
            }
        );
    }

    // Modal dialog helper
    function showModal(title, content, onConfirm) {
        // Create modal HTML
        const modal = document.createElement('div');
        modal.id = 'fixModal';
        modal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        `;

        modal.innerHTML = `
            <div style="
                background: white;
                padding: 25px;
                border-radius: 8px;
                max-width: 500px;
                width: 90%;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            ">
                <h3 style="margin-top: 0; color: var(--fb-primary);">${title}</h3>
                <div style="margin: 15px 0;">
                    ${content}
                </div>
                <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                    <button id="modalCancel" style="
                        padding: 8px 20px;
                        border: 1px solid var(--fb-border);
                        background: white;
                        border-radius: 4px;
                        cursor: pointer;
                    ">Cancel</button>
                    <button id="modalConfirm" style="
                        padding: 8px 20px;
                        border: none;
                        background: var(--fb-primary);
                        color: white;
                        border-radius: 4px;
                        cursor: pointer;
                    ">Apply</button>
                </div>
            </div>
        `;

        document.body.appendChild(modal);

        // Handle buttons
        document.getElementById('modalCancel').onclick = function() {
            document.body.removeChild(modal);
        };

        document.getElementById('modalConfirm').onclick = function() {
            const shouldClose = onConfirm();
            if (shouldClose !== false) {
                document.body.removeChild(modal);
            }
        };

        // Close on background click
        modal.onclick = function(e) {
            if (e.target === modal) {
                document.body.removeChild(modal);
            }
        };
    }

    // Create/map missing data
    function createUOM() {
        alert('Create UOM functionality will be implemented here');
    }

    function mapUOM() {
        if (csvData.length === 0) {
            alert('No data loaded.');
            return;
        }

        if (fishbowlData.uoms.length === 0) {
            alert('No UOMs loaded from Fishbowl. Please check your database connection.');
            return;
        }

        // Find all invalid UOMs
        const invalidUoms = new Set();
        validationResults.forEach(result => {
            result.errors.forEach(error => {
                if (error.field && (error.field === 'UOM' || error.field.includes('UOM')) &&
                    error.message.includes('does not exist')) {
                    const row = csvData[result.rowIndex];
                    if (row[error.field]) {
                        invalidUoms.add(row[error.field]);
                    }
                }
            });
        });

        if (invalidUoms.size === 0) {
            alert('No invalid UOMs found.');
            return;
        }

        // Build mapping UI
        const invalidList = Array.from(invalidUoms);
        const uomOptions = fishbowlData.uoms
            .map(uom => `<option value="${escapeHtml(uom)}">${escapeHtml(uom)}</option>`)
            .join('');

        let mappingHtml = '<div style="max-height: 400px; overflow-y: auto;">';
        mappingHtml += '<p>Map invalid UOMs to existing ones:</p>';
        invalidList.forEach(invalid => {
            mappingHtml += `
                <div style="margin: 10px 0; display: flex; align-items: center; gap: 10px;">
                    <strong style="width: 150px;">${escapeHtml(invalid)}</strong>
                    <span>‚Üí</span>
                    <select class="uom-mapping" data-invalid="${escapeHtml(invalid)}" style="flex: 1; padding: 6px;">
                        <option value="">-- Select UOM --</option>
                        ${uomOptions}
                    </select>
                </div>
            `;
        });
        mappingHtml += '</div>';

        showModal(
            'Map Invalid UOMs',
            mappingHtml,
            function() {
                const mappings = {};
                const selects = document.querySelectorAll('.uom-mapping');

                selects.forEach(select => {
                    const invalid = select.getAttribute('data-invalid');
                    const valid = select.value;
                    if (valid) {
                        mappings[invalid] = valid;
                    }
                });

                if (Object.keys(mappings).length === 0) {
                    alert('No mappings selected.');
                    return false;
                }

                // Apply mappings
                let count = 0;
                csvData.forEach(row => {
                    csvHeaders.forEach(header => {
                        if ((header === 'UOM' || header.includes('UOM')) && row[header] && mappings[row[header]]) {
                            row[header] = mappings[row[header]];
                            count++;
                        }
                    });
                });

                alert(`Mapped ${count} UOM values`);
                revalidateData();
                return true;
            }
        );
    }

    function createVendor() {
        alert('Create Vendor functionality will be implemented here');
    }

    function mapVendor() {
        if (csvData.length === 0) {
            alert('No data loaded.');
            return;
        }

        if (fishbowlData.vendors.length === 0) {
            alert('No vendors loaded from Fishbowl. Please check your database connection.');
            return;
        }

        // Find all invalid vendors
        const invalidVendors = new Set();
        validationResults.forEach(result => {
            result.errors.forEach(error => {
                if (error.field === 'Vendor' && error.message.includes('does not exist')) {
                    const row = csvData[result.rowIndex];
                    if (row[error.field]) {
                        invalidVendors.add(row[error.field]);
                    }
                }
            });
        });

        if (invalidVendors.size === 0) {
            alert('No invalid vendors found.');
            return;
        }

        // Build mapping UI
        const invalidList = Array.from(invalidVendors);
        const vendorOptions = fishbowlData.vendors
            .map(vendor => `<option value="${escapeHtml(vendor)}">${escapeHtml(vendor)}</option>`)
            .join('');

        let mappingHtml = '<div style="max-height: 400px; overflow-y: auto;">';
        mappingHtml += '<p>Map invalid vendors to existing ones:</p>';
        invalidList.forEach(invalid => {
            mappingHtml += `
                <div style="margin: 10px 0; display: flex; align-items: center; gap: 10px;">
                    <strong style="width: 150px;">${escapeHtml(invalid)}</strong>
                    <span>‚Üí</span>
                    <select class="vendor-mapping" data-invalid="${escapeHtml(invalid)}" style="flex: 1; padding: 6px;">
                        <option value="">-- Select Vendor --</option>
                        ${vendorOptions}
                    </select>
                </div>
            `;
        });
        mappingHtml += '</div>';

        showModal(
            'Map Invalid Vendors',
            mappingHtml,
            function() {
                const mappings = {};
                const selects = document.querySelectorAll('.vendor-mapping');

                selects.forEach(select => {
                    const invalid = select.getAttribute('data-invalid');
                    const valid = select.value;
                    if (valid) {
                        mappings[invalid] = valid;
                    }
                });

                if (Object.keys(mappings).length === 0) {
                    alert('No mappings selected.');
                    return false;
                }

                // Apply mappings
                let count = 0;
                csvData.forEach(row => {
                    if (row['Vendor'] && mappings[row['Vendor']]) {
                        row['Vendor'] = mappings[row['Vendor']];
                        count++;
                    }
                });

                alert(`Mapped ${count} vendor values`);
                revalidateData();
                return true;
            }
        );
    }

    function mapTaxCode() {
        if (csvData.length === 0) {
            alert('No data loaded.');
            return;
        }

        if (fishbowlData.taxCodes.length === 0) {
            alert('No tax codes loaded from Fishbowl. Please check your database connection.');
            return;
        }

        // Find all invalid tax codes
        const invalidTaxCodes = new Set();
        validationResults.forEach(result => {
            result.errors.forEach(error => {
                if (error.field === 'PartTaxCode' && error.message.includes('does not exist')) {
                    const row = csvData[result.rowIndex];
                    if (row[error.field]) {
                        invalidTaxCodes.add(row[error.field]);
                    }
                }
            });
        });

        if (invalidTaxCodes.size === 0) {
            alert('No invalid tax codes found.');
            return;
        }

        // Build mapping UI
        const invalidList = Array.from(invalidTaxCodes);
        const taxOptions = fishbowlData.taxCodes
            .map(tc => `<option value="${escapeHtml(tc.code)}">${escapeHtml(tc.name)} (${escapeHtml(tc.code)})</option>`)
            .join('');

        let mappingHtml = '<div style="max-height: 400px; overflow-y: auto;">';
        mappingHtml += '<p>Map invalid tax codes to existing ones:</p>';
        invalidList.forEach(invalid => {
            mappingHtml += `
                <div style="margin: 10px 0; display: flex; align-items: center; gap: 10px;">
                    <strong style="width: 150px;">${escapeHtml(invalid)}</strong>
                    <span>‚Üí</span>
                    <select class="tax-mapping" data-invalid="${escapeHtml(invalid)}" style="flex: 1; padding: 6px;">
                        <option value="">-- Select Tax Code --</option>
                        ${taxOptions}
                    </select>
                </div>
            `;
        });
        mappingHtml += '</div>';

        showModal(
            'Map Invalid Tax Codes',
            mappingHtml,
            function() {
                const mappings = {};
                const selects = document.querySelectorAll('.tax-mapping');

                selects.forEach(select => {
                    const invalid = select.getAttribute('data-invalid');
                    const valid = select.value;
                    if (valid) {
                        mappings[invalid] = valid;
                    }
                });

                if (Object.keys(mappings).length === 0) {
                    alert('No mappings selected.');
                    return false;
                }

                // Apply mappings
                let count = 0;
                csvData.forEach(row => {
                    if (row['PartTaxCode'] && mappings[row['PartTaxCode']]) {
                        row['PartTaxCode'] = mappings[row['PartTaxCode']];
                        count++;
                    }
                });

                alert(`Mapped ${count} tax code values`);
                revalidateData();
                return true;
            }
        );
    }

    function createCustomField() {
        alert('Create Custom Field functionality will be implemented here');
    }

    function fixValues() {
        alert('Fix Values functionality will be implemented here');
    }

    function createUOMConversion() {
        alert('Create UOM Conversion functionality will be implemented here');
    }

    // ============================================
    // Column Sorting and Quick Fill
    // ============================================

    function sortBy(column) {
        // Toggle direction if same column, otherwise default to ascending
        if (sortState.column === column) {
            sortState.direction = sortState.direction === 'asc' ? 'desc' : 'asc';
        } else {
            sortState.column = column;
            sortState.direction = 'asc';
        }

        // Sort validationResults based on column
        validationResults.sort((a, b) => {
            let aVal, bVal;

            if (column === 'rowNum') {
                aVal = a.rowNum;
                bVal = b.rowNum;
            } else {
                // Get values from csvData
                aVal = csvData[a.rowIndex][column] || '';
                bVal = csvData[b.rowIndex][column] || '';

                // Convert to lowercase for case-insensitive string comparison
                if (typeof aVal === 'string') aVal = aVal.toLowerCase();
                if (typeof bVal === 'string') bVal = bVal.toLowerCase();
            }

            // Compare
            if (aVal < bVal) return sortState.direction === 'asc' ? -1 : 1;
            if (aVal > bVal) return sortState.direction === 'asc' ? 1 : -1;
            return 0;
        });

        // Re-render with current filters
        applyFilters();
    }

    function quickFillColumn(column, value) {
        if (!value) return; // Empty selection, do nothing

        // Count ALL empty cells across entire dataset
        let emptyCount = 0;
        let nonEmptyCount = 0;
        let sampleNonEmpty = [];

        csvData.forEach(row => {
            const cellValue = row[column];
            // Check if empty: undefined, null, empty string, or whitespace only
            if (cellValue === undefined || cellValue === null || cellValue === '' || (typeof cellValue === 'string' && cellValue.trim() === '')) {
                emptyCount++;
            } else {
                nonEmptyCount++;
                // Collect sample of non-empty values for debugging
                if (sampleNonEmpty.length < 5) {
                    sampleNonEmpty.push(`"${cellValue}" (length: ${cellValue.length})`);
                }
            }
        });

        console.log(`Quick-fill check: Column="${column}", Value="${value}", EmptyCount=${emptyCount}, NonEmptyCount=${nonEmptyCount}, TotalRows=${csvData.length}`);
        if (sampleNonEmpty.length > 0) {
            console.log(`Sample non-empty ${column} values:`, sampleNonEmpty.join(', '));
        }

        if (emptyCount === 0) {
            alert(`No empty ${column} cells found in the dataset.\n\nAll cells contain values. Check debug console for details.`);
            return;
        }

        // Confirm with user - make it clear it fills ALL rows (including hidden)
        const msg = `Fill ${emptyCount} empty ${column} cells with "${value}"?\n\nThis will fill ALL empty cells across the entire dataset\n(including rows not currently visible due to filters).`;
        if (!confirm(msg)) {
            return;
        }

        // Fill ALL empty cells
        let filledCount = 0;
        csvData.forEach(row => {
            const cellValue = row[column];
            if (cellValue === undefined || cellValue === null || cellValue === '' || (typeof cellValue === 'string' && cellValue.trim() === '')) {
                row[column] = value;
                filledCount++;
            }
        });

        console.log(`Quick-filled ${filledCount} ${column} cells with "${value}"`);

        // Re-validate and render
        debouncedRevalidate();

        // Reset dropdown
        event.target.value = '';
    }

    // ============================================
    // Results Table Rendering
    // ============================================

    function renderTable(results) {
        const thead = document.getElementById('tableHeader');
        const tbody = document.getElementById('tableBody');
        const tableContainer = document.querySelector('.results-table-container');

        // Build header - show status, row number, then visible columns (limit to avoid overflow)
        let visibleHeaders = ['PartNumber', 'PartDescription'];

        // Add other headers that have data
        csvHeaders.forEach(header => {
            if (!visibleHeaders.includes(header)) {
                const hasData = csvData.some(row => row[header] && row[header].trim() !== '');
                if (hasData) {
                    visibleHeaders.push(header);
                }
            }
        });

        // Limit columns for display (show first 10)
        const displayHeaders = visibleHeaders.slice(0, 10);
        const hasMoreColumns = visibleHeaders.length > 10;

        // Build sortable headers with quick-fill dropdowns
        let headerRow1 = '<tr>';
        headerRow1 += '<th class="row-status">Status</th>';
        headerRow1 += '<th onclick="sortBy(\'rowNum\')" style="cursor: pointer;">Row ' + (sortState.column === 'rowNum' ? (sortState.direction === 'asc' ? '‚ñ≤' : '‚ñº') : '') + '</th>';

        displayHeaders.forEach(h => {
            const sortIndicator = sortState.column === h ? (sortState.direction === 'asc' ? '‚ñ≤' : '‚ñº') : '';
            headerRow1 += `<th onclick="sortBy('${h}')" style="cursor: pointer;">${h} ${sortIndicator}</th>`;
        });

        if (hasMoreColumns) headerRow1 += '<th>...</th>';
        headerRow1 += '<th>Issues</th>';
        headerRow1 += '</tr>';

        // Second row: Quick-fill dropdowns for applicable columns
        let headerRow2 = '<tr class="quick-fill-row">';
        headerRow2 += '<th></th><th></th>'; // Status and Row columns

        displayHeaders.forEach(h => {
            const colDef = PPP_COLUMNS[h];
            let dropdown = '';

            // Add dropdown for columns with valid values or specific known columns
            if (h === 'Active') {
                dropdown = `<select onchange="quickFillColumn('${h}', this.value)" style="width: 100%; font-size: 11px; padding: 2px;">
                    <option value="">Quick Fill...</option>
                    <option value="TRUE">Fill empty ‚Üí TRUE</option>
                    <option value="FALSE">Fill empty ‚Üí FALSE</option>
                </select>`;
            } else if (h === 'PartTaxCode' && fishbowlData.taxCodes.length > 0) {
                const taxOpts = fishbowlData.taxCodes.map(tc =>
                    `<option value="${escapeHtml(tc.code)}">${escapeHtml(tc.name)}</option>`
                ).join('');
                dropdown = `<select onchange="quickFillColumn('${h}', this.value)" style="width: 100%; font-size: 11px; padding: 2px;">
                    <option value="">Quick Fill...</option>
                    ${taxOpts}
                </select>`;
            } else if (h === 'PartTypeID' && fishbowlData.partTypes.length > 0) {
                const ptOpts = fishbowlData.partTypes.map(pt =>
                    `<option value="${pt.id}">${escapeHtml(pt.name)}</option>`
                ).join('');
                dropdown = `<select onchange="quickFillColumn('${h}', this.value)" style="width: 100%; font-size: 11px; padding: 2px;">
                    <option value="">Quick Fill...</option>
                    ${ptOpts}
                </select>`;
            } else if (h === 'UOM' && fishbowlData.uoms.length > 0) {
                const uomOpts = fishbowlData.uoms.map(uom =>
                    `<option value="${escapeHtml(uom)}">${escapeHtml(uom)}</option>`
                ).join('');
                dropdown = `<select onchange="quickFillColumn('${h}', this.value)" style="width: 100%; font-size: 11px; padding: 2px;">
                    <option value="">Quick Fill...</option>
                    ${uomOpts}
                </select>`;
            } else if (colDef && colDef.validValues) {
                const valOpts = colDef.validValues.map(v =>
                    `<option value="${escapeHtml(v)}">${escapeHtml(v)}</option>`
                ).join('');
                dropdown = `<select onchange="quickFillColumn('${h}', this.value)" style="width: 100%; font-size: 11px; padding: 2px;">
                    <option value="">Quick Fill...</option>
                    ${valOpts}
                </select>`;
            }

            headerRow2 += `<th style="padding: 2px;">${dropdown}</th>`;
        });

        if (hasMoreColumns) headerRow2 += '<th></th>';
        headerRow2 += '<th></th>'; // Issues column
        headerRow2 += '</tr>';

        thead.innerHTML = headerRow1 + headerRow2;

        // Virtual scrolling: determine which rows to render
        let rowsToRender = results;
        let startIndex = 0;
        let endIndex = results.length;

        if (virtualScrollState.enabled && tableContainer) {
            // Calculate visible range based on scroll position
            const scrollTop = virtualScrollState.scrollTop;
            const viewportHeight = virtualScrollState.viewportHeight;

            startIndex = Math.floor(scrollTop / ROW_HEIGHT) - BUFFER_ROWS;
            endIndex = Math.ceil((scrollTop + viewportHeight) / ROW_HEIGHT) + BUFFER_ROWS;

            startIndex = Math.max(0, startIndex);
            endIndex = Math.min(results.length, endIndex);

            rowsToRender = results.slice(startIndex, endIndex);

            virtualScrollState.visibleStartIndex = startIndex;
            virtualScrollState.visibleEndIndex = endIndex;
        }

        // Build body
        let html = '';

        // Add top spacer for virtual scrolling
        if (virtualScrollState.enabled && startIndex > 0) {
            const spacerHeight = startIndex * ROW_HEIGHT;
            html += `<tr><td colspan="${displayHeaders.length + 4}" style="height: ${spacerHeight}px; padding: 0;"></td></tr>`;
        }

        rowsToRender.forEach((result, displayIdx) => {
            const idx = virtualScrollState.enabled ? startIndex + displayIdx : displayIdx;
            const row = csvData[result.rowIndex];
            const rowClass = result.status === 'error' ? 'row-error' :
                            (result.status === 'warning' ? 'row-warning' : '');
            const statusIcon = result.status === 'valid' ? '‚úÖ' :
                              (result.status === 'warning' ? '‚ö†Ô∏è' : '‚ùå');
            const statusClass = result.status;

            html += `<tr class="${rowClass}" id="row-${idx}">`;
            html += `<td class="row-status"><span class="status-icon ${statusClass}">${statusIcon}</span></td>`;
            html += `<td>${result.rowNum}</td>`;

            displayHeaders.forEach(header => {
                const value = row[header] || '';
                const cellClass = result.cellErrors[header] ? 'cell-error' :
                                 (result.cellWarnings[header] ? 'cell-warning' : '');

                // Make certain fields editable with dropdowns
                if (header === 'Active') {
                    html += `<td class="${cellClass}" style="min-width: 120px;">
                        <select onchange="updateCell(${result.rowIndex}, '${header}', this.value)" style="width: 100%; padding: 4px;">
                            <option value="" ${value === '' ? 'selected' : ''}></option>
                            <option value="TRUE" ${value === 'TRUE' ? 'selected' : ''}>TRUE</option>
                            <option value="FALSE" ${value === 'FALSE' ? 'selected' : ''}>FALSE</option>
                        </select>
                    </td>`;
                } else if (header === 'PartTaxCode') {
                    if (fishbowlData.taxCodes.length > 0) {
                        const taxOptions = fishbowlData.taxCodes
                            .map(tc => `<option value="${escapeHtml(tc.code)}" ${value === tc.code ? 'selected' : ''}>${escapeHtml(tc.name)} (${escapeHtml(tc.code)})</option>`)
                            .join('');
                        html += `<td class="${cellClass}">
                            <select onchange="updateCell(${result.rowIndex}, '${header}', this.value)" style="width: 100%; padding: 2px; font-size: 11px;">
                                <option value="" ${value === '' ? 'selected' : ''}></option>
                                ${taxOptions}
                            </select>
                        </td>`;
                    } else {
                        html += `<td class="${cellClass}">${escapeHtml(value)}</td>`;
                    }
                } else if (header === 'PartTypeID') {
                    if (fishbowlData.partTypes.length > 0) {
                        const ptOptions = fishbowlData.partTypes
                            .map(pt => `<option value="${pt.id}" ${value == pt.id ? 'selected' : ''}>${escapeHtml(pt.name)} (${pt.id})</option>`)
                            .join('');
                        html += `<td class="${cellClass}" style="min-width: 150px;">
                            <select onchange="updateCell(${result.rowIndex}, '${header}', this.value)" style="width: 100%; padding: 4px; font-size: 11px;">
                                <option value="" ${value === '' ? 'selected' : ''}></option>
                                ${ptOptions}
                            </select>
                        </td>`;
                    } else {
                        html += `<td class="${cellClass}">${escapeHtml(value)}</td>`;
                    }
                } else if (header === 'UOM') {
                    if (fishbowlData.uoms.length > 0) {
                        const uomOptions = fishbowlData.uoms
                            .map(uom => `<option value="${escapeHtml(uom)}" ${value === uom ? 'selected' : ''}>${escapeHtml(uom)}</option>`)
                            .join('');
                        html += `<td class="${cellClass}" style="min-width: 120px;">
                            <select onchange="updateCell(${result.rowIndex}, '${header}', this.value)" style="width: 100%; padding: 4px; font-size: 11px;">
                                <option value="" ${value === '' ? 'selected' : ''}></option>
                                ${uomOptions}
                            </select>
                        </td>`;
                    } else {
                        html += `<td class="${cellClass}">${escapeHtml(value)}</td>`;
                    }
                } else {
                    html += `<td class="${cellClass}">${escapeHtml(value)}</td>`;
                }
            });

            if (hasMoreColumns) {
                html += `<td style="color: var(--fb-text-secondary); font-style: italic;">+${visibleHeaders.length - 10} cols</td>`;
            }

            // Issues column
            const totalIssues = result.errors.length + result.warnings.length;
            if (totalIssues > 0) {
                html += `<td>
                    <button class="expand-btn" onclick="toggleRowDetails(${idx})">
                        ${totalIssues} issue${totalIssues > 1 ? 's' : ''} ‚ñº
                    </button>
                </td>`;
            } else {
                html += `<td style="color: var(--fb-success);">None</td>`;
            }

            html += `</tr>`;

            // Hidden details row
            if (totalIssues > 0) {
                html += `<tr class="row-details" id="details-${idx}">
                    <td colspan="${displayHeaders.length + 4}">
                        <div class="error-details">
                            ${result.errors.map(e => `
                                <div class="error-item">
                                    <span class="error-field">${e.field}:</span>
                                    <span class="error-message">${e.message}</span>
                                    ${e.suggestion ? `<span class="error-suggestion">üí° ${e.suggestion}</span>` : ''}
                                </div>
                            `).join('')}
                            ${result.warnings.map(w => `
                                <div class="error-item warning-item">
                                    <span class="error-field" style="color: var(--fb-warning);">${w.field}:</span>
                                    <span class="error-message">${w.message}</span>
                                    ${w.suggestion ? `<span class="error-suggestion">üí° ${w.suggestion}</span>` : ''}
                                </div>
                            `).join('')}
                        </div>
                    </td>
                </tr>`;
            }
        });

        // Add bottom spacer for virtual scrolling
        if (virtualScrollState.enabled && endIndex < results.length) {
            const remainingRows = results.length - endIndex;
            const spacerHeight = remainingRows * ROW_HEIGHT;
            html += `<tr><td colspan="${displayHeaders.length + 4}" style="height: ${spacerHeight}px; padding: 0;"></td></tr>`;
        }

        tbody.innerHTML = html;

        // Setup scroll listener for virtual scrolling (only once)
        if (virtualScrollState.enabled && tableContainer && !tableContainer.dataset.scrollListenerAttached) {
            tableContainer.addEventListener('scroll', handleTableScroll);
            tableContainer.dataset.scrollListenerAttached = 'true';
            console.log('Virtual scroll listener attached');
        }
    }

    // Handle table scroll for virtual scrolling
    function handleTableScroll() {
        const tableContainer = document.querySelector('.results-table-container');
        if (!tableContainer || !virtualScrollState.enabled) return;

        virtualScrollState.scrollTop = tableContainer.scrollTop;
        virtualScrollState.viewportHeight = tableContainer.clientHeight;

        // Re-render only visible rows
        const statusFilter = document.getElementById('filterStatus').value;
        const searchTerm = document.getElementById('searchInput').value.toLowerCase();

        let filtered = validationResults.filter(result => {
            // Status filter
            if (statusFilter !== 'all') {
                if (statusFilter === 'errors' && result.status !== 'error') return false;
                if (statusFilter === 'warnings' && result.status !== 'warning') return false;
                if (statusFilter === 'valid' && result.status !== 'valid') return false;
            }

            // Search filter
            if (searchTerm) {
                const row = csvData[result.rowIndex];
                const rowText = Object.values(row).join(' ').toLowerCase();
                if (!rowText.includes(searchTerm)) return false;
            }

            return true;
        });

        renderTable(filtered);
    }

    function toggleRowDetails(idx) {
        const detailsRow = document.getElementById('details-' + idx);
        if (detailsRow) {
            detailsRow.classList.toggle('expanded');
        }
    }

    // Debounced re-validation function
    const debouncedRevalidate = debounce(async function() {
        showLoading('Re-validating...');
        await validateData();
        renderResults();
        hideLoading();
    }, 500);

    function updateCell(rowIndex, field, newValue) {
        if (rowIndex >= 0 && rowIndex < csvData.length) {
            csvData[rowIndex][field] = newValue;
            // Re-validate after cell update (debounced to avoid re-validating on every keystroke)
            debouncedRevalidate();
        }
    }

    function escapeHtml(text) {
        if (!text) return '';
        return text
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;');
    }

    // ============================================
    // Filtering
    // ============================================

    function applyFilters() {
        const statusFilter = document.getElementById('filterStatus').value;
        const searchTerm = document.getElementById('searchInput').value.toLowerCase();

        let filtered = validationResults.filter(result => {
            // Status filter
            if (statusFilter !== 'all') {
                if (statusFilter === 'errors' && result.status !== 'error') return false;
                if (statusFilter === 'warnings' && result.status !== 'warning') return false;
                if (statusFilter === 'valid' && result.status !== 'valid') return false;
            }

            // Search filter
            if (searchTerm) {
                const row = csvData[result.rowIndex];
                const rowText = Object.values(row).join(' ').toLowerCase();
                if (!rowText.includes(searchTerm)) return false;
            }

            return true;
        });

        renderTable(filtered);
    }

    // ============================================
    // Export Functions
    // ============================================

    function exportValidRows() {
        const validResults = validationResults.filter(r => r.status === 'valid');
        if (validResults.length === 0) {
            alert('No valid rows to export.');
            return;
        }

        const validRows = validResults.map(r => csvData[r.rowIndex]);
        exportCSV(validRows, 'PPP_Valid_Rows.csv');
    }

    function exportAllWithFixes() {
        // Export all rows with a comment column for issues
        const exportData = csvData.map((row, idx) => {
            const result = validationResults[idx];
            const newRow = { ...row };

            // Add issues as a comment
            if (result.errors.length > 0 || result.warnings.length > 0) {
                const issues = [
                    ...result.errors.map(e => `ERROR: ${e.field} - ${e.message}`),
                    ...result.warnings.map(w => `WARNING: ${w.field} - ${w.message}`)
                ];
                newRow['_ValidationIssues'] = issues.join('; ');
            } else {
                newRow['_ValidationIssues'] = 'OK';
            }

            return newRow;
        });

        exportCSV(exportData, 'PPP_Validated.csv', [...csvHeaders, '_ValidationIssues']);
    }

    function exportCSV(data, filename, headers) {
        headers = headers || csvHeaders;

        let csv = headers.map(h => '"' + h.replace(/"/g, '""') + '"').join(',') + '\n';

        data.forEach(row => {
            const values = headers.map(h => {
                let value = row[h] || '';
                // Escape quotes and wrap in quotes
                value = '"' + String(value).replace(/"/g, '""') + '"';
                return value;
            });
            csv += values.join(',') + '\n';
        });

        // Download
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = window.URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        window.URL.revokeObjectURL(url);
    }

    function importToFishbowl() {
        // Get valid rows only
        const validResults = validationResults.filter(r => r.status === 'valid');

        if (validResults.length === 0) {
            alert('No valid rows to import. Please fix all errors and warnings first.');
            return;
        }

        const validRows = validResults.map(r => csvData[r.rowIndex]);

        if (!confirm(`Import ${validRows.length} valid rows to Fishbowl?\n\nThis will create/update parts, products, and vendor pricing in Fishbowl.`)) {
            return;
        }

        showLoading('Preparing data for import...');

        try {
            // Build rows array in the format expected by Fishbowl API
            let rows = [];

            // Header row
            rows.push(csvHeaders.map(h => '"' + h.replace(/"/g, '""') + '"').join(','));

            // Data rows
            validRows.forEach(function(row) {
                const values = csvHeaders.map(h => {
                    let value = row[h] || '';
                    value = '"' + String(value).replace(/"/g, '""') + '"';
                    return value;
                });
                rows.push(values.join(','));
            });

            // Build API request payload
            let payload = {
                "ImportRq": {
                    "Type": "ImportPartProductAndVendorPricing",
                    "Rows": {
                        "Row": rows
                    }
                }
            };

            console.log('Import Request:', payload);
            console.log('First 3 rows:', rows.slice(0, 3));

            showLoading('Importing ' + validRows.length + ' rows to Fishbowl...');

            // Call the Fishbowl API
            let response = runApiRequest('ImportRq', JSON.stringify(payload));
            console.log('Import Response (raw):', response);

            hideLoading();

            if (!response) {
                alert('Import failed: No response from API');
                return;
            }

            // Parse response
            let result = typeof response === 'string' ? JSON.parse(response) : response;
            console.log('Import Result (parsed):', result);

            // Check for success
            if (result && result.ImportRs && result.ImportRs.statusCode === 1000) {
                alert('Successfully imported ' + validRows.length + ' rows to Fishbowl!');

                // Optionally clear data after successful import
                if (confirm('Import successful! Clear the validator?')) {
                    clearData();
                }
            } else {
                let errorMsg = 'Import failed';
                let statusMessage = '';

                if (result && result.ImportRs && result.ImportRs.statusMessage) {
                    statusMessage = result.ImportRs.statusMessage;
                    errorMsg += ': ' + statusMessage;
                } else if (result && result.ErrorRs && result.ErrorRs.statusMessage) {
                    statusMessage = result.ErrorRs.statusMessage;
                    errorMsg += ': ' + statusMessage;
                } else {
                    errorMsg += ': ' + JSON.stringify(result);
                }

                // Try to extract line number from error message
                let lineNumberMatch = statusMessage.match(/Line Number:\s*(\d+)/i);
                if (lineNumberMatch && lineNumberMatch[1]) {
                    let csvLineNum = parseInt(lineNumberMatch[1]);
                    let arrayIndex = csvLineNum - 1;

                    if (arrayIndex >= 0 && arrayIndex < rows.length) {
                        errorMsg += '\n\nError on CSV line ' + csvLineNum + ':\n' + rows[arrayIndex];
                        console.error('Error on CSV line ' + csvLineNum + ' (array index ' + arrayIndex + '): ' + rows[arrayIndex]);
                    }
                }

                alert(errorMsg);
            }

        } catch (error) {
            hideLoading();
            console.error('Error during import:', error);
            alert('Import error: ' + error.message);
        }
    }

    // ============================================
    // Utility Functions
    // ============================================

    async function revalidateData() {
        if (csvData.length === 0) {
            alert('No data to validate. Please upload a file first.');
            return;
        }

        showLoading('Re-loading Fishbowl data...');
        loadFishbowlReferenceData();

        showLoading('Re-validating...');
        await validateData(); // Now async!

        showLoading('Rendering results...');
        renderResults();

        hideLoading();
    }

    function clearData() {
        csvData = [];
        csvHeaders = [];
        validationResults = [];
        consolidatedIssues = {};

        document.getElementById('fileName').textContent = '';
        document.getElementById('fileInput').value = '';
        document.getElementById('summaryStats').classList.add('hidden');
        document.getElementById('filterControls').classList.add('hidden');
        document.getElementById('resultsSection').classList.add('hidden');
        document.getElementById('actionButtons').classList.add('hidden');
        document.getElementById('consolidatedIssues').classList.add('hidden');
        document.getElementById('tableBody').innerHTML = '';
    }

    function showLoading(text) {
        document.getElementById('loadingText').textContent = text || 'Processing...';
        document.getElementById('loadingOverlay').classList.remove('hidden');
    }

    function hideLoading() {
        document.getElementById('loadingOverlay').classList.add('hidden');
    }

    // ============================================
    // Column Reference
    // ============================================

    function populateColumnReference() {
        const grid = document.getElementById('columnGrid');
        let html = '';

        Object.entries(PPP_COLUMNS).forEach(([name, def]) => {
            html += `
                <div class="column-item">
                    <span class="col-name">${name}</span>
                    <span class="col-type">${def.type}</span>
                    ${def.required ? '<span class="col-required">*Required</span>' : ''}
                    <div class="col-desc">${def.desc}</div>
                    ${def.validValues ? `<div class="col-desc" style="color: var(--fb-info);">Values: ${def.validValues.join(', ')}</div>` : ''}
                </div>
            `;
        });

        // Add note about custom fields
        html += `
            <div class="column-item" style="background-color: var(--fb-warning-bg);">
                <span class="col-name">CF-*</span>
                <span class="col-type">Custom Field</span>
                <div class="col-desc">Any column starting with "CF-" is treated as a custom field. The field name after "CF-" must match an existing custom field in Fishbowl.</div>
            </div>
        `;

        grid.innerHTML = html;
    }

    function toggleColumnReference() {
        const grid = document.getElementById('columnGrid');
        const toggle = document.getElementById('refToggle');

        if (grid.classList.contains('hidden')) {
            grid.classList.remove('hidden');
            toggle.textContent = '‚ñº';
        } else {
            grid.classList.add('hidden');
            toggle.textContent = '‚ñ∂';
        }
    }
    </script>
</body>
</html>
