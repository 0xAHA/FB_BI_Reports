<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Part, Product & Vendor Pricing Validator</title>
    <style>
        {% Style fishbowl-theme %}
    </style>
    <style>
        /* Minimal page-specific overrides */
        h1 {
            text-align: center;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Part, Product & Vendor Pricing Validator</h1>
        <p class="subtitle">Validate your PPP import CSV before importing to Fishbowl</p>

        <!-- Upload Section -->
        <div class="upload-section" id="uploadSection">
            <h3>üìÑ Upload PPP Import CSV</h3>
            <p>Drag and drop file here, or <button class="btn-primary" onclick="document.getElementById('fileInput').click()">Choose File</button></p>
            <input type="file" id="fileInput" accept=".csv" onchange="handleFileSelect(event)" />
            <p id="fileName"></p>
        </div>

        <!-- Summary Stats (hidden until file loaded) -->
        <div class="summary-stats hidden" id="summaryStats">
            <div class="stat-card total">
                <span class="stat-number" id="statTotal">0</span>
                <span class="stat-label">Total</span>
            </div>
            <div class="stat-card valid">
                <span class="stat-number" id="statValid">0</span>
                <span class="stat-label">Valid</span>
            </div>
            <div class="stat-card warning">
                <span class="stat-number" id="statWarning">0</span>
                <span class="stat-label">Warnings</span>
            </div>
            <div class="stat-card error">
                <span class="stat-number" id="statError">0</span>
                <span class="stat-label">Errors</span>
            </div>
        </div>

        <!-- Missing Dependencies Panel -->
        <div class="dependencies-panel hidden" id="dependenciesPanel">
            <h3>Missing Dependencies in Fishbowl</h3>
            <p>The following items must exist in Fishbowl before this import can succeed:</p>

            <div class="dependency-section hidden" id="missingUomsSection">
                <h4>Missing UOMs (Units of Measure)</h4>
                <div class="dependency-list" id="missingUomsList"></div>
            </div>

            <div class="dependency-section hidden" id="missingVendorsSection">
                <h4>Missing Vendors</h4>
                <div class="dependency-list" id="missingVendorsList"></div>
            </div>

            <div class="dependency-section hidden" id="missingCustomFieldsSection">
                <h4>Missing Custom Fields</h4>
                <div class="dependency-list" id="missingCustomFieldsList"></div>
            </div>

            <div class="dependency-section hidden" id="missingUomConversionsSection">
                <h4>Missing UOM Conversions</h4>
                <div class="dependency-list" id="missingUomConversionsList"></div>
            </div>
        </div>

        <!-- Filter Controls -->
        <div class="filter-controls hidden" id="filterControls">
            <label>Show:</label>
            <select id="filterStatus" onchange="applyFilters()">
                <option value="all">All Rows</option>
                <option value="errors">Errors Only</option>
                <option value="warnings">Warnings Only</option>
                <option value="valid">Valid Only</option>
            </select>

            <div class="search-box">
                <input type="text" id="searchInput" placeholder="Search by Part Number, Vendor, etc..." oninput="applyFilters()" />
            </div>
        </div>

        <!-- Results Table -->
        <div class="results-section hidden" id="resultsSection">
            <div class="results-table-container">
                <table class="results-table" id="resultsTable">
                    <thead id="tableHeader">
                        <!-- Dynamic headers -->
                    </thead>
                    <tbody id="tableBody">
                        <!-- Dynamic rows -->
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Action Buttons -->
        <div class="action-buttons hidden" id="actionButtons">
            <button class="action-btn btn-revalidate" onclick="revalidateData()">
                <span>üîÑ</span> Re-validate
            </button>
            <button class="action-btn btn-export" onclick="exportValidRows()" id="exportValidBtn">
                <span>‚úÖ</span> Export Valid Rows
            </button>
            <button class="action-btn btn-export" onclick="exportAllWithFixes()" id="exportAllBtn" style="background-color: var(--fb-warning);">
                <span>üìù</span> Export All (with suggestions)
            </button>
            <button class="action-btn btn-clear" onclick="clearData()">
                <span>üóëÔ∏è</span> Clear
            </button>
        </div>

        <!-- Column Reference -->
        <div class="column-reference">
            <h3 onclick="toggleColumnReference()">
                <span id="refToggle">‚ñ∂</span> PPP Import Column Reference
            </h3>
            <div class="column-grid hidden" id="columnGrid">
                <!-- Will be populated dynamically -->
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay hidden" id="loadingOverlay">
        <div class="loading-spinner"></div>
        <div class="loading-text" id="loadingText">Processing file...</div>
    </div>

    <script>
    // ============================================
    // Configuration & Column Definitions
    // ============================================

    const PPP_COLUMNS = {
        // Part Information - Core
        'PartNumber': { type: 'Text', required: true, desc: 'Unique part identifier (required to find/create part)' },
        'PartDescription': { type: 'Text', required: false, desc: 'Part description' },
        'PartDetails': { type: 'Text', required: false, desc: 'Additional part details' },
        'UOM': { type: 'Text', required: false, desc: 'Default Unit of Measure for the part', validateUOM: true },
        'UPC': { type: 'Text', required: false, desc: 'Universal Product Code' },
        'PartType': { type: 'Text', required: false, desc: 'Part type name (Inventory, Non-Inventory, Service, etc.)', validValues: ['Inventory', 'Non-Inventory', 'Service', 'Labor', 'Overhead', 'Capital Equipment', 'Shipping', 'Internal Use'] },
        'PartTypeID': { type: 'Integer', required: false, desc: 'Part type ID (10=Inventory, 20=Service, etc.)' },
        'ABCCode': { type: 'Text', required: false, desc: 'ABC classification code', validValues: ['A', 'B', 'C', 'N'] },
        'Active': { type: 'Boolean', required: false, desc: 'Whether part is active' },
        'Taxable': { type: 'Boolean', required: false, desc: 'Whether part is taxable' },
        'ComSchPercent': { type: 'Percentage', required: false, desc: 'Commission percentage' },

        // Part - Physical Properties
        'Weight': { type: 'Decimal', required: false, desc: 'Part weight' },
        'WeightUOM': { type: 'Text', required: false, desc: 'Weight unit of measure', validateUOM: true },
        'Width': { type: 'Decimal', required: false, desc: 'Part width' },
        'Height': { type: 'Decimal', required: false, desc: 'Part height' },
        'Len': { type: 'Decimal', required: false, desc: 'Part length' },
        'SizeUOM': { type: 'Text', required: false, desc: 'Size unit of measure', validateUOM: true },

        // Part - Tracking Flags
        'Tracks-Lot Number': { type: 'Boolean', required: false, desc: 'Whether part tracks lot numbers' },
        'Tracks-Revision Level': { type: 'Boolean', required: false, desc: 'Whether part tracks revision levels' },
        'Tracks-Expiration Date': { type: 'Boolean', required: false, desc: 'Whether part tracks expiration dates' },
        'Tracks-Serial Number': { type: 'Boolean', required: false, desc: 'Whether part tracks serial numbers' },
        'Tracks-Batch Number': { type: 'Boolean', required: false, desc: 'Whether part tracks batch numbers' },
        'Tracks-BoxID-Qty': { type: 'Boolean', required: false, desc: 'Whether part tracks BoxID quantity' },
        'Tracks-BoxID-count': { type: 'Boolean', required: false, desc: 'Whether part tracks BoxID count' },
        'Tracks-BoxID-money': { type: 'Boolean', required: false, desc: 'Whether part tracks BoxID money' },
        'Tracks-Consignment': { type: 'Boolean', required: false, desc: 'Whether part tracks consignment' },
        'PrimaryTracking': { type: 'Text', required: false, desc: 'Primary tracking method' },

        // Part - Cost & Other
        'StandardCost': { type: 'Currency', required: false, desc: 'Standard cost' },
        'StdCost': { type: 'Currency', required: false, desc: 'Standard cost (alternate column name)' },
        'ConsumptionRate': { type: 'Decimal', required: false, desc: 'Consumption rate' },
        'AlertNote': { type: 'Text', required: false, desc: 'Alert note for part' },
        'PictureUrl': { type: 'Text', required: false, desc: 'URL to part picture' },
        'Revision': { type: 'Text', required: false, desc: 'Part revision' },
        'POItemType': { type: 'Text', required: false, desc: 'Purchase Order item type' },
        'DefaultOutsourcedReturnItem': { type: 'Text', required: false, desc: 'Default outsourced return item' },
        'ControlledFlag': { type: 'Boolean', required: false, desc: 'Whether part is controlled' },
        'UsedFlag': { type: 'Boolean', required: false, desc: 'Whether part has been used' },

        // Accounting
        'AssetAccount': { type: 'Text', required: false, desc: 'Asset account name' },
        'COGSAccount': { type: 'Text', required: false, desc: 'Cost of Goods Sold account' },
        'AdjustmentAccount': { type: 'Text', required: false, desc: 'Adjustment account' },
        'ScrapAccount': { type: 'Text', required: false, desc: 'Scrap account' },
        'VarianceAccount': { type: 'Text', required: false, desc: 'Variance account' },
        'IncomeAccount': { type: 'Text', required: false, desc: 'Income account name' },

        // Product Information
        'ProductNumber': { type: 'Text', required: false, desc: 'Product number (for sellable items)' },
        'ProductDescription': { type: 'Text', required: false, desc: 'Product description' },
        'ProductDetails': { type: 'Text', required: false, desc: 'Additional product details' },
        'ProductUOM': { type: 'Text', required: false, desc: 'Product unit of measure', validateUOM: true },
        'ProductPrice': { type: 'Currency', required: false, desc: 'Product price' },
        'Price': { type: 'Currency', required: false, desc: 'Product price (alternate column name)' },
        'ProductTaxable': { type: 'Boolean', required: false, desc: 'Whether product is taxable' },
        'ProductActive': { type: 'Boolean', required: false, desc: 'Whether product is active' },
        'ProductSOItemType': { type: 'Text', required: false, desc: 'Sales Order item type name', validValues: ['Sale', 'Misc. Sale', 'Drop Ship', 'Credit Return', 'Misc. Credit', 'Discount Percentage', 'Discount Amount', 'Subtotal', 'Assoc. Price', 'Shipping', 'Tax', 'Kit', 'Note'] },
        'ProductSOItemTypeID': { type: 'Integer', required: false, desc: 'Sales Order item type ID' },
        'ProductWeight': { type: 'Decimal', required: false, desc: 'Product weight' },
        'ProductWeightUOM': { type: 'Text', required: false, desc: 'Product weight UOM', validateUOM: true },
        'ProductWidth': { type: 'Decimal', required: false, desc: 'Product width' },
        'ProductHeight': { type: 'Decimal', required: false, desc: 'Product height' },
        'ProductLen': { type: 'Decimal', required: false, desc: 'Product length' },
        'ProductSizeUOM': { type: 'Text', required: false, desc: 'Product size UOM', validateUOM: true },
        'ProductUPC': { type: 'Text', required: false, desc: 'Product UPC code' },
        'ProductSKU': { type: 'Text', required: false, desc: 'Product SKU' },
        'ProductDisplayType': { type: 'Text', required: false, desc: 'Display type' },
        'ProductURL': { type: 'Text', required: false, desc: 'Product URL' },
        'ProductPictureURL': { type: 'Text', required: false, desc: 'Product picture URL' },
        'ProductDefaultCarrier': { type: 'Text', required: false, desc: 'Default carrier' },
        'ProductDefaultCarrierService': { type: 'Text', required: false, desc: 'Default carrier service' },
        'ProductAlertNote': { type: 'Text', required: false, desc: 'Product alert note' },
        'ProductKitFlag': { type: 'Boolean', required: false, desc: 'Whether product is a kit' },
        'ProductKitGroupedFlag': { type: 'Boolean', required: false, desc: 'Whether kit is grouped' },
        'ProductShowSOComboFlag': { type: 'Boolean', required: false, desc: 'Show SO combo flag' },

        // Vendor Pricing Information - Multiple column name variants
        'VendorName': { type: 'Text', required: false, desc: 'Vendor name (must exist in Fishbowl)', validateVendor: true },
        'Vendor': { type: 'Text', required: false, desc: 'Vendor name (alternate column name)', validateVendor: true },
        'VendorPartNumber': { type: 'Text', required: false, desc: 'Vendor part number' },
        'VendorCost': { type: 'Currency', required: false, desc: 'Cost from this vendor' },
        'Cost': { type: 'Currency', required: false, desc: 'Vendor cost (alternate column name)' },
        'VendorDefaultFlag': { type: 'Boolean', required: false, desc: 'Whether this is default vendor' },
        'DefaultVendor': { type: 'Boolean', required: false, desc: 'Whether this is default vendor (alternate column name)' },
        'VendorUOM': { type: 'Text', required: false, desc: 'Vendor UOM', validateUOM: true },
        'VendorMinQty': { type: 'Decimal', required: false, desc: 'Minimum order quantity' },
        'VendorQtyMultiple': { type: 'Decimal', required: false, desc: 'Order quantity multiple' },
        'VendorLeadTime': { type: 'Integer', required: false, desc: 'Lead time in days' },
        'LastDate': { type: 'Date', required: false, desc: 'Last date for pricing' },
        'FirstDate': { type: 'Date', required: false, desc: 'First date for pricing' }
    };

    // Global state
    let csvData = [];
    let csvHeaders = [];
    let validationResults = [];
    let fishbowlData = {
        uoms: [],
        vendors: [],
        customFields: [],
        uomConversions: []
    };

    // ============================================
    // Initialization
    // ============================================

    window.onload = function() {
        loadFishbowlReferenceData();
        populateColumnReference();
        setupDragAndDrop();
    };

    function setupDragAndDrop() {
        const uploadSection = document.getElementById('uploadSection');

        uploadSection.addEventListener('dragover', function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.add('dragover');
        });

        uploadSection.addEventListener('dragleave', function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.remove('dragover');
        });

        uploadSection.addEventListener('drop', function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.remove('dragover');

            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].name.endsWith('.csv')) {
                processFile(files[0]);
            } else {
                alert('Please drop a CSV file.');
            }
        });
    }

    // ============================================
    // Fishbowl Data Loading
    // ============================================

    function loadFishbowlReferenceData() {
        try {
            // Load UOMs
            let uomQuery = `SELECT code FROM uom WHERE activeflag = 1 ORDER BY code`;
            let uomResult = runQuery(uomQuery);
            let uoms = uomResult ? JSON.parse(uomResult) : [];
            if (uoms && !Array.isArray(uoms)) uoms = [uoms];
            fishbowlData.uoms = uoms.map(u => u.code.toUpperCase());

            // Load Vendors
            let vendorQuery = `SELECT name FROM vendor WHERE activeflag = 1 ORDER BY name`;
            let vendorResult = runQuery(vendorQuery);
            let vendors = vendorResult ? JSON.parse(vendorResult) : [];
            if (vendors && !Array.isArray(vendors)) vendors = [vendors];
            fishbowlData.vendors = vendors.map(v => v.name);

            // Load Custom Fields (for Part)
            let cfQuery = `SELECT name FROM customfield WHERE tableid IN (SELECT id FROM systables WHERE name = 'Part') AND activeflag = 1`;
            let cfResult = runQuery(cfQuery);
            let customFields = cfResult ? JSON.parse(cfResult) : [];
            if (customFields && !Array.isArray(customFields)) customFields = [customFields];
            fishbowlData.customFields = customFields.map(cf => cf.name);

            // Load UOM Conversions
            let convQuery = `SELECT
                u1.code as fromUom,
                u2.code as toUom
            FROM uomconversion uc
            INNER JOIN uom u1 ON uc.touomid = u1.id
            INNER JOIN uom u2 ON uc.fromuomid = u2.id`;
            let convResult = runQuery(convQuery);
            let conversions = convResult ? JSON.parse(convResult) : [];
            if (conversions && !Array.isArray(conversions)) conversions = [conversions];
            fishbowlData.uomConversions = conversions.map(c => c.fromUom.toUpperCase() + '->' + c.toUom.toUpperCase());

            console.log('Loaded Fishbowl reference data:', {
                uoms: fishbowlData.uoms.length,
                vendors: fishbowlData.vendors.length,
                customFields: fishbowlData.customFields.length,
                uomConversions: fishbowlData.uomConversions.length
            });

        } catch (e) {
            console.error('Error loading Fishbowl reference data:', e);
            // Continue with empty data - validation will still work for format checks
        }
    }

    // ============================================
    // File Processing
    // ============================================

    function handleFileSelect(event) {
        const file = event.target.files[0];
        if (file) {
            processFile(file);
        }
    }

    function processFile(file) {
        showLoading('Reading file...');
        document.getElementById('fileName').textContent = file.name;

        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                showLoading('Parsing CSV...');
                parseCSV(e.target.result);

                showLoading('Validating data...');
                validateData();

                showLoading('Rendering results...');
                renderResults();

                hideLoading();

            } catch (err) {
                hideLoading();
                alert('Error processing file: ' + err.message);
                console.error(err);
            }
        };
        reader.onerror = function() {
            hideLoading();
            alert('Error reading file');
        };
        reader.readAsText(file);
    }

    function parseCSV(text) {
        csvData = [];
        csvHeaders = [];

        // Handle different line endings
        const lines = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');

        if (lines.length === 0) {
            throw new Error('Empty file');
        }

        // Parse header row
        csvHeaders = parseCSVLine(lines[0]);

        // Parse data rows
        for (let i = 1; i < lines.length; i++) {
            const line = lines[i].trim();
            if (line === '') continue;

            const values = parseCSVLine(line);
            const row = { _rowNum: i + 1 };

            csvHeaders.forEach((header, index) => {
                row[header] = values[index] !== undefined ? values[index] : '';
            });

            csvData.push(row);
        }

        console.log('Parsed ' + csvData.length + ' rows with ' + csvHeaders.length + ' columns');
    }

    function parseCSVLine(line) {
        const result = [];
        let current = '';
        let inQuotes = false;

        for (let i = 0; i < line.length; i++) {
            const char = line[i];
            const nextChar = line[i + 1];

            if (inQuotes) {
                if (char === '"' && nextChar === '"') {
                    // Escaped quote
                    current += '"';
                    i++;
                } else if (char === '"') {
                    // End of quoted field
                    inQuotes = false;
                } else {
                    current += char;
                }
            } else {
                if (char === '"') {
                    inQuotes = true;
                } else if (char === ',') {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
        }

        result.push(current.trim());
        return result;
    }

    // ============================================
    // Validation
    // ============================================

    function validateData() {
        validationResults = [];

        const missingDeps = {
            uoms: new Set(),
            vendors: new Set(),
            customFields: new Set(),
            uomConversions: new Set()
        };

        csvData.forEach((row, index) => {
            const rowResult = {
                rowNum: row._rowNum,
                rowIndex: index,
                status: 'valid',
                errors: [],
                warnings: [],
                cellErrors: {},
                cellWarnings: {}
            };

            // Check required fields
            if (!row['PartNumber'] || row['PartNumber'].trim() === '') {
                rowResult.errors.push({
                    field: 'PartNumber',
                    message: 'Part Number is required',
                    suggestion: 'Provide a unique part number'
                });
                rowResult.cellErrors['PartNumber'] = true;
            }

            // Validate each column
            csvHeaders.forEach(header => {
                const value = row[header];
                if (!value || value.trim() === '') return; // Skip empty values

                // Check if it's a custom field
                if (header.startsWith('CF-')) {
                    const cfName = header.substring(3);
                    if (fishbowlData.customFields.length > 0 && !fishbowlData.customFields.includes(cfName)) {
                        rowResult.errors.push({
                            field: header,
                            message: `Custom field "${cfName}" does not exist in Fishbowl`,
                            suggestion: 'Create this custom field in Fishbowl first, or remove this column'
                        });
                        rowResult.cellErrors[header] = true;
                        missingDeps.customFields.add(cfName);
                    }
                    return;
                }

                const colDef = PPP_COLUMNS[header];
                if (!colDef) {
                    // Unknown column - just a warning, Fishbowl will ignore it
                    rowResult.warnings.push({
                        field: header,
                        message: `Unknown column "${header}" will be ignored by Fishbowl`,
                        suggestion: 'Remove this column or check spelling'
                    });
                    rowResult.cellWarnings[header] = true;
                    return;
                }

                // Type validation
                const typeError = validateType(value, colDef.type, header);
                if (typeError) {
                    rowResult.errors.push(typeError);
                    rowResult.cellErrors[header] = true;
                }

                // Valid values check
                if (colDef.validValues && !colDef.validValues.includes(value)) {
                    rowResult.errors.push({
                        field: header,
                        message: `Invalid value "${value}"`,
                        suggestion: `Valid values: ${colDef.validValues.join(', ')}`
                    });
                    rowResult.cellErrors[header] = true;
                }

                // UOM validation
                if (colDef.validateUOM && fishbowlData.uoms.length > 0) {
                    if (!fishbowlData.uoms.includes(value.toUpperCase())) {
                        rowResult.errors.push({
                            field: header,
                            message: `UOM "${value}" does not exist in Fishbowl`,
                            suggestion: 'Create this UOM first, or use an existing one'
                        });
                        rowResult.cellErrors[header] = true;
                        missingDeps.uoms.add(value.toUpperCase());
                    }
                }

                // Vendor validation
                if (colDef.validateVendor && fishbowlData.vendors.length > 0) {
                    if (!fishbowlData.vendors.some(v => v.toLowerCase() === value.toLowerCase())) {
                        rowResult.errors.push({
                            field: header,
                            message: `Vendor "${value}" does not exist in Fishbowl`,
                            suggestion: 'Create this vendor first, or check spelling'
                        });
                        rowResult.cellErrors[header] = true;
                        missingDeps.vendors.add(value);
                    }
                }
            });

            // Check UOM conversions if multiple UOMs are specified
            const partUom = row['UOM'] ? row['UOM'].toUpperCase() : null;
            const productUom = row['ProductUOM'] ? row['ProductUOM'].toUpperCase() : null;
            const vendorUom = row['VendorUOM'] ? row['VendorUOM'].toUpperCase() : null;

            if (partUom && productUom && partUom !== productUom) {
                const convKey = partUom + '->' + productUom;
                const revConvKey = productUom + '->' + partUom;
                if (fishbowlData.uomConversions.length > 0 &&
                    !fishbowlData.uomConversions.includes(convKey) &&
                    !fishbowlData.uomConversions.includes(revConvKey)) {
                    rowResult.warnings.push({
                        field: 'ProductUOM',
                        message: `UOM conversion from ${partUom} to ${productUom} may not exist`,
                        suggestion: 'Ensure UOM conversion exists in Fishbowl'
                    });
                    rowResult.cellWarnings['ProductUOM'] = true;
                    missingDeps.uomConversions.add(partUom + ' <-> ' + productUom);
                }
            }

            if (partUom && vendorUom && partUom !== vendorUom) {
                const convKey = partUom + '->' + vendorUom;
                const revConvKey = vendorUom + '->' + partUom;
                if (fishbowlData.uomConversions.length > 0 &&
                    !fishbowlData.uomConversions.includes(convKey) &&
                    !fishbowlData.uomConversions.includes(revConvKey)) {
                    rowResult.warnings.push({
                        field: 'VendorUOM',
                        message: `UOM conversion from ${partUom} to ${vendorUom} may not exist`,
                        suggestion: 'Ensure UOM conversion exists in Fishbowl'
                    });
                    rowResult.cellWarnings['VendorUOM'] = true;
                    missingDeps.uomConversions.add(partUom + ' <-> ' + vendorUom);
                }
            }

            // Set overall status
            if (rowResult.errors.length > 0) {
                rowResult.status = 'error';
            } else if (rowResult.warnings.length > 0) {
                rowResult.status = 'warning';
            }

            validationResults.push(rowResult);
        });

        // Update missing dependencies panel
        updateDependenciesPanel(missingDeps);
    }

    function validateType(value, type, field) {
        switch (type) {
            case 'Integer':
                if (!/^-?\d+$/.test(value)) {
                    return {
                        field: field,
                        message: `"${value}" is not a valid integer`,
                        suggestion: 'Use whole numbers only (e.g., 1, 10, 100)'
                    };
                }
                break;

            case 'Decimal':
            case 'Currency':
            case 'Percentage':
                // Remove currency symbols and commas for validation
                const cleanValue = value.replace(/[$,]/g, '');
                if (!/^-?\d*\.?\d+$/.test(cleanValue)) {
                    return {
                        field: field,
                        message: `"${value}" is not a valid number`,
                        suggestion: 'Use numeric format (e.g., 10.50)'
                    };
                }
                break;

            case 'Boolean':
                const boolValues = ['true', 'false', '1', '0', 'yes', 'no'];
                if (!boolValues.includes(value.toLowerCase())) {
                    return {
                        field: field,
                        message: `"${value}" is not a valid boolean`,
                        suggestion: 'Use true/false, 1/0, or yes/no'
                    };
                }
                break;

            case 'Date':
                // Basic date validation - could be enhanced
                const dateRegex = /^\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}$|^\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2}$/;
                if (!dateRegex.test(value)) {
                    return {
                        field: field,
                        message: `"${value}" is not a valid date format`,
                        suggestion: 'Use MM/DD/YYYY or YYYY-MM-DD format'
                    };
                }
                break;
        }
        return null;
    }

    function updateDependenciesPanel(missingDeps) {
        const panel = document.getElementById('dependenciesPanel');
        let hasAnyMissing = false;

        // UOMs
        const uomSection = document.getElementById('missingUomsSection');
        const uomList = document.getElementById('missingUomsList');
        if (missingDeps.uoms.size > 0) {
            uomList.innerHTML = Array.from(missingDeps.uoms).map(u =>
                `<span class="dependency-item">${u}</span>`
            ).join('');
            uomSection.classList.remove('hidden');
            hasAnyMissing = true;
        } else {
            uomSection.classList.add('hidden');
        }

        // Vendors
        const vendorSection = document.getElementById('missingVendorsSection');
        const vendorList = document.getElementById('missingVendorsList');
        if (missingDeps.vendors.size > 0) {
            vendorList.innerHTML = Array.from(missingDeps.vendors).map(v =>
                `<span class="dependency-item">${v}</span>`
            ).join('');
            vendorSection.classList.remove('hidden');
            hasAnyMissing = true;
        } else {
            vendorSection.classList.add('hidden');
        }

        // Custom Fields
        const cfSection = document.getElementById('missingCustomFieldsSection');
        const cfList = document.getElementById('missingCustomFieldsList');
        if (missingDeps.customFields.size > 0) {
            cfList.innerHTML = Array.from(missingDeps.customFields).map(cf =>
                `<span class="dependency-item">CF-${cf}</span>`
            ).join('');
            cfSection.classList.remove('hidden');
            hasAnyMissing = true;
        } else {
            cfSection.classList.add('hidden');
        }

        // UOM Conversions
        const convSection = document.getElementById('missingUomConversionsSection');
        const convList = document.getElementById('missingUomConversionsList');
        if (missingDeps.uomConversions.size > 0) {
            convList.innerHTML = Array.from(missingDeps.uomConversions).map(c =>
                `<span class="dependency-item">${c}</span>`
            ).join('');
            convSection.classList.remove('hidden');
            hasAnyMissing = true;
        } else {
            convSection.classList.add('hidden');
        }

        // Show/hide main panel
        if (hasAnyMissing) {
            panel.classList.remove('hidden');
        } else {
            panel.classList.add('hidden');
        }
    }

    // ============================================
    // Rendering
    // ============================================

    function renderResults() {
        // Show sections
        document.getElementById('summaryStats').classList.remove('hidden');
        document.getElementById('filterControls').classList.remove('hidden');
        document.getElementById('resultsSection').classList.remove('hidden');
        document.getElementById('actionButtons').classList.remove('hidden');

        // Update stats
        const totalRows = validationResults.length;
        const validRows = validationResults.filter(r => r.status === 'valid').length;
        const warningRows = validationResults.filter(r => r.status === 'warning').length;
        const errorRows = validationResults.filter(r => r.status === 'error').length;

        document.getElementById('statTotal').textContent = totalRows;
        document.getElementById('statValid').textContent = validRows;
        document.getElementById('statWarning').textContent = warningRows;
        document.getElementById('statError').textContent = errorRows;

        // Enable/disable export buttons
        document.getElementById('exportValidBtn').disabled = validRows === 0;

        // Render table
        renderTable(validationResults);
    }

    function renderTable(results) {
        const thead = document.getElementById('tableHeader');
        const tbody = document.getElementById('tableBody');

        // Build header - show status, row number, then visible columns (limit to avoid overflow)
        let visibleHeaders = ['PartNumber', 'PartDescription'];

        // Add other headers that have data
        csvHeaders.forEach(header => {
            if (!visibleHeaders.includes(header)) {
                const hasData = csvData.some(row => row[header] && row[header].trim() !== '');
                if (hasData) {
                    visibleHeaders.push(header);
                }
            }
        });

        // Limit columns for display (show first 10)
        const displayHeaders = visibleHeaders.slice(0, 10);
        const hasMoreColumns = visibleHeaders.length > 10;

        thead.innerHTML = `
            <tr>
                <th class="row-status">Status</th>
                <th>Row</th>
                ${displayHeaders.map(h => `<th>${h}</th>`).join('')}
                ${hasMoreColumns ? '<th>...</th>' : ''}
                <th>Issues</th>
            </tr>
        `;

        // Build body
        let html = '';
        results.forEach((result, idx) => {
            const row = csvData[result.rowIndex];
            const rowClass = result.status === 'error' ? 'row-error' :
                            (result.status === 'warning' ? 'row-warning' : '');
            const statusIcon = result.status === 'valid' ? '‚úÖ' :
                              (result.status === 'warning' ? '‚ö†Ô∏è' : '‚ùå');
            const statusClass = result.status;

            html += `<tr class="${rowClass}" id="row-${idx}">`;
            html += `<td class="row-status"><span class="status-icon ${statusClass}">${statusIcon}</span></td>`;
            html += `<td>${result.rowNum}</td>`;

            displayHeaders.forEach(header => {
                const value = row[header] || '';
                const cellClass = result.cellErrors[header] ? 'cell-error' :
                                 (result.cellWarnings[header] ? 'cell-warning' : '');
                html += `<td class="${cellClass}">${escapeHtml(value)}</td>`;
            });

            if (hasMoreColumns) {
                html += `<td style="color: var(--fb-text-secondary); font-style: italic;">+${visibleHeaders.length - 10} cols</td>`;
            }

            // Issues column
            const totalIssues = result.errors.length + result.warnings.length;
            if (totalIssues > 0) {
                html += `<td>
                    <button class="expand-btn" onclick="toggleRowDetails(${idx})">
                        ${totalIssues} issue${totalIssues > 1 ? 's' : ''} ‚ñº
                    </button>
                </td>`;
            } else {
                html += `<td style="color: var(--fb-success);">None</td>`;
            }

            html += `</tr>`;

            // Hidden details row
            if (totalIssues > 0) {
                html += `<tr class="row-details" id="details-${idx}">
                    <td colspan="${displayHeaders.length + 4}">
                        <div class="error-details">
                            ${result.errors.map(e => `
                                <div class="error-item">
                                    <span class="error-field">${e.field}:</span>
                                    <span class="error-message">${e.message}</span>
                                    ${e.suggestion ? `<span class="error-suggestion">üí° ${e.suggestion}</span>` : ''}
                                </div>
                            `).join('')}
                            ${result.warnings.map(w => `
                                <div class="error-item warning-item">
                                    <span class="error-field" style="color: var(--fb-warning);">${w.field}:</span>
                                    <span class="error-message">${w.message}</span>
                                    ${w.suggestion ? `<span class="error-suggestion">üí° ${w.suggestion}</span>` : ''}
                                </div>
                            `).join('')}
                        </div>
                    </td>
                </tr>`;
            }
        });

        tbody.innerHTML = html;
    }

    function toggleRowDetails(idx) {
        const detailsRow = document.getElementById('details-' + idx);
        if (detailsRow) {
            detailsRow.classList.toggle('expanded');
        }
    }

    function escapeHtml(text) {
        if (!text) return '';
        return text
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;');
    }

    // ============================================
    // Filtering
    // ============================================

    function applyFilters() {
        const statusFilter = document.getElementById('filterStatus').value;
        const searchTerm = document.getElementById('searchInput').value.toLowerCase();

        let filtered = validationResults.filter(result => {
            // Status filter
            if (statusFilter !== 'all') {
                if (statusFilter === 'errors' && result.status !== 'error') return false;
                if (statusFilter === 'warnings' && result.status !== 'warning') return false;
                if (statusFilter === 'valid' && result.status !== 'valid') return false;
            }

            // Search filter
            if (searchTerm) {
                const row = csvData[result.rowIndex];
                const rowText = Object.values(row).join(' ').toLowerCase();
                if (!rowText.includes(searchTerm)) return false;
            }

            return true;
        });

        renderTable(filtered);
    }

    // ============================================
    // Export Functions
    // ============================================

    function exportValidRows() {
        const validResults = validationResults.filter(r => r.status === 'valid');
        if (validResults.length === 0) {
            alert('No valid rows to export.');
            return;
        }

        const validRows = validResults.map(r => csvData[r.rowIndex]);
        exportCSV(validRows, 'PPP_Valid_Rows.csv');
    }

    function exportAllWithFixes() {
        // Export all rows with a comment column for issues
        const exportData = csvData.map((row, idx) => {
            const result = validationResults[idx];
            const newRow = { ...row };

            // Add issues as a comment
            if (result.errors.length > 0 || result.warnings.length > 0) {
                const issues = [
                    ...result.errors.map(e => `ERROR: ${e.field} - ${e.message}`),
                    ...result.warnings.map(w => `WARNING: ${w.field} - ${w.message}`)
                ];
                newRow['_ValidationIssues'] = issues.join('; ');
            } else {
                newRow['_ValidationIssues'] = 'OK';
            }

            return newRow;
        });

        exportCSV(exportData, 'PPP_Validated.csv', [...csvHeaders, '_ValidationIssues']);
    }

    function exportCSV(data, filename, headers) {
        headers = headers || csvHeaders;

        let csv = headers.map(h => '"' + h.replace(/"/g, '""') + '"').join(',') + '\n';

        data.forEach(row => {
            const values = headers.map(h => {
                let value = row[h] || '';
                // Escape quotes and wrap in quotes
                value = '"' + String(value).replace(/"/g, '""') + '"';
                return value;
            });
            csv += values.join(',') + '\n';
        });

        // Download
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = window.URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        window.URL.revokeObjectURL(url);
    }

    // ============================================
    // Utility Functions
    // ============================================

    function revalidateData() {
        if (csvData.length === 0) {
            alert('No data to validate. Please upload a file first.');
            return;
        }

        showLoading('Re-loading Fishbowl data...');
        loadFishbowlReferenceData();

        showLoading('Re-validating...');
        validateData();

        showLoading('Rendering results...');
        renderResults();

        hideLoading();
    }

    function clearData() {
        csvData = [];
        csvHeaders = [];
        validationResults = [];

        document.getElementById('fileName').textContent = '';
        document.getElementById('fileInput').value = '';
        document.getElementById('summaryStats').classList.add('hidden');
        document.getElementById('filterControls').classList.add('hidden');
        document.getElementById('resultsSection').classList.add('hidden');
        document.getElementById('actionButtons').classList.add('hidden');
        document.getElementById('dependenciesPanel').classList.add('hidden');
        document.getElementById('tableBody').innerHTML = '';
    }

    function showLoading(text) {
        document.getElementById('loadingText').textContent = text || 'Processing...';
        document.getElementById('loadingOverlay').classList.remove('hidden');
    }

    function hideLoading() {
        document.getElementById('loadingOverlay').classList.add('hidden');
    }

    // ============================================
    // Column Reference
    // ============================================

    function populateColumnReference() {
        const grid = document.getElementById('columnGrid');
        let html = '';

        Object.entries(PPP_COLUMNS).forEach(([name, def]) => {
            html += `
                <div class="column-item">
                    <span class="col-name">${name}</span>
                    <span class="col-type">${def.type}</span>
                    ${def.required ? '<span class="col-required">*Required</span>' : ''}
                    <div class="col-desc">${def.desc}</div>
                    ${def.validValues ? `<div class="col-desc" style="color: var(--fb-info);">Values: ${def.validValues.join(', ')}</div>` : ''}
                </div>
            `;
        });

        // Add note about custom fields
        html += `
            <div class="column-item" style="background-color: var(--fb-warning-bg);">
                <span class="col-name">CF-*</span>
                <span class="col-type">Custom Field</span>
                <div class="col-desc">Any column starting with "CF-" is treated as a custom field. The field name after "CF-" must match an existing custom field in Fishbowl.</div>
            </div>
        `;

        grid.innerHTML = html;
    }

    function toggleColumnReference() {
        const grid = document.getElementById('columnGrid');
        const toggle = document.getElementById('refToggle');

        if (grid.classList.contains('hidden')) {
            grid.classList.remove('hidden');
            toggle.textContent = '‚ñº';
        } else {
            grid.classList.add('hidden');
            toggle.textContent = '‚ñ∂';
        }
    }
    </script>
</body>
</html>
