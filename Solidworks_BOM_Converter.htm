<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solidworks BOM Conversion Tool</title>

    <!-- External Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <!-- Google Fonts - Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">

    <!-- Bootstrap Icons (icon font only) -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css" rel="stylesheet">

    <!-- Bootstrap CSS (for component structure - overridden by custom styles below) -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">

    <style>
        /* ============================================
           GLOBAL STYLES & CSS VARIABLES
           ============================================ */
        * {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        body {
            font-size: 12px;
            padding: 8px;
            background: #f5f5f5;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            font-size: 16px;
            font-weight: 600;
            color: #333;
            margin-bottom: 4px;
        }

        .subtitle {
            font-size: 12px;
            color: #666;
            margin-bottom: 12px;
        }

        :root {
            /* Brand Colors */
            --color-primary: #2d9cdb;           /* Bright blue */
            --color-primary-dark: #1e7bb4;      /* Darker blue for hover */
            --color-sidebar: #06162d;
            --color-sidebar-hover: #0a1f3d;
        }

        /* ============================================
           TAILWIND COLOR OVERRIDES
           ============================================ */
        /* Override Tailwind indigo with custom blue */
        .bg-indigo-600 {
            background-color: var(--color-primary) !important;
        }
        .hover\:bg-indigo-700:hover {
            background-color: var(--color-primary-dark) !important;
        }
        .text-indigo-600 {
            color: var(--color-primary) !important;
        }
        .border-indigo-300 {
            border-color: rgba(45, 156, 219, 0.4) !important;
        }
        .focus\:ring-indigo-100:focus {
            --tw-ring-color: rgba(45, 156, 219, 0.2) !important;
        }
        .focus\:border-indigo-300:focus {
            border-color: rgba(45, 156, 219, 0.4) !important;
        }

        /* ============================================
           BOOTSTRAP COMPONENT OVERRIDES
           ============================================ */

        /* Button Overrides - Compact Style */
        .btn {
            padding: 6px 12px;
            font-size: 12px;
            border: 1px solid #ccc;
            background: white;
            border-radius: 3px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.15s ease;
        }

        .btn:hover {
            background: #f0f0f0;
        }

        .btn-primary {
            background: #2d9cdb;
            color: white;
            border-color: #2d9cdb;
        }

        .btn-primary:hover {
            background: #1e7bb4;
            border-color: #1e7bb4;
        }

        .btn-outline-primary {
            color: #2d9cdb;
            border-color: #ccc;
            background: white;
        }

        .btn-outline-primary:hover {
            background: #2d9cdb;
            border-color: #2d9cdb;
            color: white;
        }

        .btn-outline-success {
            color: #10b981;
            border-color: #ccc;
            background: white;
        }

        .btn-outline-success:hover {
            background: #10b981;
            border-color: #10b981;
            color: white;
        }

        .btn-success {
            background: #10b981;
            color: white;
            border-color: #10b981;
        }

        .btn-success:hover {
            background: #059669;
            border-color: #059669;
        }

        .btn-sm {
            padding: 4px 8px;
            font-size: 11px;
        }

        .btn i {
            font-size: 11px;
        }

        /* Form Control Overrides - Compact */
        .form-control, .form-select {
            padding: 4px 8px;
            font-size: 12px;
            border: 1px solid #cbd5e1;
            border-radius: 3px;
            color: #334155;
        }

        .form-control:focus, .form-select:focus {
            outline: none;
            border-color: #2d9cdb;
            box-shadow: none;
        }

        .form-select-sm {
            padding: 4px 8px;
            font-size: 11px;
        }

        .form-check-input {
            border-color: #cbd5e1;
        }

        .form-check-input:checked {
            background-color: var(--color-primary);
            border-color: var(--color-primary);
        }

        .form-check-label {
            font-size: 12px;
        }

        /* Alert Overrides - Compact */
        .alert {
            border-radius: 4px;
            border: 1px solid;
            font-size: 12px;
            padding: 8px 12px;
        }

        .alert-info {
            background-color: #eff6ff;
            border-color: #93c5fd;
            color: #1e40af;
        }

        .alert-warning {
            background-color: #fef3c7;
            border-color: #fcd34d;
            color: #92400e;
        }

        .alert-danger {
            background-color: #fee2e2;
            border-color: #fca5a5;
            color: #991b1b;
        }

        .alert-success {
            background-color: #d1fae5;
            border-color: #6ee7b7;
            color: #065f46;
        }

        /* Progress Bar Overrides */
        .progress {
            background-color: #e2e8f0;
            border-radius: 3px;
            height: 6px;
        }

        .progress-bar {
            background-color: var(--color-primary);
        }

        /* Accordion Overrides - Compact */
        .accordion-button {
            background-color: #f8f9fa;
            color: #333;
            font-weight: 600;
            font-size: 12px;
            padding: 8px 12px;
            border-radius: 4px !important;
        }

        .accordion-button:not(.collapsed) {
            background-color: #eff6ff;
            color: var(--color-primary-dark);
        }

        .accordion-button:focus {
            box-shadow: none;
            border-color: transparent;
        }

        .accordion-item {
            border: 1px solid #ddd;
            border-radius: 4px !important;
            margin-bottom: 8px;
        }

        /* Table Overrides */
        .table {
            color: #334155;
        }

        .table thead th {
            background-color: #f8fafc;
            color: #475569;
            font-weight: 700;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 2px solid #e2e8f0;
        }

        .table-hover tbody tr:hover {
            background-color: #f8fafc;
        }

        /* Modal Overrides - Compact */
        .modal-content {
            border-radius: 4px;
            border: 1px solid #ddd;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .modal-header {
            border-bottom: 1px solid #e2e8f0;
            padding: 12px 16px;
        }

        .modal-title {
            font-weight: 600;
            font-size: 14px;
            color: white;
        }

        .modal-body {
            padding: 16px;
        }

        /* Badge Overrides - Compact */
        .badge {
            font-weight: 600;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
        }

        .bg-success {
            background-color: #10b981 !important;
        }

        .bg-info {
            background-color: #3b82f6 !important;
        }

        .bg-warning {
            background-color: #f59e0b !important;
        }

        .bg-danger {
            background-color: #ef4444 !important;
        }

        /* Text Color Overrides */
        .text-muted {
            color: #64748b !important;
        }

        .text-primary {
            color: var(--color-primary) !important;
        }

        .text-success {
            color: #10b981 !important;
        }

        .text-danger {
            color: #ef4444 !important;
        }

        .text-warning {
            color: #f59e0b !important;
        }

        /* ============================================
           CUSTOM SCROLLBAR
           ============================================ */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 4px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        /* ============================================
           UPLOAD SECTION - Compact
           ============================================ */
        .upload-section {
            padding: 16px;
            background-color: white;
            border: 2px dashed #ddd;
            border-radius: 4px;
            text-align: center;
            margin-bottom: 8px;
            transition: all 0.2s ease;
        }

        .upload-section:hover {
            border-color: var(--color-primary);
            background-color: #f8fafc;
        }

        .upload-section.dragover {
            border-color: #10b981;
            background-color: #d1fae5;
            border-style: solid;
        }

        .upload-section h3 {
            margin: 0 0 6px 0;
            color: #333;
            font-size: 14px;
            font-weight: 600;
        }

        .upload-section p {
            margin: 4px 0;
            font-size: 12px;
            color: #666;
        }

        /* ============================================
           SUMMARY STATS - Inline Badge Style
           ============================================ */
        .summary-stats {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            flex-wrap: wrap;
            align-items: center;
            font-size: 12px;
        }

        .stat-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 600;
            border: 1px solid;
        }

        .stat-badge.total {
            background-color: #eff6ff;
            border-color: #93c5fd;
            color: #1e40af;
        }

        .stat-badge.parts {
            background-color: #eff6ff;
            border-color: #60a5fa;
            color: #1e40af;
        }

        .stat-badge.boms {
            background-color: #f1f5f9;
            border-color: #cbd5e1;
            color: #475569;
        }

        .stat-badge.new-parts {
            background-color: #d1fae5;
            border-color: #6ee7b7;
            color: #065f46;
        }

        .stat-badge.warning {
            background-color: #fef3c7;
            border-color: #fcd34d;
            color: #92400e;
        }

        .stat-badge.error {
            background-color: #fee2e2;
            border-color: #fca5a5;
            color: #991b1b;
        }

        .stat-number {
            font-weight: 700;
        }

        .stat-label {
            opacity: 0.85;
        }

        /* ============================================
           TABLE STYLES - Compact
           ============================================ */
        .results-table-container {
            max-height: 600px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 8px;
            background-color: white;
        }

        .data-table,
        .table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .data-table th,
        .table thead th {
            background-color: #f8f9fa;
            padding: 8px;
            text-align: left;
            font-size: 11px;
            font-weight: 600;
            color: #475569;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 2px solid #e2e8f0;
            position: sticky;
            top: 0;
            z-index: 10;
            white-space: nowrap;
        }

        .data-table td,
        .table td {
            padding: 6px 8px;
            border-bottom: 1px solid #e9ecef;
            font-size: 12px;
            color: #334155;
        }

        .data-table tbody tr:hover,
        .table tbody tr:hover,
        .table-hover tbody tr:hover {
            background-color: #f8fafc;
        }

        /* BOM Tree Table Styling */
        .bom-header-row {
            background-color: #f1f5f9 !important;
            font-weight: 600;
        }

        .bom-header-row:hover {
            background-color: #e2e8f0 !important;
        }

        .bom-header-row td {
            border-top: 2px solid #cbd5e1;
            border-bottom: 2px solid #cbd5e1;
        }

        /* ============================================
           OFFCANVAS / SIDEBAR STYLING - Compact
           ============================================ */
        .offcanvas {
            background-color: white !important;
            box-shadow: -4px 0 12px rgba(0, 0, 0, 0.15);
        }

        .offcanvas.offcanvas-start {
            box-shadow: 4px 0 12px rgba(0, 0, 0, 0.15);
        }

        .offcanvas-header {
            background-color: var(--color-primary);
            color: white;
            border-bottom: 1px solid var(--color-primary-dark);
            padding: 12px 16px;
        }

        .offcanvas-title {
            color: white;
            font-weight: 600;
            font-size: 14px;
        }

        .offcanvas-title i {
            font-size: 13px;
        }

        .offcanvas-body {
            padding: 12px;
        }

        .btn-close {
            filter: brightness(0) invert(1);
        }

        /* ============================================
           STICKY OFFCANVAS TABS
           ============================================ */
        .offcanvas-tab {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            z-index: 1001;
            background-color: var(--color-primary);
            color: white;
            border: none;
            border-radius: 8px 0 0 8px;
            padding: 40px 8px;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: -2px 2px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            letter-spacing: 2px;
        }

        .offcanvas-tab:hover {
            background-color: var(--color-primary-dark);
            box-shadow: -4px 4px 12px rgba(0, 0, 0, 0.4);
        }

        .offcanvas-tab.tab-right {
            right: 0;
            border-radius: 8px 0 0 8px;
        }

        .offcanvas-tab.tab-right:hover {
            right: 5px;
        }

        .offcanvas-tab.tab-left {
            left: 0;
            border-radius: 0 8px 8px 0;
            box-shadow: 2px 2px 8px rgba(0, 0, 0, 0.3);
        }

        .offcanvas-tab.tab-left:hover {
            left: 5px;
            box-shadow: 4px 4px 12px rgba(0, 0, 0, 0.4);
        }

        @media print {
            .offcanvas-tab {
                display: none !important;
            }
        }

        /* ============================================
           CONFIGURATION SETTINGS STYLING - Compact
           ============================================ */
        .config-group {
            margin-bottom: 12px;
            padding: 12px;
            background-color: #f8fafc;
            border-radius: 4px;
            border: 1px solid #ddd;
        }

        .config-group h5 {
            color: #333;
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .config-item {
            margin-bottom: 8px;
        }

        .config-item label {
            display: block;
            font-size: 11px;
            font-weight: 600;
            color: #475569;
            margin-bottom: 4px;
        }

        .form-check-label {
            font-size: 12px;
            color: #334155;
            font-weight: 400;
        }

        /* ============================================
           BOM TREE VISUALIZATION
           ============================================ */
        .bom-tree {
            margin-bottom: 20px;
        }

        .bom-item {
            padding: 10px;
            margin: 4px 0;
            border-left: 3px solid var(--color-primary);
            background-color: #f8fafc;
            border-radius: 4px;
        }

        .bom-item.level-0 {
            margin-left: 0;
            border-left-color: var(--color-primary-dark);
            font-weight: 600;
        }

        .bom-item.level-1 {
            margin-left: 20px;
            border-left-color: var(--color-primary);
        }

        .bom-item.level-2 {
            margin-left: 40px;
            border-left-color: #60a5fa;
        }

        .bom-item.level-3 {
            margin-left: 60px;
            border-left-color: #93c5fd;
        }

        /* ============================================
           UTILITY CLASSES
           ============================================ */
        .hidden {
            display: none !important;
        }

        /* ============================================
           INFO BOXES - Compact
           ============================================ */
        .info-box {
            padding: 10px;
            background-color: #eff6ff;
            border-left: 3px solid var(--color-primary);
            border-radius: 3px;
            margin-bottom: 12px;
            font-size: 12px;
            color: #334155;
        }

        .info-box ul {
            margin-bottom: 0;
            padding-left: 18px;
        }

        .info-box li {
            margin-bottom: 4px;
        }

        .info-box h6 {
            font-size: 12px;
            margin-bottom: 6px;
        }

        /* ============================================
           FIELD MAPPING SECTION - Compact
           ============================================ */
        .mapping-section {
            margin: 12px 0;
            padding: 12px;
            background-color: #f8fafc;
            border-radius: 4px;
            border: 1px solid #ddd;
        }

        .mapping-row {
            display: grid;
            grid-template-columns: 45% 10% 45%;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            padding: 6px;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #e2e8f0;
        }

        .mapping-label {
            font-weight: 500;
            color: #334155;
            font-size: 12px;
        }

        .mapping-arrow {
            color: var(--color-primary);
            font-size: 14px;
            text-align: center;
        }

        .mapping-select {
            padding: 4px 8px;
            border: 1px solid #cbd5e1;
            border-radius: 3px;
            font-size: 12px;
            width: 100%;
            background-color: white;
            color: #334155;
        }

        .mapping-select:focus {
            outline: none;
            border-color: var(--color-primary);
            box-shadow: none;
        }

        .required-field::after {
            content: " *";
            color: #ef4444;
        }

        /* ============================================
           DEBUG SECTION - Compact
           ============================================ */
        .debug-section {
            margin-top: 12px;
            margin-bottom: 12px;
        }

        .debug-content {
            max-height: 200px;
            overflow-y: auto;
            background-color: #1e293b;
            color: #e2e8f0;
            padding: 8px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            line-height: 1.5;
        }

        .debug-entry {
            margin-bottom: 6px;
            padding: 4px 0;
            border-bottom: 1px solid #334155;
        }

        .debug-timestamp {
            color: #64748b;
            font-size: 10px;
        }

        .debug-type {
            font-weight: bold;
            margin-right: 6px;
        }

        .debug-type.info {
            color: #38bdf8;
        }

        .debug-type.success {
            color: #4ade80;
        }

        .debug-type.warning {
            color: #fb923c;
        }

        .debug-type.error {
            color: #f87171;
        }

        .debug-message {
            color: #e2e8f0;
        }

        .debug-data {
            margin-top: 3px;
            padding-left: 12px;
            color: #fbbf24;
            white-space: pre-wrap;
            word-break: break-all;
        }
    </style>
</head>

<body>
    <!-- Sticky Side Tab Buttons -->
    <button class="offcanvas-tab tab-left" type="button" data-bs-toggle="offcanvas" data-bs-target="#settingsOffcanvas" aria-controls="settingsOffcanvas">
        SETTINGS
    </button>
    <button class="offcanvas-tab tab-right" type="button" data-bs-toggle="offcanvas" data-bs-target="#instructionsOffcanvas" aria-controls="instructionsOffcanvas">
        INSTRUCTIONS
    </button>

    <!-- Left Offcanvas: Configuration Settings -->
    <div class="offcanvas offcanvas-start" tabindex="-1" id="settingsOffcanvas" aria-labelledby="settingsOffcanvasLabel" style="width: 380px;">
        <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="settingsOffcanvasLabel"><i class="bi bi-gear-fill"></i> Configuration Settings</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
        </div>
        <div class="offcanvas-body">
            <div class="config-group">
                <h5><i class="bi bi-sliders"></i> Default Values</h5>
                <div class="config-item">
                    <label for="defaultUOM">Default UOM (Part UOM)</label>
                    <select class="form-select form-select-sm" id="defaultUOM" onchange="saveSettings()">
                        <option value="ea" selected>ea (Each)</option>
                        <!-- Will be populated from Fishbowl -->
                    </select>
                    <small class="text-muted d-block mt-1">Default unit of measure for parts without specified UOM</small>
                </div>
                <div class="config-item">
                    <label for="defaultTaxCode">Default Tax Code</label>
                    <select class="form-select form-select-sm" id="defaultTaxCode" onchange="saveSettings()">
                        <option value="NON">NON (Non-Taxable)</option>
                        <!-- Will be populated from Fishbowl -->
                    </select>
                    <small class="text-muted d-block mt-1">Tax code for new parts</small>
                </div>
                <div class="config-item">
                    <label for="defaultWeightUOM">Default Weight UOM</label>
                    <select class="form-select form-select-sm" id="defaultWeightUOM" onchange="saveSettings()">
                        <optgroup label="Metric">
                            <option value="kg" selected>kg (Kilogram)</option>
                            <option value="g">g (Gram)</option>
                        </optgroup>
                        <optgroup label="Imperial">
                            <option value="lb">lb (Pound)</option>
                            <option value="oz">oz (Ounce)</option>
                        </optgroup>
                    </select>
                    <small class="text-muted d-block mt-1">Unit for part weights</small>
                </div>
                <div class="config-item">
                    <label for="defaultSizeUOM">Default Size UOM</label>
                    <select class="form-select form-select-sm" id="defaultSizeUOM" onchange="saveSettings()">
                        <optgroup label="Metric">
                            <option value="cm" selected>cm (Centimeter)</option>
                            <option value="mm">mm (Millimeter)</option>
                            <option value="m">m (Meter)</option>
                        </optgroup>
                        <optgroup label="Imperial">
                            <option value="in">in (Inch)</option>
                            <option value="ft">ft (Foot)</option>
                        </optgroup>
                    </select>
                    <small class="text-muted d-block mt-1">Unit for dimensions (width, height, length)</small>
                </div>
            </div>

            <div class="config-group">
                <h5><i class="bi bi-box-seam"></i> Part Creation Options</h5>
                <div class="config-item">
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="createAsInventory" checked onchange="saveSettings()">
                        <label class="form-check-label" for="createAsInventory">
                            Create new parts as Inventory type
                        </label>
                    </div>
                    <small class="text-muted d-block mt-1">All new parts will be created with Part Type = Inventory</small>
                </div>
                <div class="config-item">
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="createFinishedGoodsAsProducts" onchange="saveSettings()">
                        <label class="form-check-label" for="createFinishedGoodsAsProducts">
                            Create finished goods as Products
                        </label>
                    </div>
                    <small class="text-muted d-block mt-1">Parts that are output of a BOM/stage will also be created as products</small>
                </div>
            </div>

            <div class="config-group">
                <h5><i class="bi bi-diagram-3"></i> BOM Processing Options</h5>
                <div class="config-item">
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="validatePartsExist" checked onchange="saveSettings()">
                        <label class="form-check-label" for="validatePartsExist">
                            Validate all parts before creating BOMs
                        </label>
                    </div>
                    <small class="text-muted d-block mt-1">Ensure all required parts exist before BOM creation</small>
                </div>
                <div class="config-item">
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="processStagesSequentially" checked onchange="saveSettings()">
                        <label class="form-check-label" for="processStagesSequentially">
                            Process staged BOMs sequentially
                        </label>
                    </div>
                    <small class="text-muted d-block mt-1">Create parts from earlier stages before later stages</small>
                </div>
                <div class="config-item">
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="createBOMFromFilename" onchange="saveSettings()">
                        <label class="form-check-label" for="createBOMFromFilename">
                            Create top-level BOM from filename
                        </label>
                    </div>
                    <small class="text-muted d-block mt-1">Wrap all BOMs in a main assembly named after the CSV file</small>
                </div>
                <div class="config-item">
                    <label for="autoCreateType" class="form-label" style="font-weight: 500;">BOM Auto Create Type</label>
                    <select class="form-select form-select-sm" id="autoCreateType" onchange="saveSettings()">
                        <option value="Never">Never</option>
                        <option value="Short Quantity">Short Quantity</option>
                        <option value="Order Quantity">Order Quantity</option>
                        <option value="Always Create">Always Create</option>
                        <option value="Build To Order">Build To Order</option>
                    </select>
                    <small class="text-muted d-block mt-1">How BOMs should auto-create work orders in Fishbowl</small>
                </div>
            </div>

            <!-- Configuration Management -->
            <div class="config-group mt-4">
                <h5><i class="bi bi-file-earmark-arrow-down"></i> Configuration</h5>
                <div class="d-grid gap-2">
                    <button class="btn btn-success btn-sm" onclick="saveConfiguration()">
                        <i class="bi bi-download"></i> Save Configuration
                    </button>
                    <button class="btn btn-outline-primary btn-sm" onclick="loadConfiguration()">
                        <i class="bi bi-upload"></i> Load Configuration
                    </button>
                </div>
                <small class="text-muted d-block mt-2">
                    <i class="bi bi-info-circle"></i> Saves/loads both settings and field mappings together
                </small>
            </div>

            <div class="alert alert-info mt-3" style="font-size: 12px;">
                <i class="bi bi-info-circle-fill"></i> Changes take effect when you process the next file.
            </div>
        </div>
    </div>

    <!-- Right Offcanvas: Instructions -->
    <div class="offcanvas offcanvas-end" tabindex="-1" id="instructionsOffcanvas" aria-labelledby="instructionsOffcanvasLabel" style="width: 500px;">
        <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="instructionsOffcanvasLabel"><i class="bi bi-book-fill"></i> How to Use This Tool</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
        </div>
        <div class="offcanvas-body">
            <div class="info-box">
                <h6 class="fw-bold mb-2"><i class="bi bi-1-circle-fill"></i> Export from Solidworks</h6>
                <p>Export your Bill of Materials from Solidworks as a CSV file with:</p>
                <ul style="font-size: 12px;">
                    <li><strong>Dotted indentation levels</strong> (1, 1.1, 1.1.1, 1.2, 2, 2.1...)</li>
                    <li>Part numbers, descriptions, quantities</li>
                    <li>Optional: vendor info, costs, UPC, dimensions</li>
                </ul>
            </div>

            <div class="info-box">
                <h6 class="fw-bold mb-2"><i class="bi bi-2-circle-fill"></i> Upload & Map Fields</h6>
                <p style="font-size: 12px;">Drag and drop your CSV file, then map Solidworks columns to Fishbowl fields in the popup dialog.</p>
                <p style="font-size: 12px;"><strong>Required mappings:</strong></p>
                <ul style="font-size: 11px;">
                    <li><strong>Level</strong> - BOM hierarchy (1, 1.1, 1.2...)</li>
                    <li><strong>Number</strong> - Part number</li>
                    <li><strong>Description</strong> - Part description</li>
                    <li><strong>Quantity</strong> - Component quantity</li>
                </ul>
                <p style="font-size: 12px;"><strong>Optional but recommended:</strong> UOM, Vendor, Vendor Cost, UPC, Dimensions</p>
            </div>

            <div class="info-box">
                <h6 class="fw-bold mb-2"><i class="bi bi-3-circle-fill"></i> Configure Settings</h6>
                <p style="font-size: 12px;">Click the <strong>Settings</strong> tab (left side) to configure:</p>
                <ul style="font-size: 11px;">
                    <li><strong>Default UOM/Tax Code</strong> - Applied to parts without values</li>
                    <li><strong>Create as Inventory</strong> - Part type (checked) vs other types</li>
                    <li><strong>Create Finished Goods as Products</strong> - Make FG parts sellable products</li>
                    <li><strong>Validate Parts Exist</strong> - Check against Fishbowl database</li>
                    <li><strong>Process Stages Sequentially</strong> - Create sub-assemblies first</li>
                    <li><strong>Create BOM from Filename</strong> - Wrap all BOMs in top-level assembly</li>
                    <li><strong>BOM Auto Create Type</strong> - Work order creation rules</li>
                </ul>
            </div>

            <div class="info-box">
                <h6 class="fw-bold mb-2"><i class="bi bi-4-circle-fill"></i> Review BOM Structure</h6>
                <p style="font-size: 12px;">The tool displays:</p>
                <ul style="font-size: 11px;">
                    <li><strong>Hierarchical tree</strong> - Click to expand/collapse assemblies</li>
                    <li><strong>Cost rollup</strong> - Calculated from vendor costs or Fishbowl data</li>
                    <li><strong>Part badges</strong> - Shows Finished Good, Raw Good, or Stage types</li>
                    <li><strong>Subtotals</strong> - Per assembly and grand total</li>
                </ul>
            </div>

            <div class="info-box">
                <h6 class="fw-bold mb-2"><i class="bi bi-5-circle-fill"></i> Export or Import</h6>
                <p style="font-size: 12px;"><strong>CSV Export (manual):</strong></p>
                <ul style="font-size: 11px;">
                    <li><strong>Export PPP</strong> - Part/Product/Vendor Pricing CSV for manual import</li>
                    <li><strong>Export BOM</strong> - BOM Import CSV for manual import</li>
                </ul>
                <p style="font-size: 12px;"><strong>Direct API (automatic):</strong></p>
                <ul style="font-size: 11px;">
                    <li><strong>Create Parts</strong> - Import parts directly via Fishbowl API</li>
                    <li><strong>Create BOMs</strong> - Import BOMs directly via Fishbowl API</li>
                </ul>
            </div>

            <div class="alert alert-warning mt-3" style="font-size: 11px;">
                <i class="bi bi-exclamation-triangle-fill"></i> <strong>Import Order:</strong> Always create parts BEFORE BOMs. BOMs require all referenced parts to exist.
            </div>

            <div class="alert alert-info mt-3" style="font-size: 11px;">
                <i class="bi bi-lightbulb-fill"></i> <strong>Tip:</strong> Save/load configuration files to reuse field mappings and settings across sessions.
            </div>
        </div>
    </div>

    <!-- Field Mapping Modal -->
    <div class="modal fade" id="fieldMappingModal" tabindex="-1" aria-labelledby="fieldMappingModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header" style="background-color: var(--fb-primary); color: white;">
                    <h5 class="modal-title" id="fieldMappingModalLabel">
                        <i class="bi bi-arrows-angle-contract"></i> Map Solidworks Columns to Fishbowl BOM Import
                    </h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="alert alert-info mb-3">
                        <i class="bi bi-info-circle-fill"></i> Map your Solidworks BOM columns to Fishbowl fields. Fields marked with <span class="text-danger">*</span> are required.
                    </div>

                    <div style="display: grid; grid-template-columns: 45% 10% 45%; gap: 10px; margin-bottom: 15px; font-weight: bold;">
                        <div>Fishbowl Field</div>
                        <div style="text-align: center;"></div>
                        <div>Solidworks Column</div>
                    </div>

                    <!-- BOM field mappings -->
                    <div id="bomLevelMappings">
                        <!-- Will be populated dynamically -->
                    </div>

                    <!-- Hidden - not used anymore but keeping for compatibility -->
                    <div id="itemLevelMappings" style="display: none;"></div>

                    <div class="alert alert-warning mt-3 mb-0">
                        <small><i class="bi bi-lightbulb-fill"></i> <strong>Tip:</strong> Use "None" to skip optional fields. Required fields must be mapped.</small>
                    </div>
                </div>
                <div class="modal-footer">
                    <div class="me-auto">
                        <button type="button" class="btn btn-sm btn-outline-secondary" onclick="exportMappingFile()">
                            <i class="bi bi-download"></i> Export Mapping
                        </button>
                        <button type="button" class="btn btn-sm btn-outline-secondary" onclick="importMappingFile()">
                            <i class="bi bi-upload"></i> Import Mapping
                        </button>
                    </div>
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" onclick="saveMappings()">
                        <i class="bi bi-save"></i> Save & Process
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div class="container">
        <h1>Solidworks BOM Conversion Tool</h1>
        <p class="subtitle">Convert Solidworks BOM exports to Fishbowl-compatible Part and BOM imports</p>

        <!-- Upload Section -->
        <div class="upload-section" id="uploadSection">
            <h3>ðŸ“„ Upload Solidworks BOM CSV</h3>
            <p>Drag and drop file here, or <button type="button" class="btn btn-primary" onclick="document.getElementById('fileInput').click()">Choose File</button></p>
            <input type="file" id="fileInput" accept=".csv" onchange="handleFileSelect(event)" style="display: none;" />
            <p id="fileName" class="text-primary fw-bold"></p>
        </div>

        <!-- Field Mapping Button (hidden until file loaded) -->
        <div style="text-align: center; margin-bottom: 8px;" class="hidden" id="mappingButtonSection">
            <button class="btn btn-primary" onclick="openFieldMappingDialog()">
                <i class="bi bi-arrows-angle-contract"></i> Configure Field Mapping
            </button>
            <button class="btn btn-outline-primary" style="margin-left: 8px;" onclick="importMappingFile()" title="Load saved field mappings from JSON file">
                <i class="bi bi-upload"></i> Load Saved Mappings
            </button>
            <p class="text-muted" style="margin-top: 6px; margin-bottom: 0; font-size: 11px;">
                Map Solidworks columns to Fishbowl fields, or load a saved mapping configuration
            </p>
        </div>

        <!-- Summary Stats (hidden until file loaded) -->
        <div class="summary-stats hidden" id="summaryStats">
            <span class="stat-badge total">
                <span class="stat-label">Total:</span>
                <span class="stat-number" id="statTotal">0</span>
            </span>
            <span class="stat-badge parts">
                <span class="stat-label">Parts:</span>
                <span class="stat-number" id="statParts">0</span>
            </span>
            <span class="stat-badge new-parts">
                <span class="stat-label">New:</span>
                <span class="stat-number" id="statNewParts">0</span>
            </span>
            <span class="stat-badge boms">
                <span class="stat-label">BOMs:</span>
                <span class="stat-number" id="statBOMs">0</span>
            </span>
            <span class="stat-badge warning">
                <span class="stat-label">Warnings:</span>
                <span class="stat-number" id="statWarnings">0</span>
            </span>
            <span class="stat-badge error">
                <span class="stat-label">Errors:</span>
                <span class="stat-number" id="statErrors">0</span>
            </span>
        </div>

        <!-- Progress Section (hidden until processing) -->
        <div class="progress-section hidden" id="progressSection">
            <div class="alert alert-info">
                <i class="bi bi-hourglass-split"></i> <span id="progressText">Processing...</span>
            </div>
            <div class="progress">
                <div class="progress-bar progress-bar-striped progress-bar-animated" id="progressBar" role="progressbar" style="width: 0%"></div>
            </div>
        </div>

        <!-- BOM Structure Preview (hidden until file loaded) -->
        <div class="hidden" id="bomStructureSection">
            <h3>ðŸ“Š BOM Structure</h3>
            <div class="bom-tree" id="bomTree">
                <!-- Will be populated dynamically -->
            </div>
        </div>

        <!-- Parts to Create (hidden until file loaded) -->
        <div class="hidden" id="partsSection">
            <div class="accordion" id="partsAccordion">
                <div class="accordion-item">
                    <h2 class="accordion-header">
                        <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#partsContent" aria-expanded="true">
                            <i class="bi bi-box-seam me-2"></i> ðŸ”§ Parts to Create (<span id="partsCount">0</span>)
                        </button>
                    </h2>
                    <div id="partsContent" class="accordion-collapse collapse show" data-bs-parent="#partsAccordion">
                        <div class="accordion-body p-0">
                            <div class="results-table-container">
                                <table class="table table-sm table-hover mb-0" id="partsTable">
                                    <thead>
                                        <tr>
                                            <th>Part Number</th>
                                            <th>Description</th>
                                            <th>UOM</th>
                                            <th>Type</th>
                                            <th>Status</th>
                                        </tr>
                                    </thead>
                                    <tbody id="partsTableBody">
                                        <!-- Will be populated dynamically -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- BOMs to Create (hidden until file loaded) -->
        <div class="hidden" id="bomsSection">
            <div class="accordion" id="bomsAccordion">
                <div class="accordion-item">
                    <h2 class="accordion-header">
                        <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#bomsContent" aria-expanded="true">
                            <i class="bi bi-diagram-3 me-2"></i> ðŸ“‹ BOMs to Create (<span id="bomsCount">0</span>)
                        </button>
                    </h2>
                    <div id="bomsContent" class="accordion-collapse collapse show" data-bs-parent="#bomsAccordion">
                        <div class="accordion-body p-0">
                            <div class="results-table-container">
                                <table class="table table-sm table-hover mb-0" id="bomsTable">
                                    <thead>
                                        <tr>
                                            <th>BOM Name</th>
                                            <th>Parent Part</th>
                                            <th>Items</th>
                                            <th>Stage</th>
                                            <th>Status</th>
                                        </tr>
                                    </thead>
                                    <tbody id="bomsTableBody">
                                        <!-- Will be populated dynamically -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Export Section (hidden until ready) -->
        <div class="export-section hidden" id="exportSection">
            <h4>ðŸ“¥ Export & Import to Fishbowl</h4>

            <div class="d-flex gap-2 justify-content-center flex-wrap">
                <button class="btn btn-sm btn-outline-success" onclick="exportPartImport()">
                    <i class="bi bi-download"></i> Export PPP
                </button>
                <button class="btn btn-sm btn-outline-primary" onclick="exportBOMImport()">
                    <i class="bi bi-download"></i> Export BOM
                </button>
                <button class="btn btn-sm btn-success" onclick="importPartsToFishbowl()">
                    <i class="bi bi-upload"></i> Create Parts
                </button>
                <button class="btn btn-sm btn-primary" onclick="importBOMsToFishbowl()">
                    <i class="bi bi-upload"></i> Create BOMs
                </button>
            </div>
        </div>

        <!-- Toast Container (Bottom-Right) -->
        <div class="toast-container position-fixed bottom-0 end-0 p-3" id="toastContainer">
            <!-- Dynamic toasts will appear here -->
        </div>

        <!-- Debug Section -->
        <div class="debug-section">
            <div class="accordion" id="debugAccordion">
                <div class="accordion-item">
                    <h2 class="accordion-header">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#debugContent" aria-expanded="false" aria-controls="debugContent">
                            <i class="bi bi-bug-fill me-2"></i> Debug Console
                        </button>
                    </h2>
                    <div id="debugContent" class="accordion-collapse collapse" data-bs-parent="#debugAccordion">
                        <div class="accordion-body p-0">
                            <div class="p-2 bg-dark text-white d-flex justify-content-between align-items-center">
                                <small>Debug log - Auto-scrolls to latest entry</small>
                                <button class="btn btn-sm btn-outline-light" onclick="clearDebugLog()">
                                    <i class="bi bi-trash"></i> Clear
                                </button>
                            </div>
                            <div class="debug-content" id="debugLog">
                                <div class="debug-entry">
                                    <span class="debug-timestamp">[00:00:00]</span>
                                    <span class="debug-type info">[INFO]</span>
                                    <span class="debug-message">Debug console initialized</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Bootstrap 5 JS Bundle (includes Popper) -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

    <script>
        // Configuration state
        const config = {
            createAsInventory: true,
            createFinishedGoodsAsProducts: false,
            validatePartsExist: true,
            processStagesSequentially: true,
            createBOMFromFilename: false,
            autoCreateType: 'Build To Order' // Options: Never, Short Quantity, Order Quantity, Always Create, Build To Order
        };

        // Application state
        let solidworksData = null;
        let rawCSVContent = null; // Store raw CSV before processing
        let csvFilename = null; // Store the CSV filename for BOM creation
        let parsedBOM = null;
        let partsToCreate = [];
        let bomsToCreate = [];
        let bomImportHeaders = null;
        let bomLevelHeaders = [];
        let itemLevelHeaders = [];
        let partImportHeaders = []; // Store part import headers from API
        let solidworksColumns = [];
        let fieldMappings = {};

        // Fishbowl data cache
        let fishbowlData = {
            uoms: [],
            uomDetails: [],
            vendors: [],
            taxCodes: [],
            taxCodeDetails: [],
            existingParts: [], // Cache of existing parts in Fishbowl
            partTypes: ['Inventory', 'Non-Inventory', 'Service', 'Labor', 'Overhead', 'Miscellaneous', 'Internal Use', 'Capital Equipment', 'Shipping']
        };

        // User-configurable defaults
        let defaultValues = {
            uom: 'ea',
            taxCode: 'NON',
            weightUOM: 'kg', // Metric default
            sizeUOM: 'cm',   // Metric default
            active: true
        };

        // BOM Field definitions (from Fishbowl documentation)
        const bomFieldDefinitions = {
            'Level': { required: true, desc: 'Hierarchical level (1, 1.1, 1.2, etc.)', validate: false },
            'Number': { required: true, desc: 'Part number in Fishbowl', validate: false },
            'Description': { required: true, desc: 'Part description', validate: false },
            'Details': { required: false, desc: 'Additional details about the part', validate: false },
            'Revision': { required: false, desc: 'Revision identifier', validate: false },
            'Standard Cost': { required: false, desc: 'Anticipated cost per unit', validate: false },
            'Quantity': { required: true, desc: 'Quantity needed in BOM', validate: false },
            'UPC': { required: false, desc: 'Universal Product Code', validate: false },
            'UOM': { required: true, desc: 'Unit of Measure', validateUOM: true },
            'Weight': { required: false, desc: 'Part weight', validate: false },
            'Width': { required: false, desc: 'Part width', validate: false },
            'Height': { required: false, desc: 'Part height', validate: false },
            'Length': { required: false, desc: 'Part length', validate: false },
            'Vendor': { required: false, desc: 'Vendor name', validateVendor: true },
            'Vendor Number': { required: false, desc: 'Vendor part number', validate: false },
            'Vendor Cost': { required: false, desc: 'Cost from vendor', validate: false }
        };

        const MAPPING_STORAGE_KEY = 'solidworksBOMMappings';

        // Debug logging functions
        function debugLog(type, message, data = null) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = 'debug-entry';

            let html = `
                <span class="debug-timestamp">[${timestamp}]</span>
                <span class="debug-type ${type}">[${type.toUpperCase()}]</span>
                <span class="debug-message">${message}</span>
            `;

            if (data) {
                const dataStr = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
                html += `<div class="debug-data">${dataStr}</div>`;
            }

            logEntry.innerHTML = html;

            const debugLogEl = document.getElementById('debugLog');
            debugLogEl.appendChild(logEntry);

            // Auto-scroll to bottom
            debugLogEl.scrollTop = debugLogEl.scrollHeight;

            // Also log to console
            console.log(`[${type.toUpperCase()}]`, message, data || '');
        }

        function clearDebugLog() {
            const debugLogEl = document.getElementById('debugLog');
            debugLogEl.innerHTML = `
                <div class="debug-entry">
                    <span class="debug-timestamp">[${new Date().toLocaleTimeString()}]</span>
                    <span class="debug-type info">[INFO]</span>
                    <span class="debug-message">Debug log cleared</span>
                </div>
            `;
        }

        // Check BOM Import API Headers
        function checkBOMImportHeaders() {
            debugLog('info', 'Checking BOM Import API headers...');

            const headerPayload = {
                "ImportHeaderRq": {
                    "Type": "ImportBillOfMaterials"
                }
            };

            try {
                const headerResponse = runApiRequest('ImportHeaderRq', JSON.stringify(headerPayload));

                if (headerResponse) {
                    const headerResult = typeof headerResponse === 'string' ? JSON.parse(headerResponse) : headerResponse;

                    if (headerResult && headerResult.ImportHeaderRs && headerResult.ImportHeaderRs.Header) {
                        bomImportHeaders = headerResult.ImportHeaderRs.Header;
                        debugLog('success', 'BOM Import Headers retrieved successfully');

                        // Parse the two header rows
                        if (bomImportHeaders.Row && bomImportHeaders.Row.length >= 2) {
                            // First row is BOM-level headers
                            bomLevelHeaders = parseCSVLine(bomImportHeaders.Row[0]);
                            debugLog('info', 'BOM-level headers', bomLevelHeaders);

                            // Second row is Item-level headers
                            itemLevelHeaders = parseCSVLine(bomImportHeaders.Row[1]);
                            debugLog('info', 'Item-level headers', itemLevelHeaders);
                        }

                        showMessage('BOM Import headers retrieved successfully', 'success');
                        return bomImportHeaders;
                    } else {
                        debugLog('warning', 'No headers found in response');
                        showMessage('Could not find headers in API response', 'warning');
                    }
                } else {
                    debugLog('error', 'No response from ImportHeaderRq');
                    showMessage('No response from API', 'danger');
                }
            } catch (e) {
                debugLog('error', 'Error querying BOM import headers', e.toString());
                showMessage('Error querying BOM import headers: ' + e.message, 'danger');
            }

            return null;
        }

        function checkPartImportHeaders() {
            debugLog('info', 'Checking Part Import API headers...');

            const headerPayload = {
                "ImportHeaderRq": {
                    "Type": "ImportPartProductAndVendorPricing"
                }
            };

            try {
                const headerResponse = runApiRequest('ImportHeaderRq', JSON.stringify(headerPayload));

                if (headerResponse) {
                    const headerResult = typeof headerResponse === 'string' ? JSON.parse(headerResponse) : headerResponse;

                    if (headerResult && headerResult.ImportHeaderRs && headerResult.ImportHeaderRs.Header) {
                        const headers = headerResult.ImportHeaderRs.Header;
                        debugLog('success', 'Part Import Headers retrieved successfully');

                        // Parse the header row (PPP import has single header row)
                        if (headers.Row && headers.Row.length > 0) {
                            partImportHeaders = parseCSVLine(headers.Row[0]);
                            debugLog('success', 'Part import headers', partImportHeaders);
                        }

                        showMessage('Part Import headers retrieved successfully', 'success');
                        return headers;
                    } else {
                        debugLog('warning', 'No headers found in response');
                        showMessage('Could not find headers in API response', 'warning');
                    }
                } else {
                    debugLog('error', 'No response from ImportHeaderRq');
                    showMessage('No response from API', 'danger');
                }
            } catch (e) {
                debugLog('error', 'Error querying Part import headers', e.toString());
                showMessage('Error querying Part import headers: ' + e.message, 'danger');
            }

            return null;
        }

        // File handling
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                processFile(file);
            }
        }

        // Drag and drop support
        const uploadSection = document.getElementById('uploadSection');

        uploadSection.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadSection.classList.add('dragover');
        });

        uploadSection.addEventListener('dragleave', () => {
            uploadSection.classList.remove('dragover');
        });

        uploadSection.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadSection.classList.remove('dragover');

            const file = e.dataTransfer.files[0];
            if (file && file.name.endsWith('.csv')) {
                processFile(file);
            } else {
                showMessage('Please drop a CSV file', 'danger');
            }
        });

        // Process uploaded file
        function processFile(file) {
            document.getElementById('fileName').textContent = file.name;

            // Store filename without extension for potential BOM creation
            csvFilename = file.name.replace(/\.csv$/i, '');
            debugLog('info', `CSV filename captured: ${csvFilename}`);

            const reader = new FileReader();
            reader.onload = function(e) {
                const content = e.target.result;
                parseSolidworksCSV(content);
            };
            reader.readAsText(file);
        }

        // Parse Solidworks CSV - ONLY extract headers
        function parseSolidworksCSV(csvContent) {
            debugLog('info', 'Loading Solidworks BOM CSV...');
            showMessage('Loading Solidworks BOM...', 'info');

            try {
                // Store raw content for later processing
                rawCSVContent = csvContent;

                // Parse CSV into rows
                const lines = csvContent.split('\n').map(line => line.trim()).filter(line => line.length > 0);
                debugLog('info', `Total lines in CSV: ${lines.length}`);

                if (lines.length < 2) {
                    debugLog('error', 'CSV file is empty or has no data rows');
                    showMessage('CSV file is empty or invalid', 'danger');
                    return;
                }

                // Parse header row ONLY
                const headers = parseCSVLine(lines[0]);
                solidworksColumns = headers;
                debugLog('success', `Detected ${headers.length} columns in Solidworks CSV`, headers);

                showMessage(`âœ“ CSV loaded with ${headers.length} columns. Processing BOM structure...`, 'info');

                // Show field mapping button
                document.getElementById('mappingButtonSection').classList.remove('hidden');

                // Check if mappings already exist (e.g., from loaded configuration)
                if (fieldMappings && Object.keys(fieldMappings).length > 0) {
                    // Validate existing mappings against current CSV headers
                    const invalidMappings = Object.values(fieldMappings).filter(
                        col => col && !headers.includes(col)
                    );

                    if (invalidMappings.length === 0) {
                        // Existing mappings are valid - use them
                        debugLog('success', 'Using pre-loaded field mappings (valid for current CSV)');
                        applyMappingsToUI();

                        // Auto-process BOM
                        if (rawCSVContent) {
                            debugLog('info', 'Auto-processing BOM with pre-loaded mappings');
                            setTimeout(() => processBOMData(), 500);
                        }
                    } else {
                        // Mappings are invalid - warn user
                        debugLog('warning', `Pre-loaded mappings have ${invalidMappings.length} invalid columns - need to remap`);
                        showMessage('Loaded mappings don\'t match CSV columns - please configure field mappings', 'warning');
                        fieldMappings = {}; // Clear invalid mappings
                        loadSavedMappings(); // Try localStorage as fallback
                    }
                } else {
                    // No pre-loaded mappings - try to load saved mappings from localStorage
                    loadSavedMappings();
                }

            } catch (error) {
                debugLog('error', 'Error loading Solidworks CSV', error.toString());
                showMessage('Error loading CSV: ' + error.message, 'danger');
            }
        }

        // Process BOM Data AFTER mappings are configured
        function processBOMData() {
            debugLog('info', 'Processing BOM data with configured mappings...');
            showMessage('Processing BOM data...', 'info');

            try {
                if (!rawCSVContent) {
                    showMessage('No CSV file loaded', 'danger');
                    return;
                }

                // Parse CSV into rows
                const lines = rawCSVContent.split('\n').map(line => line.trim()).filter(line => line.length > 0);

                // Get mapped column names from the new simplified structure
                const levelCol = fieldMappings['Level'];
                const partCol = fieldMappings['Number'];
                const descCol = fieldMappings['Description'];
                const detailsCol = fieldMappings['Details'];
                const revisionCol = fieldMappings['Revision'];
                const standardCostCol = fieldMappings['Standard Cost'];
                const qtyCol = fieldMappings['Quantity'];
                const upcCol = fieldMappings['UPC'];
                const uomCol = fieldMappings['UOM'];
                const weightCol = fieldMappings['Weight'];
                const widthCol = fieldMappings['Width'];
                const heightCol = fieldMappings['Height'];
                const lengthCol = fieldMappings['Length'];
                const vendorCol = fieldMappings['Vendor'];
                const vendorNumberCol = fieldMappings['Vendor Number'];
                const vendorCostCol = fieldMappings['Vendor Cost'];

                debugLog('info', 'Using mapped columns', fieldMappings);

                // Find column indices
                const levelIndex = levelCol ? solidworksColumns.indexOf(levelCol) : -1;
                const partNumIndex = partCol ? solidworksColumns.indexOf(partCol) : -1;
                const descIndex = descCol ? solidworksColumns.indexOf(descCol) : -1;
                const detailsIndex = detailsCol ? solidworksColumns.indexOf(detailsCol) : -1;
                const revisionIndex = revisionCol ? solidworksColumns.indexOf(revisionCol) : -1;
                const costIndex = standardCostCol ? solidworksColumns.indexOf(standardCostCol) : -1;
                const qtyIndex = qtyCol ? solidworksColumns.indexOf(qtyCol) : -1;
                const upcIndex = upcCol ? solidworksColumns.indexOf(upcCol) : -1;
                const uomIndex = uomCol ? solidworksColumns.indexOf(uomCol) : -1;
                const weightIndex = weightCol ? solidworksColumns.indexOf(weightCol) : -1;
                const widthIndex = widthCol ? solidworksColumns.indexOf(widthCol) : -1;
                const heightIndex = heightCol ? solidworksColumns.indexOf(heightCol) : -1;
                const lengthIndex = lengthCol ? solidworksColumns.indexOf(lengthCol) : -1;
                const vendorIndex = vendorCol ? solidworksColumns.indexOf(vendorCol) : -1;
                const vendorNumIndex = vendorNumberCol ? solidworksColumns.indexOf(vendorNumberCol) : -1;
                const vendorCostIndex = vendorCostCol ? solidworksColumns.indexOf(vendorCostCol) : -1;

                // Parse data rows
                const bomItems = [];
                for (let i = 1; i < lines.length; i++) {
                    const row = parseCSVLine(lines[i]);
                    if (row.length > 0) {
                        const item = {
                            level: levelIndex >= 0 ? row[levelIndex] : String(i),
                            partNumber: partNumIndex >= 0 ? row[partNumIndex] : '',
                            description: descIndex >= 0 ? row[descIndex] : '',
                            details: detailsIndex >= 0 ? row[detailsIndex] : '',
                            revision: revisionIndex >= 0 ? row[revisionIndex] : '',
                            standardCost: costIndex >= 0 ? row[costIndex] : '',
                            quantity: qtyIndex >= 0 ? row[qtyIndex] : '1',
                            upc: upcIndex >= 0 ? row[upcIndex] : '',
                            uom: uomIndex >= 0 ? row[uomIndex] : 'ea',
                            weight: weightIndex >= 0 ? row[weightIndex] : '',
                            width: widthIndex >= 0 ? row[widthIndex] : '',
                            height: heightIndex >= 0 ? row[heightIndex] : '',
                            length: lengthIndex >= 0 ? row[lengthIndex] : '',
                            vendor: vendorIndex >= 0 ? row[vendorIndex] : '',
                            vendorNumber: vendorNumIndex >= 0 ? row[vendorNumIndex] : '',
                            vendorCost: vendorCostIndex >= 0 ? row[vendorCostIndex] : '',
                            lineNumber: i + 1,
                            rawData: row // Store full row for later use
                        };
                        bomItems.push(item);
                    }
                }

                debugLog('success', `Parsed ${bomItems.length} BOM items`);

                // Analyze BOM structure
                analyzeBOMStructure(bomItems);

                solidworksData = bomItems;
                showMessage(`Successfully processed ${bomItems.length} items from Solidworks BOM`, 'success');

            } catch (error) {
                debugLog('error', 'Error processing BOM data', error.toString());
                showMessage('Error processing BOM data: ' + error.message, 'danger');
            }
        }

        // Simple CSV line parser (handles quoted fields)
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];

                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }

            result.push(current.trim());
            return result;
        }

        // Analyze BOM structure and extract parts/BOMs
        function analyzeBOMStructure(bomItems) {
            debugLog('info', 'Analyzing BOM structure...');

            const uniqueParts = new Map();
            const bomStructure = [];
            const bomsByLevel = new Map(); // Track BOMs by their level

            // First pass: identify all unique parts and potential BOMs
            for (let i = 0; i < bomItems.length; i++) {
                const item = bomItems[i];
                const levelParts = item.level.split('.');
                const depth = levelParts.length;

                // Track unique parts - preserve ALL fields from the item
                if (item.partNumber && !uniqueParts.has(item.partNumber)) {
                    uniqueParts.set(item.partNumber, {
                        partNumber: item.partNumber,
                        description: item.description,
                        details: item.details,
                        type: item.type,
                        uom: item.uom,
                        upc: item.upc,
                        revision: item.revision,
                        standardCost: item.standardCost,
                        weight: item.weight,
                        width: item.width,
                        height: item.height,
                        length: item.length,
                        vendor: item.vendor,
                        vendorNumber: item.vendorNumber,
                        vendorCost: item.vendorCost
                    });
                }

                // Check if this item has children (is a BOM parent)
                const hasChildren = i < bomItems.length - 1 &&
                    bomItems[i + 1].level.startsWith(item.level + '.');

                if (hasChildren) {
                    // This is a BOM/assembly
                    const bom = {
                        level: item.level,
                        partNumber: item.partNumber,
                        description: item.description,
                        uom: item.uom || defaultValues.uom, // Include UOM from item or default
                        items: [],
                        isStage: depth > 1 // Sub-assemblies are stages
                    };
                    bomsByLevel.set(item.level, bom);
                    bomStructure.push(bom);
                }
            }

            // Second pass: assign items to their parent BOMs
            for (const item of bomItems) {
                const levelParts = item.level.split('.');

                // Find the parent BOM (one level up)
                if (levelParts.length > 1) {
                    const parentLevel = levelParts.slice(0, -1).join('.');
                    const parentBOM = bomsByLevel.get(parentLevel);

                    if (parentBOM) {
                        // This item belongs to the parent BOM
                        parentBOM.items.push(item);
                    }
                }
            }

            // Create wrapper BOM from filename if enabled
            if (config.createBOMFromFilename && csvFilename) {
                debugLog('info', `Creating wrapper BOM from filename: ${csvFilename}`);

                // Find all top-level BOMs (level without dots)
                const topLevelBOMs = bomStructure.filter(bom => !bom.level.includes('.'));

                if (topLevelBOMs.length > 0) {
                    // Create wrapper BOM
                    const wrapperBOM = {
                        level: '0',
                        partNumber: csvFilename,
                        description: csvFilename,
                        uom: defaultValues.uom,
                        items: topLevelBOMs.map(bom => ({
                            level: bom.level,
                            partNumber: bom.partNumber,
                            description: bom.description,
                            uom: bom.uom,
                            quantity: '1', // Each top-level BOM is qty 1 in the wrapper
                            type: 'Raw Good' // Top-level BOMs are raw goods in the wrapper BOM
                        })),
                        isStage: false // The wrapper itself is not a stage
                    };

                    bomsByLevel.set('0', wrapperBOM);
                    bomStructure.push(wrapperBOM);

                    // Add wrapper's finished good part to uniqueParts if not already present
                    if (!uniqueParts.has(csvFilename)) {
                        uniqueParts.set(csvFilename, {
                            partNumber: csvFilename,
                            description: csvFilename,
                            type: config.createFinishedGoodsAsProducts ? 'Product' : 'Inventory',
                            uom: defaultValues.uom
                        });
                    }

                    debugLog('success', `Created wrapper BOM "${csvFilename}" containing ${topLevelBOMs.length} top-level assemblies`);
                } else {
                    debugLog('warning', 'No top-level BOMs found to wrap');
                }
            }

            // Filter out parts that already exist in Fishbowl (if validation enabled)
            let allParts = Array.from(uniqueParts.values());

            // Sort BOMs by depth (deepest first) so stages are created before their parent BOMs
            bomStructure.sort((a, b) => {
                const aDepth = a.level.split('.').length;
                const bDepth = b.level.split('.').length;
                return bDepth - aDepth; // Descending order (deepest first)
            });

            bomsToCreate = bomStructure;
            debugLog('info', `BOMs sorted by depth for bottom-up creation (deepest first)`);
            if (bomsToCreate.length > 0) {
                debugLog('info', `BOM creation order example: ${bomsToCreate.slice(0, 5).map(b => `${b.level} (${b.partNumber})`).join(', ')}`);
            }

            // Validate UOMs and apply defaults for parts AND BOM items
            const invalidUOMs = [];
            const missingUOMs = [];

            // Validate part UOMs
            allParts.forEach(part => {
                // Apply default UOM if missing or empty
                if (!part.uom || part.uom.trim() === '') {
                    part.uom = defaultValues.uom;
                    missingUOMs.push(part.partNumber);
                }

                // Validate UOM against Fishbowl UOMs (if loaded)
                if (fishbowlData.uoms.length > 0 && !fishbowlData.uoms.includes(part.uom)) {
                    invalidUOMs.push({ partNumber: part.partNumber, uom: part.uom });
                }
            });

            // Validate BOM item UOMs
            bomsToCreate.forEach(bom => {
                // Validate BOM's own UOM
                if (!bom.uom || bom.uom.trim() === '') {
                    bom.uom = defaultValues.uom;
                }
                if (fishbowlData.uoms.length > 0 && !fishbowlData.uoms.includes(bom.uom)) {
                    invalidUOMs.push({ partNumber: `${bom.partNumber} (BOM)`, uom: bom.uom });
                }

                // Validate item UOMs
                bom.items.forEach(item => {
                    if (!item.uom || item.uom.trim() === '') {
                        item.uom = defaultValues.uom;
                        missingUOMs.push(`${item.partNumber} (in BOM ${bom.partNumber})`);
                    }
                    if (fishbowlData.uoms.length > 0 && !fishbowlData.uoms.includes(item.uom)) {
                        invalidUOMs.push({ partNumber: `${item.partNumber} (in BOM ${bom.partNumber})`, uom: item.uom });
                    }
                });
            });

            if (missingUOMs.length > 0) {
                debugLog('info', `Applied default UOM "${defaultValues.uom}" to ${missingUOMs.length} items without UOM`);
            }

            if (invalidUOMs.length > 0) {
                debugLog('warning', `Found ${invalidUOMs.length} items with invalid UOMs (not in Fishbowl)`);
                const uniqueInvalidUOMs = [...new Set(invalidUOMs.map(item => item.uom))];
                showMessage(`âš ï¸ Warning: ${invalidUOMs.length} items have invalid UOMs (${uniqueInvalidUOMs.join(', ')}). Create these UOMs in Fishbowl first.`, 'warning');
            }

            if (config.validatePartsExist && fishbowlData.existingParts.length > 0) {
                const existingPartsSet = new Set(fishbowlData.existingParts);
                const newParts = [];
                const existingParts = [];

                allParts.forEach(part => {
                    if (existingPartsSet.has(part.partNumber)) {
                        existingParts.push(part);
                    } else {
                        newParts.push(part);
                    }
                });

                partsToCreate = newParts;

                debugLog('success', `Parts Analysis: ${allParts.length} total in file, ${existingParts.length} already exist, ${newParts.length} new to create`);
                if (existingParts.length > 0) {
                    showMessage(`Parts: ${allParts.length} total, ${existingParts.length} exist, ${newParts.length} new to create`, 'info');
                }
            } else {
                partsToCreate = allParts;
                debugLog('success', `Parts Analysis: ${partsToCreate.length} total in file, validation ${config.validatePartsExist ? 'pending' : 'disabled'}`);
            }

            debugLog('success', `BOMs Analysis: ${bomsToCreate.length} BOMs to create/update (will override if exist)`);

            updateStats({
                total: bomItems.length,
                parts: partsToCreate.length,
                newParts: partsToCreate.length, // Will be refined later
                boms: bomsToCreate.length,
                warnings: 0,
                errors: 0
            });

            // Show parts section and BOMs section
            displayPartsToCreate();
            displayBOMsToCreate();

            // Show field mapping button
            document.getElementById('mappingButtonSection').classList.remove('hidden');
        }

        // Get part cost from CSV data or Fishbowl query
        function getPartCost(partNumber, csvCost) {
            // First try CSV vendor cost
            if (csvCost && csvCost.trim() !== '' && !isNaN(parseFloat(csvCost))) {
                return parseFloat(csvCost);
            }

            // Fallback to Fishbowl partcost.avgcost query
            if (typeof runQuery === 'function') {
                try {
                    const query = `SELECT pc.avgcost
                                   FROM partcost pc
                                   JOIN part p ON p.id = pc.partid
                                   WHERE p.num = '${partNumber.replace(/'/g, "''")}'`;
                    const result = runQuery(query);
                    if (result) {
                        const data = JSON.parse(result);
                        const cost = Array.isArray(data) ? data[0]?.avgcost : data?.avgcost;
                        if (cost && !isNaN(parseFloat(cost))) {
                            return parseFloat(cost);
                        }
                    }
                } catch (error) {
                    // Silently fail - cost will be 0
                }
            }

            return 0;
        }

        // Calculate BOM total cost recursively
        function calculateBOMCost(bom, costCache = new Map()) {
            let total = 0;

            // Calculate cost for all items in this BOM
            for (const item of bom.items) {
                const qty = parseFloat(item.quantity) || 1;

                // Check if this item is a sub-BOM
                const subBOM = bomsToCreate.find(b => b.level === item.level);

                if (subBOM) {
                    // Recursive: get the sub-BOM's total cost
                    const subCost = costCache.has(subBOM.level)
                        ? costCache.get(subBOM.level)
                        : calculateBOMCost(subBOM, costCache);
                    costCache.set(subBOM.level, subCost);
                    total += subCost * qty;
                } else {
                    // Regular part: get unit cost and multiply by quantity
                    const unitCost = getPartCost(item.partNumber, item.vendorCost);
                    total += unitCost * qty;
                }
            }

            return total;
        }

        // Toggle BOM row expansion
        function toggleBOMRow(bomId) {
            const detailRows = document.querySelectorAll(`.bom-detail-${bomId}`);
            const chevron = document.getElementById(`chevron-${bomId}`);
            const isExpanded = detailRows[0]?.style.display !== 'none';

            detailRows.forEach(row => {
                row.style.display = isExpanded ? 'none' : 'table-row';
            });

            if (chevron) {
                chevron.style.transform = isExpanded ? 'rotate(-90deg)' : 'rotate(0deg)';
            }
        }

        // Build BOM tree rows recursively
        function buildBOMTreeRows(bom, depth = 0, costCache = new Map(), allRows = []) {
            const bomId = bom.level.replace(/\./g, '-');
            const indent = depth * 20;
            const bomCost = costCache.has(bom.level)
                ? costCache.get(bom.level)
                : calculateBOMCost(bom, costCache);
            costCache.set(bom.level, bomCost);

            const bgColor = depth === 0 ? '#e3f2fd' : (depth === 1 ? '#e9ecef' : '#f5f5f5');

            // BOM quantity defaults to 1 (or could be retrieved from parent if needed)
            const bomQty = 1;
            const bomUnitCost = bomCost; // Cost per unit of this BOM
            const bomTotalCost = bomUnitCost * bomQty;

            const typeLabel = bom.isStage ? '<span class="badge bg-info" style="font-size: 7px;">Stage</span>' : '<span class="badge bg-primary" style="font-size: 7px;">FG</span>';

            // BOM header row (clickable to expand/collapse) - matches detail row columns
            allRows.push(`
                <tr class="bom-header-row" style="background-color: ${bgColor}; cursor: pointer; font-weight: 500;" onclick="toggleBOMRow('${bomId}')">
                    <td style="padding: 6px 8px; padding-left: ${indent + 8}px;">
                        <i id="chevron-${bomId}" class="bi bi-chevron-right" style="transition: transform 0.2s; display: inline-block;"></i>
                        <strong style="margin-left: 8px;">${bom.level}</strong>
                    </td>
                    <td style="padding: 6px 8px;">${bom.partNumber}</td>
                    <td style="padding: 6px 8px;">${bom.description || bom.partNumber} ${typeLabel}</td>
                    <td style="padding: 6px 8px; text-align: right;">${bomQty}</td>
                    <td style="padding: 6px 8px;">${bom.uom || 'ea'}</td>
                    <td style="padding: 6px 8px; text-align: right; font-weight: 600;">$${bomUnitCost.toFixed(2)}</td>
                    <td style="padding: 6px 8px; text-align: right; font-weight: 600; color: #198754;">$${bomTotalCost.toFixed(2)}</td>
                </tr>
            `);

            // Component rows - iterate through items and inline sub-BOMs
            for (const item of bom.items) {
                // Special handling for wrapper BOM (level 0) - directly recurse into top-level BOMs
                if (bom.level === '0') {
                    // Find the actual BOM object for this top-level BOM
                    const topLevelBOM = bomsToCreate.find(b =>
                        b.partNumber === item.partNumber && b.level === item.level
                    );

                    if (topLevelBOM) {
                        // Recursively render this top-level BOM with wrapper's detail class
                        const nestedRows = [];
                        buildBOMTreeRows(topLevelBOM, depth + 1, costCache, nestedRows);

                        // Add all rows with parent's detail class
                        nestedRows.forEach(row => {
                            if (row.includes('class="')) {
                                allRows.push(row.replace('class="', `class="bom-detail-${bomId} `));
                            } else {
                                allRows.push(row.replace('<tr ', `<tr class="bom-detail-${bomId}" `));
                            }
                        });
                        continue; // Skip the regular item rendering below
                    }
                }

                const subBOM = bomsToCreate.find(b => b.level === item.level);

                if (subBOM) {
                    // This item is a sub-BOM - render it inline as a nested BOM with its own expand/collapse
                    // Add it to the parent's detail class so it shows/hides with parent
                    const subBomId = subBOM.level.replace(/\./g, '-');
                    const subIndent = (depth + 1) * 20;
                    const subBomCost = costCache.has(subBOM.level)
                        ? costCache.get(subBOM.level)
                        : calculateBOMCost(subBOM, costCache);
                    costCache.set(subBOM.level, subBomCost);

                    const qty = parseFloat(item.quantity) || 1;
                    const extended = subBomCost * qty;
                    const subBgColor = depth === 0 ? '#e9ecef' : '#f5f5f5';

                    // Display badge based on item type (Raw Good vs Stage)
                    const itemType = item.type || 'Stage';
                    const subTypeLabel = itemType === 'Raw Good'
                        ? '<span class="badge bg-success" style="font-size: 7px;">Raw Good</span>'
                        : '<span class="badge bg-info" style="font-size: 7px;">Stage</span>';

                    // Sub-BOM header row (part of parent's detail)
                    allRows.push(`
                        <tr class="bom-detail-${bomId} bom-header-row" style="display: none; background-color: ${subBgColor}; cursor: pointer; font-weight: 500;" onclick="toggleBOMRow('${subBomId}')">
                            <td style="padding: 6px 8px; padding-left: ${subIndent + 8}px;">
                                <i id="chevron-${subBomId}" class="bi bi-chevron-right" style="transition: transform 0.2s; display: inline-block;"></i>
                                <strong style="margin-left: 8px;">${subBOM.level}</strong>
                            </td>
                            <td style="padding: 6px 8px;">${subBOM.partNumber}</td>
                            <td style="padding: 6px 8px;">${subBOM.description || subBOM.partNumber} ${subTypeLabel}</td>
                            <td style="padding: 6px 8px; text-align: right;">${qty}</td>
                            <td style="padding: 6px 8px;">${subBOM.uom || 'ea'}</td>
                            <td style="padding: 6px 8px; text-align: right; font-weight: 600;">$${subBomCost.toFixed(2)}</td>
                            <td style="padding: 6px 8px; text-align: right; font-weight: 600; color: #198754;">$${extended.toFixed(2)}</td>
                        </tr>
                    `);

                    // Recursively add sub-BOM's components
                    for (const subItem of subBOM.items) {
                        const nestedSubBOM = bomsToCreate.find(b => b.level === subItem.level);

                        if (nestedSubBOM) {
                            // Another level of nesting - recursively call buildBOMTreeRows
                            const nestedRows = [];
                            buildBOMTreeRows(nestedSubBOM, depth + 2, costCache, nestedRows);
                            // Add nested rows with both parent detail classes
                            nestedRows.forEach(row => {
                                if (row.includes('class="')) {
                                    allRows.push(row.replace('class="', `class="bom-detail-${bomId} bom-detail-${subBomId} `));
                                } else {
                                    allRows.push(row.replace('<tr ', `<tr class="bom-detail-${bomId} bom-detail-${subBomId}" `));
                                }
                            });
                        } else {
                            // Regular component of sub-BOM
                            const subItemQty = parseFloat(subItem.quantity) || 1;
                            const subItemUnitCost = getPartCost(subItem.partNumber, subItem.vendorCost);
                            const subItemExtended = subItemUnitCost * subItemQty;

                            allRows.push(`
                                <tr class="bom-detail-${bomId} bom-detail-${subBomId}" style="display: none; background-color: white;">
                                    <td style="padding: 4px 8px; padding-left: ${subIndent + 40}px; font-size: 10pt;">${subItem.level}</td>
                                    <td style="padding: 4px 8px; font-size: 10pt;">${subItem.partNumber}</td>
                                    <td style="padding: 4px 8px; font-size: 10pt;">${subItem.description || ''}</td>
                                    <td style="padding: 4px 8px; text-align: right; font-size: 10pt;">${subItemQty}</td>
                                    <td style="padding: 4px 8px; font-size: 10pt;">${subItem.uom || 'ea'}</td>
                                    <td style="padding: 4px 8px; text-align: right; font-size: 10pt;">$${subItemUnitCost.toFixed(2)}</td>
                                    <td style="padding: 4px 8px; text-align: right; font-size: 10pt;">$${subItemExtended.toFixed(2)}</td>
                                </tr>
                            `);
                        }
                    }

                    // Sub-BOM subtotal row
                    allRows.push(`
                        <tr class="bom-detail-${bomId} bom-detail-${subBomId}" style="display: none; background-color: #e8f4f8; border-top: 1px solid #b3d9e8;">
                            <td colspan="6" style="padding: 6px 8px; padding-left: ${subIndent + 40}px; font-size: 9.5pt; font-weight: 500; text-align: right;">
                                BOM ${subBOM.level} Subtotal:
                            </td>
                            <td style="padding: 6px 8px; text-align: right; font-size: 10pt; font-weight: 600; color: #0c5460;">
                                $${subBomCost.toFixed(2)}
                            </td>
                        </tr>
                    `);
                } else {
                    // Regular component - render as detail row
                    const qty = parseFloat(item.quantity) || 1;
                    const unitCost = getPartCost(item.partNumber, item.vendorCost);
                    const extended = unitCost * qty;

                    allRows.push(`
                        <tr class="bom-detail-${bomId}" style="display: none; background-color: white;">
                            <td style="padding: 4px 8px; padding-left: ${indent + 40}px; font-size: 10pt;">${item.level}</td>
                            <td style="padding: 4px 8px; font-size: 10pt;">${item.partNumber}</td>
                            <td style="padding: 4px 8px; font-size: 10pt;">${item.description || ''}</td>
                            <td style="padding: 4px 8px; text-align: right; font-size: 10pt;">${qty}</td>
                            <td style="padding: 4px 8px; font-size: 10pt;">${item.uom || 'ea'}</td>
                            <td style="padding: 4px 8px; text-align: right; font-size: 10pt;">$${unitCost.toFixed(2)}</td>
                            <td style="padding: 4px 8px; text-align: right; font-size: 10pt;">$${extended.toFixed(2)}</td>
                        </tr>
                    `);
                }
            }

            // Add subtotal row showing breakdown
            allRows.push(`
                <tr class="bom-detail-${bomId}" style="display: none; background-color: #e8f4f8; border-top: 1px solid #b3d9e8;">
                    <td colspan="6" style="padding: 6px 8px; padding-left: ${indent + 40}px; font-size: 9.5pt; font-weight: 500; text-align: right;">
                        BOM ${bom.level} Subtotal:
                    </td>
                    <td style="padding: 6px 8px; text-align: right; font-size: 10pt; font-weight: 600; color: #0c5460;">
                        $${bomCost.toFixed(2)}
                    </td>
                </tr>
            `);

            return allRows;
        }

        // Display BOMs as hierarchical tree table
        function displayBOMsToCreate() {
            // Find the container - use the results-table-container div
            const tableContainer = document.querySelector('#bomsContent .results-table-container');
            if (!tableContainer) {
                debugLog('error', 'Could not find BOM table container');
                return;
            }

            // Calculate all costs first
            const costCache = new Map();
            let grandTotal = 0;

            // Check if wrapper BOM exists (level "0") - if so, only count it as top-level
            const hasWrapperBOM = bomsToCreate.some(bom => bom.level === '0');
            const realTopLevelBOMs = hasWrapperBOM
                ? bomsToCreate.filter(bom => bom.level === '0')
                : bomsToCreate.filter(bom => !bom.level.includes('.'));

            realTopLevelBOMs.forEach(bom => {
                const cost = calculateBOMCost(bom, costCache);
                grandTotal += cost;
            });

            // Build table structure
            let html = `
                <table class="table table-sm table-hover mb-0" style="font-size: 10.5pt;">
                    <thead style="background-color: #e3f2fd; position: sticky; top: 0; z-index: 10;">
                        <tr>
                            <th style="padding: 8px; width: 100px;">Level</th>
                            <th style="padding: 8px; width: 150px;">Part Number</th>
                            <th style="padding: 8px;">Description</th>
                            <th style="padding: 8px; width: 60px; text-align: right;">Qty</th>
                            <th style="padding: 8px; width: 60px;">UOM</th>
                            <th style="padding: 8px; width: 100px; text-align: right;">Unit Cost</th>
                            <th style="padding: 8px; width: 100px; text-align: right;">Total Cost</th>
                        </tr>
                    </thead>
                    <tbody>`;

            // Build hierarchical rows - only for top-level BOMs (sub-BOMs are inlined)
            const allRows = [];
            const topLevelBOMs = realTopLevelBOMs;

            // Build each top-level BOM (sub-BOMs are nested inline within buildBOMTreeRows)
            topLevelBOMs.forEach(bom => buildBOMTreeRows(bom, 0, costCache, allRows));

            html += allRows.join('');

            // Add grand total row
            html += `
                        <tr style="background-color: #d1ecf1; font-weight: bold; border-top: 2px solid #0c5460;">
                            <td colspan="6" style="padding: 10px 8px; text-align: right; font-size: 11pt;">TOTAL ESTIMATED COST:</td>
                            <td style="padding: 10px 8px; text-align: right; font-size: 12pt; color: #0c5460;">$${grandTotal.toFixed(2)}</td>
                        </tr>
                    </tbody>
                </table>`;

            // Replace content
            tableContainer.innerHTML = html;

            // Update count in accordion header
            document.getElementById('bomsCount').textContent = bomsToCreate.length;

            if (bomsToCreate.length > 0) {
                document.getElementById('bomsSection').classList.remove('hidden');
            }
        }

        // Load Fishbowl data (UOMs, Vendors, Tax Codes, etc.)
        function loadFishbowlData() {
            debugLog('info', 'Loading Fishbowl data (UOMs, Vendors, Tax Codes)...');

            try {
                // Load UOMs
                debugLog('info', 'Loading UOMs...');
                const uomQuery = `SELECT code, name, uomtype FROM uom WHERE activeflag = 1 ORDER BY code`;
                const uomResult = runQuery(uomQuery);

                if (uomResult) {
                    let uoms = JSON.parse(uomResult);
                    if (uoms && !Array.isArray(uoms)) uoms = [uoms];
                    fishbowlData.uoms = uoms.map(u => u.code);
                    fishbowlData.uomDetails = uoms;
                    debugLog('success', `Loaded ${fishbowlData.uoms.length} UOMs`);
                } else {
                    debugLog('warning', 'No UOMs loaded from Fishbowl');
                    fishbowlData.uoms = [];
                    fishbowlData.uomDetails = [];
                }

                // Load Vendors
                debugLog('info', 'Loading Vendors...');
                const vendorQuery = `SELECT name FROM vendor WHERE activeflag = 1 ORDER BY name`;
                const vendorResult = runQuery(vendorQuery);

                if (vendorResult) {
                    let vendors = JSON.parse(vendorResult);
                    if (vendors && !Array.isArray(vendors)) vendors = [vendors];
                    fishbowlData.vendors = vendors.map(v => v.name);
                    debugLog('success', `Loaded ${fishbowlData.vendors.length} Vendors`);
                } else {
                    debugLog('warning', 'No Vendors loaded from Fishbowl');
                    fishbowlData.vendors = [];
                }

                // Load Tax Codes
                debugLog('info', 'Loading Tax Codes...');
                const taxQuery = `SELECT code, name FROM taxrate WHERE activeflag = 1 ORDER BY code`;
                const taxResult = runQuery(taxQuery);

                if (taxResult) {
                    let taxCodes = JSON.parse(taxResult);
                    if (taxCodes && !Array.isArray(taxCodes)) taxCodes = [taxCodes];
                    fishbowlData.taxCodes = taxCodes.map(t => t.code);
                    fishbowlData.taxCodeDetails = taxCodes; // Store full details
                    debugLog('success', `Loaded ${fishbowlData.taxCodes.length} Tax Codes`);
                } else {
                    debugLog('warning', 'No Tax Codes loaded from Fishbowl');
                    fishbowlData.taxCodes = [];
                    fishbowlData.taxCodeDetails = [];
                }

                // Load Existing Parts (for validation)
                debugLog('info', 'Loading existing parts from Fishbowl...');
                const partsQuery = `SELECT num FROM part WHERE activeflag = 1`;
                const partsResult = runQuery(partsQuery);

                if (partsResult) {
                    let parts = JSON.parse(partsResult);
                    if (parts && !Array.isArray(parts)) parts = [parts];
                    fishbowlData.existingParts = parts.map(p => p.num);
                    debugLog('success', `Loaded ${fishbowlData.existingParts.length} existing parts from Fishbowl`);
                } else {
                    debugLog('warning', 'No existing parts loaded from Fishbowl');
                    fishbowlData.existingParts = [];
                }

                // Populate settings dropdowns if they exist
                populateSettingsDropdowns();

                return true;

            } catch (error) {
                debugLog('error', 'Error loading Fishbowl data', error.toString());
                showMessage('Warning: Could not load data from Fishbowl', 'warning');
                return false;
            }
        }

        // Field Mapping Functions
        function openFieldMappingDialog() {
            debugLog('info', 'User requested to open field mapping dialog');

            // Load Fishbowl data if not already loaded
            if (fishbowlData.uoms.length === 0 || fishbowlData.vendors.length === 0) {
                debugLog('info', 'Fishbowl data not loaded yet - loading...');
                showMessage('Loading UOMs and Vendors from Fishbowl...', 'info');
                loadFishbowlData();
            }

            // Populate the mapping UI
            populateFieldMappings();

            // Show the modal
            const modalElement = document.getElementById('fieldMappingModal');
            const modal = new bootstrap.Modal(modalElement);
            modal.show();
        }

        function populateFieldMappings() {
            debugLog('info', 'Populating field mapping UI with simplified BOM fields');
            debugLog('info', `Solidworks columns count: ${solidworksColumns.length}`, solidworksColumns);

            if (solidworksColumns.length === 0) {
                debugLog('error', 'Solidworks columns are empty!');
                showMessage('No Solidworks columns detected. Please upload a valid CSV file.', 'danger');
                return;
            }

            // Clear existing mappings
            const bomMappingsDiv = document.getElementById('bomLevelMappings');
            const itemMappingsDiv = document.getElementById('itemLevelMappings');
            bomMappingsDiv.innerHTML = '';
            itemMappingsDiv.innerHTML = '';

            // Create mapping rows for each BOM field
            let rowCount = 0;
            Object.keys(bomFieldDefinitions).forEach((field, index) => {
                const fieldDef = bomFieldDefinitions[field];
                const isRequired = fieldDef.required;
                const row = createMappingRow(field, isRequired, 'bom', index, fieldDef.desc);
                bomMappingsDiv.appendChild(row);
                rowCount++;
            });

            debugLog('success', `Created ${rowCount} BOM field mapping rows`);
        }

        function createMappingRow(fishbowlField, isRequired, level, index, description) {
            const row = document.createElement('div');
            row.className = 'mapping-row';

            const labelDiv = document.createElement('div');
            labelDiv.className = 'mapping-label';

            const labelText = document.createElement('div');
            if (isRequired) {
                labelText.classList.add('required-field');
            }
            labelText.textContent = fishbowlField;
            labelDiv.appendChild(labelText);

            if (description) {
                const descText = document.createElement('small');
                descText.className = 'text-muted d-block';
                descText.style.fontSize = '11px';
                descText.style.fontWeight = 'normal';
                descText.textContent = description;
                labelDiv.appendChild(descText);
            }

            const arrow = document.createElement('div');
            arrow.className = 'mapping-arrow';
            arrow.innerHTML = '<i class="bi bi-arrow-left"></i>';

            const select = document.createElement('select');
            select.className = 'mapping-select form-select';
            select.id = `mapping-${level}-${index}`;
            select.dataset.field = fishbowlField;
            select.dataset.level = level;
            select.dataset.required = isRequired;

            // Add "None" option
            const noneOption = document.createElement('option');
            noneOption.value = '';
            noneOption.textContent = '-- None --';
            select.appendChild(noneOption);

            // Add Solidworks column options
            solidworksColumns.forEach(col => {
                const option = document.createElement('option');
                option.value = col;
                option.textContent = col;

                // Check if we have a loaded mapping for this field (takes priority)
                if (fieldMappings[fishbowlField] && fieldMappings[fishbowlField] === col) {
                    option.selected = true;
                }
                // Otherwise, try to auto-match based on field name similarity
                else if (!fieldMappings[fishbowlField] && autoMatchField(fishbowlField, col)) {
                    option.selected = true;
                }

                select.appendChild(option);
            });

            row.appendChild(labelDiv);
            row.appendChild(arrow);
            row.appendChild(select);

            return row;
        }

        function autoMatchField(fishbowlField, solidworksColumn) {
            const fb = fishbowlField.toLowerCase();
            const sw = solidworksColumn.toLowerCase();

            // Direct matches
            if (fb === sw) return true;

            // Common mappings
            const mappings = {
                'level': ['level', 'item', 'line'],
                'number': ['p/n', 'part', 'number', 'part number', 'partnumber', 'part num', 'pn', 'item'],
                'description': ['description', 'desc', 'name'],
                'details': ['details', 'notes', 'comments'],
                'revision': ['revision', 'rev', 'version'],
                'standard cost': ['cost', 'standard cost', 'unit cost'],
                'quantity': ['qty', 'quantity', 'amount', 'qnty'],
                'upc': ['upc', 'barcode', 'ean'],
                'uom': ['uom', 'unit', 'units', 'u/m'],
                'weight': ['weight', 'wt', 'mass'],
                'width': ['width', 'w'],
                'height': ['height', 'h'],
                'length': ['length', 'l', 'len'],
                'vendor': ['vendor', 'supplier', 'mfg', 'manufacturer'],
                'vendor number': ['vendor number', 'vendor p/n', 'vendor part', 'mfg part'],
                'vendor cost': ['vendor cost', 'purchase cost', 'buy cost']
            };

            if (mappings[fb]) {
                return mappings[fb].some(match => sw.includes(match));
            }

            return false;
        }

        function saveMappings() {
            debugLog('info', 'Saving field mappings...');

            const mappings = {};

            // Collect all field mappings
            const allSelects = document.querySelectorAll('select[data-level="bom"]');
            let hasErrors = false;

            allSelects.forEach(select => {
                const field = select.dataset.field;
                const isRequired = select.dataset.required === 'true';
                const value = select.value;

                if (isRequired && !value) {
                    showMessage(`Required field "${field}" must be mapped`, 'danger');
                    select.classList.add('is-invalid');
                    hasErrors = true;
                } else {
                    select.classList.remove('is-invalid');
                    if (value) {
                        mappings[field] = value;
                    }
                }
            });

            if (hasErrors) {
                debugLog('error', 'Field mapping validation failed - required fields missing');
                return;
            }

            fieldMappings = mappings;
            debugLog('success', 'Field mappings saved', fieldMappings);

            // Save to localStorage for future use
            saveMappingToLocalStorage(mappings);

            showMessage('Field mappings saved successfully', 'success');

            // Close the modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('fieldMappingModal'));
            modal.hide();

            // Now process the BOM data with the configured mappings
            processBOMData();
        }

        // Save mapping to localStorage
        function saveMappingToLocalStorage(mappings) {
            try {
                const mappingData = {
                    mappings: mappings,
                    solidworksColumns: solidworksColumns,
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem(MAPPING_STORAGE_KEY, JSON.stringify(mappingData));
                debugLog('success', 'Mappings saved to browser storage');
            } catch (e) {
                if (e.name === 'SecurityError') {
                    debugLog('info', 'localStorage not available (running in restricted context)');
                } else {
                    debugLog('warning', 'Could not save mappings to localStorage', e.toString());
                }
            }
        }

        // Load saved mappings from localStorage
        function loadSavedMappings() {
            try {
                const saved = localStorage.getItem(MAPPING_STORAGE_KEY);
                if (saved) {
                    const mappingData = JSON.parse(saved);
                    debugLog('info', 'Found saved mappings from ' + mappingData.timestamp);

                    // Check if the columns match
                    const savedCols = mappingData.solidworksColumns || [];
                    const currentCols = solidworksColumns;

                    const colsMatch = savedCols.length === currentCols.length &&
                        savedCols.every((col, i) => col === currentCols[i]);

                    if (colsMatch) {
                        debugLog('success', 'Saved mappings match current CSV columns - auto-loading');
                        fieldMappings = mappingData.mappings;

                        // Apply mappings to UI dropdowns
                        applyMappingsToUI();

                        showMessage('Loaded saved field mappings from previous session', 'success');

                        // Auto-process if we have CSV
                        if (rawCSVContent) {
                            debugLog('info', 'Auto-processing BOM with saved mappings');
                            setTimeout(() => processBOMData(), 500);
                        }
                    } else {
                        debugLog('warning', 'Saved mappings do not match current CSV columns');
                        showMessage('Found saved mappings but column structure has changed', 'warning');
                    }
                }
            } catch (e) {
                if (e.name === 'SecurityError') {
                    debugLog('info', 'localStorage not available (running in restricted context)');
                } else {
                    debugLog('error', 'Error loading saved mappings', e.toString());
                }
            }
        }

        // Export mapping to JSON file
        function exportMappingFile() {
            const mappingData = {
                mappings: fieldMappings,
                solidworksColumns: solidworksColumns,
                bomLevelHeaders: bomLevelHeaders,
                itemLevelHeaders: itemLevelHeaders,
                timestamp: new Date().toISOString(),
                version: '1.0'
            };

            const content = JSON.stringify(mappingData, null, 2);
            downloadCSV(content, 'bom_field_mappings.json');
            debugLog('success', 'Mapping configuration exported');
        }

        // Import mapping from JSON file
        function importMappingFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';

            input.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const mappingData = JSON.parse(event.target.result);
                        fieldMappings = mappingData.mappings;
                        debugLog('success', 'Mapping configuration imported from file');

                        showMessage('Field mappings imported successfully! Open "Configure Field Mapping" to see the loaded mappings.', 'success');

                        // Apply the mappings if we have data
                        if (rawCSVContent) {
                            processBOMData();
                        }
                    } catch (err) {
                        debugLog('error', 'Error parsing mapping file: ' + err.toString());
                        showMessage('Error importing mapping file: ' + err.message, 'danger');
                    }
                };
                reader.readAsText(file);
            };

            input.click();
        }

        // Apply loaded mappings to the UI dropdowns
        function applyMappingsToUI() {
            debugLog('info', 'Applying loaded mappings to UI');

            // Find all mapping dropdowns
            const allSelects = document.querySelectorAll('select[data-level="bom"]');

            allSelects.forEach(select => {
                const field = select.dataset.field;

                // If we have a mapping for this field, set the dropdown value
                if (fieldMappings[field]) {
                    select.value = fieldMappings[field];
                    debugLog('info', `Set ${field} -> ${fieldMappings[field]}`);
                }
            });

            debugLog('success', 'Applied mappings to UI dropdowns');
        }

        // Display parts to create in table
        function displayPartsToCreate() {
            const tbody = document.getElementById('partsTableBody');
            tbody.innerHTML = '';

            for (const part of partsToCreate) {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${part.partNumber}</td>
                    <td>${part.description}</td>
                    <td>${part.uom || 'ea'}</td>
                    <td>${config.createAsInventory ? 'Inventory' : (part.type || 'Inventory')}</td>
                    <td><span class="badge bg-warning">To Create</span></td>
                `;
                tbody.appendChild(row);
            }

            // Update count in accordion header
            document.getElementById('partsCount').textContent = partsToCreate.length;

            document.getElementById('partsSection').classList.remove('hidden');
            document.getElementById('exportSection').classList.remove('hidden');
        }

        // Export functions
        function exportPartImport() {
            debugLog('info', 'Starting Part/Product/Vendor Pricing CSV export...');

            if (partsToCreate.length === 0) {
                showMessage('No parts to export', 'warning');
                return;
            }

            try {
                // PPP Import format with all key fields from Fishbowl documentation
                // Required fields: PartNumber, PartDescription, UOM, PartTypeID, Active, PartTaxCode
                const headers = [
                    'PartNumber', 'PartDescription', 'PartDetails', 'UOM', 'UPC',
                    'PartTypeID', 'Active', 'PartTaxCode', 'StdCost', 'ABCCode',
                    'Weight', 'WeightUOM', 'Width', 'Height', 'Len', 'SizeUOM',
                    'PartRevision', 'PartURL',
                    // Product columns (for parts created as Products)
                    'ProductNum', 'ProductDescription', 'ProductDetails', 'ProductPrice', 'ProductTaxable',
                    'ProductIncomeAccount', 'ProductDefaultSOItemType', 'ProductAlertNote', 'ProductImageUrl',
                    // Vendor columns
                    'Vendor', 'VendorPartNumber', 'Cost', 'VendorUOM', 'DefaultVendor'
                ];
                const rows = [];

                // Header row
                rows.push(headers.map(h => `"${h}"`).join(','));

                // Data rows
                for (const part of partsToCreate) {
                    // Map part type to PartTypeID (10=INVENTORY by default)
                    let partTypeID = '10'; // 10=INVENTORY (default)
                    if (!config.createAsInventory && part.type) {
                        const typeMap = {
                            'Inventory': '10',
                            'Service': '20',
                            'Labor': '21',
                            'Overhead': '22',
                            'Non-Inventory': '30',
                            'Internal Use': '40',
                            'Capital Equipment': '50',
                            'Shipping': '60'
                        };
                        partTypeID = typeMap[part.type] || '10';
                    }

                    // Determine if this part should have product data
                    const isProduct = part.type === 'Product';

                    const row = [
                        part.partNumber || '',
                        part.description || '',
                        part.details || '',
                        part.uom || defaultValues.uom,
                        part.upc || '',
                        partTypeID, // PartTypeID (required)
                        'true', // Active
                        defaultValues.taxCode, // PartTaxCode
                        part.standardCost || '', // StdCost
                        'B', // ABCCode (default to B)
                        part.weight || '',
                        part.weight ? defaultValues.weightUOM : '', // WeightUOM
                        part.width || '',
                        part.height || '',
                        part.length || '',
                        (part.width || part.height || part.length) ? defaultValues.sizeUOM : '', // SizeUOM
                        part.revision || '',
                        '', // PartURL
                        // Product columns (populate if this is a Product)
                        isProduct ? part.partNumber : '', // ProductNum (same as part number)
                        isProduct ? part.description : '', // ProductDescription (same as part description)
                        isProduct ? (part.details || '') : '', // ProductDetails
                        isProduct ? (part.productPrice || '') : '', // ProductPrice (optional - can be set later)
                        isProduct ? 'true' : '', // ProductTaxable (default to true for products)
                        isProduct ? '' : '', // ProductIncomeAccount (optional)
                        isProduct ? '10' : '', // ProductDefaultSOItemType (10=Sale, optional)
                        isProduct ? '' : '', // ProductAlertNote (optional)
                        isProduct ? '' : '', // ProductImageUrl (optional)
                        // Vendor columns
                        part.vendor || '',
                        part.vendorNumber || '',
                        part.vendorCost || '',
                        part.vendor ? (part.uom || defaultValues.uom) : '', // VendorUOM
                        part.vendor ? 'true' : '' // DefaultVendor
                    ];
                    rows.push(row.map(v => `"${v}"`).join(','));
                }

                const csvContent = rows.join('\n');
                debugLog('success', `Generated Part/Product/Vendor Pricing CSV with ${partsToCreate.length} parts`);

                downloadCSV(csvContent, 'part_product_vendor_pricing.csv');
                showMessage(`Exported ${partsToCreate.length} parts in PPP format`, 'success');

            } catch (error) {
                debugLog('error', 'Error generating Part Import CSV', error.toString());
                showMessage('Error generating Part Import CSV: ' + error.message, 'danger');
            }
        }

        function exportBOMImport() {
            debugLog('info', 'Starting BOM Import CSV export...');

            if (bomsToCreate.length === 0) {
                showMessage('No BOMs to export', 'warning');
                return;
            }

            // Check if mappings are configured (new flat structure)
            if (!fieldMappings || Object.keys(fieldMappings).length === 0) {
                showMessage('Please configure field mappings first', 'warning');
                debugLog('warning', 'Field mappings not configured');
                return;
            }

            // Auto-load BOM import headers if not loaded
            if (!bomLevelHeaders.length || !itemLevelHeaders.length) {
                debugLog('info', 'BOM import headers not loaded - loading now...');
                checkBOMImportHeaders();

                if (!bomLevelHeaders.length || !itemLevelHeaders.length) {
                    showMessage('Failed to load BOM import headers', 'danger');
                    return;
                }
            }

            try {
                const rows = [];

                // Row 1: BOM-level headers (exactly as from API)
                rows.push(bomLevelHeaders.map(h => `"${h}"`).join(','));

                // Row 2: Item-level headers (exactly as from API)
                rows.push(itemLevelHeaders.map(h => `"${h}"`).join(','));

                // Generate BOM rows
                for (let i = 0; i < bomsToCreate.length; i++) {
                    const bom = bomsToCreate[i];

                    // Log first BOM as example
                    if (i === 0) {
                        debugLog('info', `Generating BOM rows (example): ${bom.partNumber}`);
                    }

                    // BOM-level row (Flag = "BOM")
                    const bomRow = generateBOMRow(bom);
                    rows.push(bomRow);

                    // First item: Finished Good output
                    const finishedGoodRow = generateFinishedGoodRow(bom);
                    rows.push(finishedGoodRow);

                    // Item-level rows (Flag = "Item") for each component
                    for (const item of bom.items) {
                        const itemRow = generateItemRow(bom, item);
                        rows.push(itemRow);
                    }
                }

                const csvContent = rows.join('\n');
                debugLog('success', `Generated BOM Import CSV with ${bomsToCreate.length} BOMs`);
                debugLog('info', 'CSV Preview (first 500 chars)', csvContent.substring(0, 500));

                downloadCSV(csvContent, 'bom_import.csv');
                showMessage(`Exported ${bomsToCreate.length} BOMs successfully`, 'success');

            } catch (error) {
                debugLog('error', 'Error generating BOM Import CSV', error.toString());
                showMessage('Error generating BOM Import CSV: ' + error.message, 'danger');
            }
        }

        function generateBOMRow(bom) {
            const row = [];

            // For each BOM-level header, generate the value
            for (const header of bomLevelHeaders) {
                let value = '';

                if (header === 'Flag') {
                    value = 'BOM';
                } else if (header === 'Number') {
                    value = bom.partNumber || '';
                } else if (header === 'Description') {
                    value = bom.description || '';
                } else if (header === 'Active') {
                    value = 'true';
                } else if (header === 'AutoCreateType') {
                    value = config.autoCreateType || 'Build To Order';
                } else {
                    // For other fields, leave empty
                    value = '';
                }

                // Properly escape quotes (like PPP validator)
                row.push('"' + String(value).replace(/"/g, '""') + '"');
            }

            return row.join(',');
        }

        function generateFinishedGoodRow(bom) {
            const row = [];

            // For each Item-level header, generate the Finished Good output
            for (const header of itemLevelHeaders) {
                let value = '';

                if (header === 'Flag') {
                    value = 'Item';
                } else if (header === 'Part') {
                    value = bom.partNumber || '';
                } else if (header === 'Quantity') {
                    value = '1';
                } else if (header === 'UOM') {
                    value = bom.uom || defaultValues.uom;
                } else if (header === 'Description') {
                    value = bom.description || '';
                } else if (header === 'Type') {
                    value = 'Finished Good'; // BOM output is always Finished Good
                } else if (header === 'IsStage') {
                    value = 'false'; // Finished Good is NEVER a stage (only Raw Goods can be stages)
                } else if (header === 'StageBOMNumber') {
                    value = '';
                } else if (header === 'IsVariableQuantity') {
                    value = 'false';
                } else if (header === 'MinQuantity' || header === 'MaxQuantity') {
                    value = '0';
                } else if (header === 'IsGroupDefault') {
                    value = 'true';
                } else if (header === 'PriceAdjustment') {
                    value = '0.00';
                } else if (header === 'IsOneTimeItem') {
                    value = 'false';
                } else if (header === 'ConfigurationSortOrder') {
                    value = '1';
                } else {
                    // For any other fields, leave empty
                    value = '';
                }

                // Properly escape quotes (like PPP validator)
                row.push('"' + String(value).replace(/"/g, '""') + '"');
            }

            return row.join(',');
        }

        function generateItemRow(bom, item) {
            const row = [];

            // For each Item-level header, generate the value
            for (const header of itemLevelHeaders) {
                let value = '';

                if (header === 'Flag') {
                    value = 'Item';
                } else if (header === 'Part') {
                    value = item.partNumber || '';
                } else if (header === 'Quantity') {
                    value = item.quantity || '1';
                } else if (header === 'UOM') {
                    value = item.uom || defaultValues.uom;
                } else if (header === 'Description') {
                    value = item.description || '';
                } else if (header === 'Type') {
                    value = item.type || 'Raw Good';
                } else if (header === 'IsStage') {
                    // Check if this item has its own BOM
                    const hasOwnBOM = bomsToCreate.find(b => b.partNumber === item.partNumber);
                    value = hasOwnBOM ? 'true' : 'false';
                } else if (header === 'StageBOMNumber') {
                    // If it's a stage, reference the stage BOM
                    const hasOwnBOM = bomsToCreate.find(b => b.partNumber === item.partNumber);
                    value = hasOwnBOM ? item.partNumber : '';
                } else if (header === 'IsVariableQuantity') {
                    value = 'false';
                } else if (header === 'MinQuantity' || header === 'MaxQuantity') {
                    value = '0';
                } else if (header === 'IsGroupDefault') {
                    value = 'true';
                } else if (header === 'PriceAdjustment') {
                    value = '0.00';
                } else if (header === 'IsOneTimeItem') {
                    value = 'false';
                } else if (header === 'ConfigurationSortOrder') {
                    value = '1';
                } else {
                    // For any other fields, leave empty
                    value = '';
                }

                // Properly escape quotes (like PPP validator)
                row.push('"' + String(value).replace(/"/g, '""') + '"');
            }

            return row.join(',');
        }

        function getItemData(item) {
            // Find the original row data from solidworksData
            const foundItem = solidworksData.find(d => d.level === item.level && d.partNumber === item.partNumber);
            if (!foundItem) return null;

            // Create a map of column name to value
            const data = {};
            solidworksColumns.forEach((col, index) => {
                // Store the data using column names
                if (col === 'LEVEL') data[col] = foundItem.level;
                if (col === 'Description') data[col] = foundItem.description;
                if (col === 'PGE P/N#') data[col] = foundItem.partNumber;
                if (col === 'Ordering type') data[col] = foundItem.type;
                if (col === 'Qty') data[col] = foundItem.quantity;
                if (col === 'uom') data[col] = foundItem.uom;
            });

            return data;
        }

        // API Import Functions
        function importPartsToFishbowl() {
            debugLog('info', 'Starting direct Part import to Fishbowl...');

            if (partsToCreate.length === 0) {
                showMessage('No parts to import', 'warning');
                return;
            }

            try {
                // Use standard PPP import headers (same as PPP Pricing Validator)
                const headers = [
                    'PartNumber', 'PartDescription', 'PartDetails', 'UOM', 'UPC',
                    'PartTypeID', 'Active', 'PartTaxCode', 'StdCost', 'ABCCode',
                    'Weight', 'WeightUOM', 'Width', 'Height', 'Len', 'SizeUOM',
                    'PartRevision', 'PartURL',
                    // Product columns (for parts created as Products)
                    'ProductNum', 'ProductDescription', 'ProductDetails', 'ProductPrice', 'ProductTaxable',
                    'ProductIncomeAccount', 'ProductDefaultSOItemType', 'ProductAlertNote', 'ProductImageUrl',
                    // Vendor columns
                    'Vendor', 'VendorPartNumber', 'Cost', 'VendorUOM', 'DefaultVendor'
                ];

                const rows = [];

                // Header row (escape quotes like PPP validator)
                rows.push(headers.map(h => '"' + h.replace(/"/g, '""') + '"').join(','));

                // Data rows
                for (let i = 0; i < partsToCreate.length; i++) {
                    const part = partsToCreate[i];

                    // Log first part as example
                    if (i === 0) {
                        debugLog('info', `Generating part row (example): ${part.partNumber}`);
                    }

                    // Map part type to PartTypeID (10=INVENTORY by default)
                    let partTypeID = '10'; // 10=INVENTORY (default)
                    if (!config.createAsInventory && part.type) {
                        const typeMap = {
                            'Inventory': '10',
                            'Service': '20',
                            'Labor': '21',
                            'Overhead': '22',
                            'Non-Inventory': '30',
                            'Internal Use': '40',
                            'Capital Equipment': '50',
                            'Shipping': '60'
                        };
                        partTypeID = typeMap[part.type] || '10';
                    }

                    // Determine if this part should have product data
                    const isProduct = part.type === 'Product';

                    const row = [
                        part.partNumber || '',
                        part.description || '',
                        part.details || '',
                        part.uom || defaultValues.uom,
                        part.upc || '',
                        partTypeID, // PartTypeID (required)
                        'true', // Active
                        defaultValues.taxCode, // PartTaxCode
                        part.standardCost || '', // StdCost
                        'B', // ABCCode (default to B)
                        part.weight || '',
                        part.weight ? defaultValues.weightUOM : '', // WeightUOM
                        part.width || '',
                        part.height || '',
                        part.length || '',
                        (part.width || part.height || part.length) ? defaultValues.sizeUOM : '', // SizeUOM
                        part.revision || '',
                        '', // PartURL
                        // Product columns (populate if this is a Product)
                        isProduct ? part.partNumber : '', // ProductNum (same as part number)
                        isProduct ? part.description : '', // ProductDescription (same as part description)
                        isProduct ? (part.details || '') : '', // ProductDetails
                        isProduct ? (part.productPrice || '') : '', // ProductPrice (optional - can be set later)
                        isProduct ? 'true' : '', // ProductTaxable (default to true for products)
                        isProduct ? '' : '', // ProductIncomeAccount (optional)
                        isProduct ? '10' : '', // ProductDefaultSOItemType (10=Sale, optional)
                        isProduct ? '' : '', // ProductAlertNote (optional)
                        isProduct ? '' : '', // ProductImageUrl (optional)
                        // Vendor columns
                        part.vendor || '',
                        part.vendorNumber || '',
                        part.vendorCost || '',
                        part.vendor ? (part.uom || defaultValues.uom) : '', // VendorUOM
                        part.vendor ? 'true' : '' // DefaultVendor
                    ];

                    // Properly escape quotes in values (like PPP validator)
                    const escapedRow = row.map(v => '"' + String(v).replace(/"/g, '""') + '"').join(',');
                    rows.push(escapedRow);
                }

                // Build API request payload
                const payload = {
                    "ImportRq": {
                        "Type": "ImportPartProductAndVendorPricing",
                        "Rows": {
                            "Row": rows
                        }
                    }
                };

                debugLog('info', `Importing ${partsToCreate.length} parts to Fishbowl...`);

                showMessage(`Importing ${partsToCreate.length} parts to Fishbowl...`, 'info');
                showProgress('Importing parts to Fishbowl...', 50);

                // Call the Fishbowl API
                const response = runApiRequest('ImportRq', JSON.stringify(payload));

                hideProgress();

                if (!response) {
                    showMessage('Part import failed: No response from API', 'danger');
                    debugLog('error', 'Part import failed: No response from API');
                    return;
                }

                // Parse response
                const result = typeof response === 'string' ? JSON.parse(response) : response;

                // Check for errors in response
                if (result && result.ImportRs) {
                    const importRs = result.ImportRs;

                    // statusCode can be either number or string
                    if (importRs.statusCode === 1000 || importRs.statusCode === '1000') {
                        // Success
                        showMessage(`âœ“ Successfully imported ${partsToCreate.length} parts to Fishbowl!`, 'success');
                        debugLog('success', `Part import successful - ${partsToCreate.length} parts created`);

                        // Update UI to show parts were imported
                        updatePartsStatus('imported');
                    } else {
                        // Error
                        const errorMsg = importRs.statusMessage || 'Unknown error';
                        showMessage(`Part import failed: ${errorMsg}`, 'danger');
                        debugLog('error', `Part import failed: ${errorMsg}`);
                    }
                } else {
                    showMessage('Unexpected response format from API', 'warning');
                    debugLog('warning', 'Unexpected response format');
                }

            } catch (error) {
                hideProgress();
                debugLog('error', 'Error during Part import', error.toString());
                showMessage('Error importing parts: ' + error.message, 'danger');
            }
        }

        function importBOMsToFishbowl() {
            debugLog('info', 'Starting direct BOM import to Fishbowl...');

            if (bomsToCreate.length === 0) {
                showMessage('No BOMs to import', 'warning');
                return;
            }

            // Check if mappings are configured (new flat structure)
            if (!fieldMappings || Object.keys(fieldMappings).length === 0) {
                showMessage('Please configure field mappings first', 'warning');
                debugLog('warning', 'Field mappings not configured');
                return;
            }

            // Auto-load BOM import headers if not loaded
            if (!bomLevelHeaders.length || !itemLevelHeaders.length) {
                debugLog('info', 'BOM import headers not loaded - loading now...');
                checkBOMImportHeaders();

                if (!bomLevelHeaders.length || !itemLevelHeaders.length) {
                    showMessage('Failed to load BOM import headers', 'danger');
                    return;
                }
            }

            try {
                const rows = [];

                // Row 1: BOM-level headers (exactly as from API)
                rows.push(bomLevelHeaders.map(h => `"${h}"`).join(','));

                // Row 2: Item-level headers (exactly as from API)
                rows.push(itemLevelHeaders.map(h => `"${h}"`).join(','));

                // Generate BOM rows
                for (let i = 0; i < bomsToCreate.length; i++) {
                    const bom = bomsToCreate[i];

                    // Log first BOM as example
                    if (i === 0) {
                        debugLog('info', `Adding BOM to import (example): ${bom.partNumber}`);
                    }

                    // BOM-level row (Flag = "BOM")
                    const bomRow = generateBOMRow(bom);
                    rows.push(bomRow);

                    // First item: Finished Good output
                    const finishedGoodRow = generateFinishedGoodRow(bom);
                    rows.push(finishedGoodRow);

                    // Item-level rows (Flag = "Item") for each component
                    for (const item of bom.items) {
                        const itemRow = generateItemRow(bom, item);
                        rows.push(itemRow);
                    }
                }

                // Build API request payload
                const payload = {
                    "ImportRq": {
                        "Type": "ImportBillOfMaterials",
                        "Rows": {
                            "Row": rows
                        }
                    }
                };

                debugLog('info', `Importing ${bomsToCreate.length} BOMs to Fishbowl...`);

                showMessage(`Importing ${bomsToCreate.length} BOMs to Fishbowl...`, 'info');
                showProgress('Importing BOMs to Fishbowl...', 50);

                // Call the Fishbowl API
                const response = runApiRequest('ImportRq', JSON.stringify(payload));

                hideProgress();

                if (!response) {
                    showMessage('BOM import failed: No response from API', 'danger');
                    debugLog('error', 'BOM import failed: No response from API');
                    return;
                }

                // Parse response
                const result = typeof response === 'string' ? JSON.parse(response) : response;

                // Check for errors in response
                if (result && result.ImportRs) {
                    const importRs = result.ImportRs;

                    // statusCode can be either number or string
                    if (importRs.statusCode === 1000 || importRs.statusCode === '1000') {
                        // Success
                        showMessage(`âœ“ Successfully imported ${bomsToCreate.length} BOMs to Fishbowl!`, 'success');
                        debugLog('success', `BOM import successful - ${bomsToCreate.length} BOMs created`);

                        // Update UI to show BOMs were imported
                        updateBOMsStatus('imported');
                    } else {
                        // Error
                        const errorMsg = importRs.statusMessage || 'Unknown error';
                        showMessage(`BOM import failed: ${errorMsg}`, 'danger');
                        debugLog('error', `BOM import failed: ${errorMsg}`);
                    }
                } else {
                    showMessage('Unexpected response format from API', 'warning');
                    debugLog('warning', 'Unexpected response format');
                }

            } catch (error) {
                hideProgress();
                debugLog('error', 'Error during BOM import', error.toString());
                showMessage('Error importing BOMs: ' + error.message, 'danger');
            }
        }

        // Update parts table status
        function updatePartsStatus(status) {
            const tbody = document.getElementById('partsTableBody');
            const rows = tbody.getElementsByTagName('tr');

            for (const row of rows) {
                const statusCell = row.cells[4]; // Updated index (was 3, now 4 due to UOM column)
                if (status === 'imported') {
                    statusCell.innerHTML = '<span class="badge bg-success">Imported</span>';
                }
            }
        }

        // Update BOMs table status
        function updateBOMsStatus(status) {
            // New table structure doesn't have status column
            // Status is already shown via toast messages
            // This function is now a no-op for backwards compatibility
            if (status === 'imported') {
                debugLog('success', 'BOMs status updated to imported');
            }
        }

        // Show/hide progress indicator
        function showProgress(message, percent) {
            const progressSection = document.getElementById('progressSection');
            const progressText = document.getElementById('progressText');
            const progressBar = document.getElementById('progressBar');

            progressText.textContent = message;
            progressBar.style.width = percent + '%';
            progressSection.classList.remove('hidden');
        }

        function hideProgress() {
            const progressSection = document.getElementById('progressSection');
            progressSection.classList.add('hidden');
        }

        function downloadCSV(csvContent, filename) {
            debugLog('info', `Downloading CSV file: ${filename}`);

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');

            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);

                debugLog('success', `CSV file downloaded: ${filename}`);
            } else {
                showMessage('Download not supported in this browser', 'danger');
                debugLog('error', 'Download not supported');
            }
        }

        // Utility functions
        function showMessage(message, type = 'info') {
            const toastContainer = document.getElementById('toastContainer');

            // Map alert types to toast icons and colors
            const iconMap = {
                'success': 'check-circle-fill',
                'danger': 'exclamation-triangle-fill',
                'warning': 'exclamation-circle-fill',
                'info': 'info-circle-fill'
            };

            const bgMap = {
                'success': 'success',
                'danger': 'danger',
                'warning': 'warning',
                'info': 'info'
            };

            const icon = iconMap[type] || 'info-circle-fill';
            const bgColor = bgMap[type] || 'info';

            // Create toast element
            const toastEl = document.createElement('div');
            toastEl.className = 'toast';
            toastEl.setAttribute('role', 'alert');
            toastEl.setAttribute('aria-live', 'assertive');
            toastEl.setAttribute('aria-atomic', 'true');

            toastEl.innerHTML = `
                <div class="toast-header bg-${bgColor} text-white">
                    <i class="bi bi-${icon} me-2"></i>
                    <strong class="me-auto">${type.charAt(0).toUpperCase() + type.slice(1)}</strong>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="toast" aria-label="Close"></button>
                </div>
                <div class="toast-body">
                    ${message}
                </div>
            `;

            toastContainer.appendChild(toastEl);

            // Initialize Bootstrap toast
            const toast = new bootstrap.Toast(toastEl, {
                autohide: type === 'success' || type === 'info', // Auto-hide success/info, persist errors/warnings
                delay: 5000
            });

            toast.show();

            // Remove from DOM after hidden
            toastEl.addEventListener('hidden.bs.toast', () => {
                toastEl.remove();
            });
        }

        function updateStats(stats) {
            document.getElementById('statTotal').textContent = stats.total || 0;
            document.getElementById('statParts').textContent = stats.parts || 0;
            document.getElementById('statNewParts').textContent = stats.newParts || 0;
            document.getElementById('statBOMs').textContent = stats.boms || 0;
            document.getElementById('statWarnings').textContent = stats.warnings || 0;
            document.getElementById('statErrors').textContent = stats.errors || 0;

            document.getElementById('summaryStats').classList.remove('hidden');
        }

        // Populate settings dropdowns with Fishbowl data
        function populateSettingsDropdowns() {
            // Populate UOM dropdown
            const uomSelect = document.getElementById('defaultUOM');
            if (uomSelect && fishbowlData.uomDetails.length > 0) {
                // Clear existing options except the first (ea)
                while (uomSelect.options.length > 1) {
                    uomSelect.remove(1);
                }

                // Add UOMs from Fishbowl with name
                fishbowlData.uomDetails.forEach(uom => {
                    if (uom.code !== 'ea') { // Don't duplicate ea
                        const option = document.createElement('option');
                        option.value = uom.code;
                        option.textContent = `${uom.code} - ${uom.name || uom.code}`;
                        uomSelect.appendChild(option);
                    }
                });

                debugLog('success', `Populated ${fishbowlData.uomDetails.length} UOMs in settings`);
            }

            // Populate Tax Code dropdown
            const taxCodeSelect = document.getElementById('defaultTaxCode');
            if (taxCodeSelect && fishbowlData.taxCodeDetails.length > 0) {
                // Clear existing options except the first (NON)
                while (taxCodeSelect.options.length > 1) {
                    taxCodeSelect.remove(1);
                }

                // Add tax codes from Fishbowl with name
                fishbowlData.taxCodeDetails.forEach(tax => {
                    if (tax.code !== 'NON') { // Don't duplicate NON
                        const option = document.createElement('option');
                        option.value = tax.code;
                        option.textContent = `${tax.code} - ${tax.name || tax.code}`;
                        taxCodeSelect.appendChild(option);
                    }
                });

                debugLog('success', `Populated ${fishbowlData.taxCodeDetails.length} tax codes in settings`);
            }

            // Load saved settings after populating dropdowns
            loadSettings();
        }

        // Save settings to localStorage
        function saveSettings() {
            const settings = {
                defaultUOM: document.getElementById('defaultUOM').value,
                defaultTaxCode: document.getElementById('defaultTaxCode').value,
                defaultWeightUOM: document.getElementById('defaultWeightUOM').value,
                defaultSizeUOM: document.getElementById('defaultSizeUOM').value,
                createAsInventory: document.getElementById('createAsInventory').checked,
                createFinishedGoodsAsProducts: document.getElementById('createFinishedGoodsAsProducts').checked,
                validatePartsExist: document.getElementById('validatePartsExist').checked,
                processStagesSequentially: document.getElementById('processStagesSequentially').checked,
                createBOMFromFilename: document.getElementById('createBOMFromFilename').checked,
                autoCreateType: document.getElementById('autoCreateType').value
            };

            try {
                localStorage.setItem('bomConverterSettings', JSON.stringify(settings));
                debugLog('info', 'Settings saved');
            } catch (error) {
                // localStorage not available, but settings still applied to memory
                debugLog('info', 'Settings applied (localStorage not available)');
            }

            // Update the in-memory config and defaultValues
            defaultValues.uom = settings.defaultUOM;
            defaultValues.taxCode = settings.defaultTaxCode;
            defaultValues.weightUOM = settings.defaultWeightUOM;
            defaultValues.sizeUOM = settings.defaultSizeUOM;
            config.createAsInventory = settings.createAsInventory;
            config.createFinishedGoodsAsProducts = settings.createFinishedGoodsAsProducts;
            config.validatePartsExist = settings.validatePartsExist;
            config.processStagesSequentially = settings.processStagesSequentially;
            config.createBOMFromFilename = settings.createBOMFromFilename;
            config.autoCreateType = settings.autoCreateType;
        }

        // Load settings from localStorage
        function loadSettings() {
            try {
                const savedSettings = localStorage.getItem('bomConverterSettings');
                if (savedSettings) {
                    try {
                        const settings = JSON.parse(savedSettings);

                        // Apply settings to UI elements
                        if (settings.defaultUOM) document.getElementById('defaultUOM').value = settings.defaultUOM;
                        if (settings.defaultTaxCode) document.getElementById('defaultTaxCode').value = settings.defaultTaxCode;
                        if (settings.defaultWeightUOM) document.getElementById('defaultWeightUOM').value = settings.defaultWeightUOM;
                        if (settings.defaultSizeUOM) document.getElementById('defaultSizeUOM').value = settings.defaultSizeUOM;
                        if (settings.createAsInventory !== undefined) document.getElementById('createAsInventory').checked = settings.createAsInventory;
                        if (settings.createFinishedGoodsAsProducts !== undefined) document.getElementById('createFinishedGoodsAsProducts').checked = settings.createFinishedGoodsAsProducts;
                        if (settings.validatePartsExist !== undefined) document.getElementById('validatePartsExist').checked = settings.validatePartsExist;
                        if (settings.processStagesSequentially !== undefined) document.getElementById('processStagesSequentially').checked = settings.processStagesSequentially;
                        if (settings.createBOMFromFilename !== undefined) document.getElementById('createBOMFromFilename').checked = settings.createBOMFromFilename;
                        if (settings.autoCreateType) document.getElementById('autoCreateType').value = settings.autoCreateType;

                        // Update in-memory config and defaultValues
                        defaultValues.uom = settings.defaultUOM || 'ea';
                        defaultValues.taxCode = settings.defaultTaxCode || 'NON';
                        defaultValues.weightUOM = settings.defaultWeightUOM || 'kg'; // Metric default
                        defaultValues.sizeUOM = settings.defaultSizeUOM || 'cm';      // Metric default
                        config.createAsInventory = settings.createAsInventory !== undefined ? settings.createAsInventory : true;
                        config.createFinishedGoodsAsProducts = settings.createFinishedGoodsAsProducts || false;
                        config.validatePartsExist = settings.validatePartsExist !== undefined ? settings.validatePartsExist : true;
                        config.processStagesSequentially = settings.processStagesSequentially !== undefined ? settings.processStagesSequentially : true;
                        config.createBOMFromFilename = settings.createBOMFromFilename || false;
                        config.autoCreateType = settings.autoCreateType || 'Build To Order';

                        debugLog('success', 'Settings loaded from localStorage');
                    } catch (error) {
                        debugLog('error', 'Error parsing settings', error.toString());
                    }
                } else {
                    debugLog('info', 'No saved settings found, using defaults');
                }
            } catch (error) {
                // localStorage not available (e.g., data: URLs, file: URLs with restrictions)
                debugLog('info', 'localStorage not available, using defaults');
            }
        }

        // Save combined configuration (settings + field mappings)
        function saveConfiguration() {
            const configuration = {
                version: '1.0',
                timestamp: new Date().toISOString(),
                settings: {
                    defaultUOM: document.getElementById('defaultUOM').value,
                    defaultTaxCode: document.getElementById('defaultTaxCode').value,
                    defaultWeightUOM: document.getElementById('defaultWeightUOM').value,
                    defaultSizeUOM: document.getElementById('defaultSizeUOM').value,
                    createAsInventory: document.getElementById('createAsInventory').checked,
                    createFinishedGoodsAsProducts: document.getElementById('createFinishedGoodsAsProducts').checked,
                    validatePartsExist: document.getElementById('validatePartsExist').checked,
                    processStagesSequentially: document.getElementById('processStagesSequentially').checked,
                    createBOMFromFilename: document.getElementById('createBOMFromFilename').checked,
                    autoCreateType: document.getElementById('autoCreateType').value
                },
                fieldMappings: fieldMappings
            };

            const json = JSON.stringify(configuration, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `bom-converter-config-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);

            showMessage('Configuration saved successfully', 'success');
            debugLog('success', 'Configuration saved to file');
        }

        // Load combined configuration (settings + field mappings)
        function loadConfiguration() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';

            input.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const configuration = JSON.parse(event.target.result);

                        // Load settings
                        if (configuration.settings) {
                            const settings = configuration.settings;
                            if (settings.defaultUOM) document.getElementById('defaultUOM').value = settings.defaultUOM;
                            if (settings.defaultTaxCode) document.getElementById('defaultTaxCode').value = settings.defaultTaxCode;
                            if (settings.defaultWeightUOM) document.getElementById('defaultWeightUOM').value = settings.defaultWeightUOM;
                            if (settings.defaultSizeUOM) document.getElementById('defaultSizeUOM').value = settings.defaultSizeUOM;
                            if (settings.createAsInventory !== undefined) document.getElementById('createAsInventory').checked = settings.createAsInventory;
                            if (settings.createFinishedGoodsAsProducts !== undefined) document.getElementById('createFinishedGoodsAsProducts').checked = settings.createFinishedGoodsAsProducts;
                            if (settings.validatePartsExist !== undefined) document.getElementById('validatePartsExist').checked = settings.validatePartsExist;
                            if (settings.processStagesSequentially !== undefined) document.getElementById('processStagesSequentially').checked = settings.processStagesSequentially;
                            if (settings.createBOMFromFilename !== undefined) document.getElementById('createBOMFromFilename').checked = settings.createBOMFromFilename;
                            if (settings.autoCreateType) document.getElementById('autoCreateType').value = settings.autoCreateType;

                            // Update in-memory values
                            defaultValues.uom = settings.defaultUOM || 'ea';
                            defaultValues.taxCode = settings.defaultTaxCode || 'NON';
                            defaultValues.weightUOM = settings.defaultWeightUOM || 'kg';
                            defaultValues.sizeUOM = settings.defaultSizeUOM || 'cm';
                            config.createAsInventory = settings.createAsInventory !== undefined ? settings.createAsInventory : true;
                            config.createFinishedGoodsAsProducts = settings.createFinishedGoodsAsProducts || false;
                            config.validatePartsExist = settings.validatePartsExist !== undefined ? settings.validatePartsExist : true;
                            config.processStagesSequentially = settings.processStagesSequentially !== undefined ? settings.processStagesSequentially : true;
                            config.createBOMFromFilename = settings.createBOMFromFilename || false;
                            config.autoCreateType = settings.autoCreateType || 'Build To Order';

                            // Save to localStorage
                            saveSettings();
                        }

                        // Load field mappings
                        if (configuration.fieldMappings) {
                            fieldMappings = configuration.fieldMappings;
                        }

                        showMessage('Configuration loaded successfully! Settings applied and field mappings ready.', 'success');
                        debugLog('success', 'Configuration loaded from file');

                        // Reprocess if we have data
                        if (rawCSVContent) {
                            processBOMData();
                        }
                    } catch (err) {
                        debugLog('error', 'Error loading configuration: ' + err.toString());
                        showMessage('Error loading configuration file: ' + err.message, 'danger');
                    }
                };
                reader.readAsText(file);
            };

            input.click();
        }

        // Configuration event listeners
        document.getElementById('defaultUOM').addEventListener('change', function() {
            defaultValues.uom = this.value;
            debugLog('info', `Default UOM changed to: ${this.value}`);
        });

        document.getElementById('defaultTaxCode').addEventListener('change', function() {
            defaultValues.taxCode = this.value;
            debugLog('info', `Default tax code changed to: ${this.value}`);
        });

        document.getElementById('defaultWeightUOM').addEventListener('change', function() {
            defaultValues.weightUOM = this.value;
            debugLog('info', `Default weight UOM changed to: ${this.value}`);
        });

        document.getElementById('defaultSizeUOM').addEventListener('change', function() {
            defaultValues.sizeUOM = this.value;
            debugLog('info', `Default size UOM changed to: ${this.value}`);
        });

        document.getElementById('createAsInventory').addEventListener('change', function() {
            config.createAsInventory = this.checked;
        });

        document.getElementById('createFinishedGoodsAsProducts').addEventListener('change', function() {
            config.createFinishedGoodsAsProducts = this.checked;
        });

        document.getElementById('validatePartsExist').addEventListener('change', function() {
            config.validatePartsExist = this.checked;
        });

        document.getElementById('processStagesSequentially').addEventListener('change', function() {
            config.processStagesSequentially = this.checked;
        });

        document.getElementById('createBOMFromFilename').addEventListener('change', function() {
            config.createBOMFromFilename = this.checked;
        });

        // Add event listener for settings panel to load Fishbowl data
        const settingsOffcanvas = document.getElementById('settingsOffcanvas');
        if (settingsOffcanvas) {
            settingsOffcanvas.addEventListener('show.bs.offcanvas', function() {
                // Load Fishbowl data if not already loaded and runQuery is available
                if ((fishbowlData.uomDetails.length === 0 || fishbowlData.taxCodeDetails.length === 0) && typeof runQuery === 'function') {
                    try {
                        loadFishbowlData();
                    } catch (error) {
                        debugLog('warning', 'Could not load Fishbowl data: ' + error.message);
                    }
                }
            });
        }

        // Initialize
        console.log('Solidworks BOM Conversion Tool initialized');
        debugLog('info', 'Solidworks BOM Conversion Tool initialized');
        debugLog('info', 'Ready to process Solidworks BOM CSV files');
        debugLog('info', 'Upload Solidworks CSV to begin BOM conversion');

        // Auto-check BOM headers on load (optional - can comment out if not needed)
        // setTimeout(() => checkBOMImportHeaders(), 1000);
    </script>

    <!-- Bootstrap JS Bundle (for modals, offcanvas functionality) -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
