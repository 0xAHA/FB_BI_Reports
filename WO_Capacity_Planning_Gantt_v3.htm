<!DOCTYPE html>
<!--
    Commit: 98ef2b9
    Updated: 2026-01-16 16:00:00 AEDT (UTC+10)
    Changes: Added Customer PO to MO tooltips, View by WO#/BOM# dropdown for calendar/capacity tiles
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manufacturing Capacity Planning (beta)</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <!-- Moment.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.4/moment.min.js"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">

    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        /* Custom Brand Colors */
        :root {
            --color-primary: #2d9cdb;
            --color-primary-dark: #1e7bb4;
            --color-sidebar: #06162d;
            --color-sidebar-hover: #0a1f3d;
        }

        /* Custom Scrollbar */
        .custom-scrollbar::-webkit-scrollbar { width: 8px; height: 8px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #f1f5f9; border-radius: 4px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #94a3b8; }

        /* Override Tailwind indigo with custom blue */
        .bg-indigo-600 { background-color: var(--color-primary) !important; }
        .bg-indigo-50 { background-color: rgba(45, 156, 219, 0.1) !important; }
        .text-indigo-600 { color: var(--color-primary) !important; }
        .text-indigo-700 { color: var(--color-primary-dark) !important; }
        .border-indigo-200 { border-color: rgba(45, 156, 219, 0.3) !important; }
        .hover\:text-indigo-600:hover { color: var(--color-primary) !important; }
        .hover\:bg-indigo-50:hover { background-color: rgba(45, 156, 219, 0.1) !important; }
        .focus\:ring-indigo-100:focus { --tw-ring-color: rgba(45, 156, 219, 0.2) !important; }
        .shadow-indigo-900\/20 { box-shadow: 0 10px 15px -3px rgba(45, 156, 219, 0.2) !important; }

        /* Sidebar colors */
        .bg-slate-900 { background-color: var(--color-sidebar) !important; }
        .bg-slate-800 { background-color: var(--color-sidebar-hover) !important; }

        /* Gantt Chart Styles */
        .wo-bar {
            cursor: move;
            transition: opacity 0.2s ease;
        }
        .wo-bar:hover { opacity: 0.9; }
        .wo-bar.dragging { opacity: 0.6; }

        .dependency-arrow { pointer-events: none; }
        .dependency-arrow.conflict { stroke: #ef4444; }

        /* Capacity Table */
        .capacity-table-wrapper {
            cursor: grab;
            user-select: none;
        }
        .capacity-table-wrapper:active { cursor: grabbing; }

        .capacity-wo-bar {
            cursor: move;
            transition: transform 0.2s;
        }
        .capacity-wo-bar:hover {
            transform: translateY(-2px);
        }

        /* Toast Container */
        .toast-container {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .toast {
            min-width: 300px;
            padding: 1rem;
            background: white;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            border-left: 4px solid;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .toast.success { border-color: #10b981; }
        .toast.error { border-color: #ef4444; }
        .toast.info { border-color: #6366f1; }

        /* Modal/Offcanvas */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 9998;
            display: none;
            backdrop-filter: blur(4px);
        }

        .modal-overlay.show { display: block; }

        .offcanvas {
            position: fixed;
            top: 0;
            right: -500px;
            width: 500px;
            height: 100%;
            background: white;
            z-index: 9999;
            transition: right 0.3s ease-out;
            box-shadow: -10px 0 25px rgba(0, 0, 0, 0.1);
        }

        .offcanvas.show { right: 0; }

        /* Loading Spinner */
        .spinner {
            border: 3px solid #e2e8f0;
            border-top-color: #6366f1;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Sidebar transition */
        .sidebar-collapsed { width: 5rem; }
        .sidebar-expanded { width: 16rem; }

        /* Custom Tooltips */
        .wo-tooltip {
            position: absolute;
            background: rgba(15, 23, 42, 0.95);
            color: white;
            padding: 0.75rem;
            border-radius: 0.5rem;
            font-size: 0.75rem;
            line-height: 1.5;
            pointer-events: none;
            z-index: 10000;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.15);
            opacity: 0;
            transition: opacity 0.2s ease;
            max-width: 300px;
            white-space: pre-line;
        }
        .wo-tooltip.show { opacity: 1; }
        .wo-tooltip-label {
            font-weight: 600;
            color: #94a3b8;
            margin-right: 0.5rem;
        }
        .wo-tooltip-value {
            color: #ffffff;
        }
    </style>
</head>
<body class="bg-slate-50">
    <!-- Toast Container -->
    <div class="toast-container"></div>

    <!-- Tooltip Container -->
    <div id="woTooltip" class="wo-tooltip"></div>

    <!-- Modal Overlay -->
    <div class="modal-overlay" id="modalOverlay"></div>

    <!-- Settings Offcanvas -->
    <div class="offcanvas custom-scrollbar" id="settingsOffcanvas">
        <div class="h-full flex flex-col">
            <div class="flex items-center justify-between p-6 border-b border-slate-200">
                <h2 class="text-xl font-bold text-slate-800">Settings</h2>
                <button onclick="closeOffcanvas('settingsOffcanvas')" class="p-2 hover:bg-slate-100 rounded-lg transition-colors">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex-1 overflow-y-auto p-6 space-y-6">
                <div class="space-y-4">
                    <h3 class="text-sm font-bold text-slate-700 uppercase tracking-wider">Schedule Options</h3>
                    <label class="flex items-center justify-between p-4 bg-slate-50 rounded-xl cursor-pointer hover:bg-slate-100 transition-colors">
                        <div>
                            <div class="text-sm font-medium text-slate-700">Allow Same-Day Dependency Starts</div>
                            <div class="text-xs text-slate-500 mt-1">Allow multiple WOs in the same MO to start on the same day</div>
                        </div>
                        <input type="checkbox" id="sameDayStartsToggle" class="w-5 h-5 flex-shrink-0 text-indigo-600 rounded">
                    </label>
                    <label class="flex items-center justify-between p-4 bg-slate-50 rounded-xl cursor-pointer hover:bg-slate-100 transition-colors">
                        <div>
                            <div class="text-sm font-medium text-slate-700">Shift Dependent WOs on Drag</div>
                            <div class="text-xs text-slate-500 mt-1">When dragging a WO in Gantt view, automatically shift its dependent WOs by the same amount</div>
                        </div>
                        <input type="checkbox" id="shiftDependentWOsToggle" class="w-5 h-5 flex-shrink-0 text-indigo-600 rounded">
                    </label>
                    <label class="flex items-center justify-between p-4 bg-slate-50 rounded-xl cursor-pointer hover:bg-slate-100 transition-colors">
                        <div>
                            <div class="text-sm font-medium text-slate-700">Skip Weekends When Scheduling</div>
                            <div class="text-xs text-slate-500 mt-1">When dragging or resizing WOs, automatically skip weekends to land on weekdays</div>
                        </div>
                        <input type="checkbox" id="skipWeekendsToggle" class="w-5 h-5 flex-shrink-0 text-indigo-600 rounded">
                    </label>
                </div>

                <div class="space-y-4">
                    <h3 class="text-sm font-bold text-slate-700 uppercase tracking-wider">Display</h3>
                    <label class="flex items-center justify-between p-4 bg-slate-50 rounded-xl cursor-pointer hover:bg-slate-100 transition-colors">
                        <span class="text-sm font-medium text-slate-700">Show Dependency Arrows</span>
                        <input type="checkbox" id="showArrowsToggle" checked class="w-5 h-5 flex-shrink-0 text-indigo-600 rounded">
                    </label>
                    <label class="flex items-center justify-between p-4 bg-slate-50 rounded-xl cursor-pointer hover:bg-slate-100 transition-colors">
                        <div>
                            <div class="text-sm font-medium text-slate-700">Show Completed WOs</div>
                            <div class="text-xs text-slate-500 mt-1">Display completed work orders in Capacity Planning and Calendar views</div>
                        </div>
                        <input type="checkbox" id="showCompletedWOsToggle" checked class="w-5 h-5 flex-shrink-0 text-indigo-600 rounded">
                    </label>
                    <div class="p-4 bg-slate-50 rounded-xl">
                        <label class="block text-sm font-medium text-slate-700 mb-2">Date Format</label>
                        <select id="dateFormatSelect" class="w-full px-3 py-2 bg-white border border-slate-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500">
                            <option value="DD/MM/YYYY">DD/MM/YYYY</option>
                            <option value="MM/DD/YYYY">MM/DD/YYYY</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Instructions Offcanvas -->
    <div class="offcanvas custom-scrollbar" id="instructionsOffcanvas">
        <div class="h-full flex flex-col">
            <div class="flex items-center justify-between p-6 border-b border-slate-200">
                <h2 class="text-xl font-bold text-slate-800">Instructions</h2>
                <button onclick="closeOffcanvas('instructionsOffcanvas')" class="p-2 hover:bg-slate-100 rounded-lg transition-colors">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex-1 overflow-y-auto p-6 space-y-6">
                <div class="space-y-3">
                    <h3 class="text-sm font-bold text-slate-700 uppercase tracking-wider">About This Tool</h3>
                    <p class="text-sm text-slate-600 leading-relaxed">Manufacturing Capacity Planning (beta) provides three interactive views for visualizing and managing work order schedules:</p>
                    <ul class="text-sm text-slate-600 space-y-2 ml-4">
                        <li class="flex items-start gap-2">
                            <span class="text-indigo-600 mt-1">•</span>
                            <span><strong>MO Gantt View:</strong> Groups work orders by Manufacturing Order</span>
                        </li>
                        <li class="flex items-start gap-2">
                            <span class="text-indigo-600 mt-1">•</span>
                            <span><strong>Category View:</strong> Groups work orders by manufacturing category (swim lanes)</span>
                        </li>
                        <li class="flex items-start gap-2">
                            <span class="text-indigo-600 mt-1">•</span>
                            <span><strong>Capacity Planning:</strong> Weekly calendar view with drag-and-drop scheduling and capacity tracking</span>
                        </li>
                    </ul>
                </div>

                <div class="space-y-3">
                    <h3 class="text-sm font-bold text-slate-700 uppercase tracking-wider">MO Gantt & Category Views</h3>
                    <ul class="text-sm text-slate-600 space-y-2 ml-4">
                        <li class="flex items-start gap-2">
                            <span class="text-indigo-600 mt-1">•</span>
                            <span><strong>Drag WO:</strong> Click and drag work order bars to reschedule (auto-scrolls to updated WO)</span>
                        </li>
                        <li class="flex items-start gap-2">
                            <span class="text-indigo-600 mt-1">•</span>
                            <span><strong>Resize WO:</strong> Drag left/right edge to adjust dates</span>
                        </li>
                        <li class="flex items-start gap-2">
                            <span class="text-indigo-600 mt-1">•</span>
                            <span><strong>Navigate:</strong> Scroll or drag the timeline, use prev/next week buttons</span>
                        </li>
                        <li class="flex items-start gap-2">
                            <span class="text-indigo-600 mt-1">•</span>
                            <span><strong>Zoom:</strong> Use zoom buttons (persists across sessions)</span>
                        </li>
                        <li class="flex items-start gap-2">
                            <span class="text-indigo-600 mt-1">•</span>
                            <span><strong>Collapse MOs:</strong> Double-click MO header to collapse/expand (MO view only)</span>
                        </li>
                        <li class="flex items-start gap-2">
                            <span class="text-indigo-600 mt-1">•</span>
                            <span><strong>Undo/Redo:</strong> Use toolbar buttons (50-step history)</span>
                        </li>
                    </ul>
                </div>

                <div class="space-y-3">
                    <h3 class="text-sm font-bold text-slate-700 uppercase tracking-wider">Capacity Planning View</h3>
                    <ul class="text-sm text-slate-600 space-y-2 ml-4">
                        <li class="flex items-start gap-2">
                            <span class="text-indigo-600 mt-1">•</span>
                            <span><strong>Weekly View:</strong> Drag WOs horizontally (change dates) or vertically (change categories)</span>
                        </li>
                        <li class="flex items-start gap-2">
                            <span class="text-indigo-600 mt-1">•</span>
                            <span><strong>Monthly Calendar:</strong> Drag WOs to reschedule across days, navigate with month buttons or Today</span>
                        </li>
                        <li class="flex items-start gap-2">
                            <span class="text-indigo-600 mt-1">•</span>
                            <span><strong>Category Sorting:</strong> Categories are sorted alphabetically by name</span>
                        </li>
                        <li class="flex items-start gap-2">
                            <span class="text-indigo-600 mt-1">•</span>
                            <span><strong>Navigate:</strong> Use prev/next week buttons or Today button to jump to current week</span>
                        </li>
                        <li class="flex items-start gap-2">
                            <span class="text-indigo-600 mt-1">•</span>
                            <span><strong>Capacity Settings:</strong> Click gear icon to set daily labor hours per category (auto-saves)</span>
                        </li>
                        <li class="flex items-start gap-2">
                            <span class="text-indigo-600 mt-1">•</span>
                            <span><strong>Color Coding:</strong> Green = under capacity, Orange = at capacity, Red = over capacity</span>
                        </li>
                    </ul>
                </div>

                <div class="space-y-3">
                    <h3 class="text-sm font-bold text-slate-700 uppercase tracking-wider">Search & Filter</h3>
                    <ul class="text-sm text-slate-600 space-y-2 ml-4">
                        <li class="flex items-start gap-2">
                            <span class="text-indigo-600 mt-1">•</span>
                            <span><strong>Global Search:</strong> Searches WO numbers, MO numbers, part numbers, categories, and descriptions</span>
                        </li>
                        <li class="flex items-start gap-2">
                            <span class="text-indigo-600 mt-1">•</span>
                            <span><strong>MO Filter:</strong> Filter by specific Manufacturing Order (MO view only)</span>
                        </li>
                        <li class="flex items-start gap-2">
                            <span class="text-indigo-600 mt-1">•</span>
                            <span><strong>Works Across Views:</strong> Search results apply to all views (gantt and capacity)</span>
                        </li>
                    </ul>
                </div>

                <div class="space-y-3">
                    <h3 class="text-sm font-bold text-slate-700 uppercase tracking-wider">Settings & Preferences</h3>
                    <ul class="text-sm text-slate-600 space-y-2 ml-4">
                        <li class="flex items-start gap-2">
                            <span class="text-indigo-600 mt-1">•</span>
                            <span><strong>Auto-Save:</strong> All settings automatically save to database and persist across sessions</span>
                        </li>
                        <li class="flex items-start gap-2">
                            <span class="text-indigo-600 mt-1">•</span>
                            <span><strong>Same-Day Starts:</strong> Allow/prevent multiple WOs in same MO from starting on same day</span>
                        </li>
                        <li class="flex items-start gap-2">
                            <span class="text-indigo-600 mt-1">•</span>
                            <span><strong>Show Arrows:</strong> Toggle dependency arrows between WOs in same MO</span>
                        </li>
                        <li class="flex items-start gap-2">
                            <span class="text-indigo-600 mt-1">•</span>
                            <span><strong>Persisted Settings:</strong> Zoom level, collapsed MOs, calendar state, capacity limits</span>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Layout -->
    <div class="h-screen flex overflow-hidden">
        <!-- Main Content -->
        <main class="flex-1 flex flex-col min-w-0 h-screen overflow-hidden bg-slate-50">
            <!-- Header -->
            <header class="h-20 bg-white border-b border-slate-200 px-8 flex items-center justify-between flex-shrink-0 z-20 shadow-sm">
                <div class="flex items-center gap-6 flex-1">
                    <!-- View Switcher -->
                    <div class="flex items-center gap-2 bg-slate-100 p-1 rounded-lg">
                        <button id="view-btn-mo" onclick="switchView('mo')" class="p-2 rounded-md transition-all bg-white text-indigo-600 shadow-sm" title="MO Gantt View">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                            </svg>
                        </button>
                        <button id="view-btn-capacity" onclick="switchView('capacity')" class="p-2 rounded-md transition-all text-slate-400 hover:text-slate-600" title="Capacity Planning">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                            </svg>
                        </button>
                    </div>
                    <h2 id="viewTitle" class="text-xl font-bold text-slate-800 hidden md:block">Gantt View</h2>
                    <div class="h-6 w-px bg-slate-200 hidden md:block"></div>
                    <!-- KPI Cards -->
                    <div id="kpiCards" class="hidden lg:flex items-center gap-2 flex-1">
                        <!-- Will be populated dynamically -->
                    </div>
                    <div class="relative flex-shrink min-w-[200px] max-w-sm group">
                        <svg class="absolute left-3 top-1/2 -translate-y-1/2 text-slate-400 group-focus-within:text-indigo-600 transition-colors w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                        </svg>
                        <input
                            type="text"
                            id="searchInput"
                            placeholder="Search work orders..."
                            class="w-full bg-slate-50 border border-slate-300 rounded-xl py-2.5 pl-10 pr-4 text-sm font-medium focus:bg-white focus:ring-2 focus:ring-indigo-100 focus:border-indigo-300 transition-all outline-none text-slate-600"
                        />
                    </div>
                </div>
                <div class="flex items-center gap-3">
                    <button onclick="openOffcanvas('settingsOffcanvas')" class="p-2.5 text-slate-400 hover:text-indigo-600 hover:bg-indigo-50 rounded-xl transition-all" title="Settings">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path>
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                        </svg>
                    </button>
                    <button onclick="openOffcanvas('instructionsOffcanvas')" class="p-2.5 text-slate-400 hover:text-indigo-600 hover:bg-indigo-50 rounded-xl transition-all" title="Instructions">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path>
                        </svg>
                    </button>
                    <button onclick="loadWorkOrders()" id="refreshBtn" class="p-2.5 text-slate-400 hover:text-indigo-600 hover:bg-indigo-50 rounded-xl transition-all" title="Refresh Data">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                        </svg>
                    </button>
                </div>
            </header>

            <!-- Content Area -->
            <div class="flex-1 overflow-y-auto custom-scrollbar p-4 lg:p-8">
                <!-- Gantt/Category View Container -->
                <div id="ganttContainer" class="bg-white rounded-2xl shadow-md border border-slate-300 p-6">
                    <div class="flex flex-col sm:flex-row sm:items-center justify-between gap-4 mb-6">
                        <h3 class="text-lg font-bold text-slate-800 flex items-center gap-2">
                            <svg class="w-5 h-5 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                            </svg>
                            <span id="ganttTitle">Production Schedule</span>
                        </h3>

                        <div class="flex items-center gap-2">
                            <!-- Status Filter (Multi-select) -->
                            <div class="relative">
                                <button id="statusFilterButton" class="flex items-center gap-1 bg-slate-50 px-2 py-1.5 rounded-lg border border-slate-200 hover:bg-white text-xs font-semibold text-slate-600">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z"></path>
                                    </svg>
                                    <span id="statusFilterLabel">All Status</span>
                                    <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                    </svg>
                                </button>
                                <div id="statusFilterDropdown" class="hidden absolute z-50 mt-1 bg-white rounded-lg shadow-lg border border-slate-300 py-2 min-w-[160px]">
                                    <label class="flex items-center gap-2 px-3 py-1.5 hover:bg-slate-50 cursor-pointer">
                                        <input type="checkbox" class="status-filter-checkbox" value="10" checked>
                                        <span class="text-xs text-slate-700">Entered</span>
                                    </label>
                                    <label class="flex items-center gap-2 px-3 py-1.5 hover:bg-slate-50 cursor-pointer">
                                        <input type="checkbox" class="status-filter-checkbox" value="30" checked>
                                        <span class="text-xs text-slate-700">Started</span>
                                    </label>
                                    <label class="flex items-center gap-2 px-3 py-1.5 hover:bg-slate-50 cursor-pointer">
                                        <input type="checkbox" class="status-filter-checkbox" value="40" checked>
                                        <span class="text-xs text-slate-700">Fulfilled</span>
                                    </label>
                                    <label class="flex items-center gap-2 px-3 py-1.5 hover:bg-slate-50 cursor-pointer">
                                        <input type="checkbox" class="status-filter-checkbox" value="conflict" checked>
                                        <span class="text-xs text-slate-700">Conflicts</span>
                                    </label>
                                </div>
                            </div>

                            <!-- Date Navigation -->
                            <div class="flex items-center gap-1 bg-slate-50 px-2 py-1.5 rounded-lg border border-slate-200">
                                <button onclick="prevWeek()" class="p-1 hover:bg-white rounded transition-colors text-slate-600" title="Previous Week">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
                                    </svg>
                                </button>
                                <button onclick="goToToday()" class="px-2 py-1 text-xs font-semibold hover:bg-white rounded transition-colors text-slate-600" title="Go to Today">
                                    Today
                                </button>
                                <button onclick="nextWeek()" class="p-1 hover:bg-white rounded transition-colors text-slate-600" title="Next Week">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                                    </svg>
                                </button>
                            </div>

                            <!-- Time Range -->
                            <div class="flex items-center gap-1 bg-slate-50 px-2 py-1.5 rounded-lg border border-slate-200">
                                <button onclick="setTimeRange(7)" class="px-2 py-1 text-xs font-semibold hover:bg-white rounded transition-colors text-slate-600" title="Show 1 Week">1W</button>
                                <button onclick="setTimeRange(14)" class="px-2 py-1 text-xs font-semibold hover:bg-white rounded transition-colors text-slate-600" title="Show 2 Weeks">2W</button>
                                <button onclick="setTimeRange(30)" class="px-2 py-1 text-xs font-semibold hover:bg-white rounded transition-colors text-slate-600" title="Show 1 Month">1M</button>
                                <button onclick="setTimeRange(90)" class="px-2 py-1 text-xs font-semibold hover:bg-white rounded transition-colors text-slate-600" title="Show 3 Months">3M</button>
                            </div>

                            <!-- Zoom Controls -->
                            <div class="flex items-center gap-1 bg-slate-50 px-2 py-1.5 rounded-lg border border-slate-200">
                                <button onclick="zoomOut()" class="p-1 hover:bg-white rounded transition-colors text-slate-600" title="Zoom Out">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM13 10H7"></path>
                                    </svg>
                                </button>
                                <button onclick="zoomIn()" class="p-1 hover:bg-white rounded transition-colors text-slate-600" title="Zoom In">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM10 7v3m0 0v3m0-3h3m-3 0H7"></path>
                                    </svg>
                                </button>
                            </div>

                            <!-- Toggle Buttons -->
                            <div class="flex items-center gap-1 bg-slate-50 px-2 py-1.5 rounded-lg border border-slate-200">
                                <button id="toggleArrowsBtn" onclick="toggleArrows()" class="p-1 hover:bg-white rounded transition-colors" title="Show/Hide Dependency Arrows">
                                    <svg class="w-4 h-4 text-emerald-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7l5 5m0 0l-5 5m5-5H6"></path>
                                    </svg>
                                </button>
                            </div>

                            <!-- Undo/Redo -->
                            <div class="flex items-center gap-1 bg-slate-50 px-2 py-1.5 rounded-lg border border-slate-200">
                                <button id="undoBtn" onclick="undo()" disabled class="p-1 hover:bg-white rounded transition-colors text-slate-600 disabled:opacity-30 disabled:cursor-not-allowed" title="Undo">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6"></path>
                                    </svg>
                                </button>
                                <button id="redoBtn" onclick="redo()" disabled class="p-1 hover:bg-white rounded transition-colors text-slate-600 disabled:opacity-30 disabled:cursor-not-allowed" title="Redo">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 10h-10a8 8 0 00-8 8v2m18-10l-6-6m6 6l-6 6"></path>
                                    </svg>
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Gantt Chart SVG -->
                    <div id="ganttWrapper" class="overflow-auto custom-scrollbar" style="max-height: 800px; position: relative;">
                        <svg id="ganttSvg"></svg>
                        <!-- Sticky category labels overlay (category view only) -->
                        <div id="categoryLabelsOverlay" style="position: absolute; top: 0; left: 0; width: 185px; display: none; background: #f8fafc; z-index: 100;">
                        </div>
                    </div>
                </div>

                <!-- Capacity Planning View Container -->
                <div id="capacityContainer" style="display: none;">
                    <!-- Monthly Calendar View - Always Visible -->
                    <div class="bg-white rounded-2xl shadow-md border border-slate-300 mb-4 p-6">
                        <div class="flex items-center justify-between mb-4">
                            <div class="flex items-center gap-2">
                                <svg class="w-5 h-5 text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                                </svg>
                                <h3 class="text-lg font-bold text-slate-800">Monthly Calendar</h3>
                                <span id="calendarMonthDisplay" class="text-sm font-semibold text-slate-600 ml-2"></span>
                            </div>
                            <div class="flex items-center gap-2">
                                <button onclick="changeCalendarMonth(-1)" class="px-3 py-2 bg-slate-100 hover:bg-slate-200 border border-slate-300 rounded-lg text-sm font-medium transition-colors">
                                    <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 19l-7-7 7-7m8 14l-7-7 7-7"></path>
                                    </svg>
                                    Month
                                </button>
                                <button onclick="goToCalendarToday()" class="px-3 py-2 bg-indigo-50 hover:bg-indigo-100 border border-indigo-300 rounded-lg text-sm font-semibold text-indigo-700 transition-colors">
                                    Today
                                </button>
                                <button onclick="changeCalendarMonth(1)" class="px-3 py-2 bg-slate-100 hover:bg-slate-200 border border-slate-300 rounded-lg text-sm font-medium transition-colors">
                                    Month
                                    <svg class="w-4 h-4 inline ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 5l7 7-7 7M5 5l7 7-7 7"></path>
                                    </svg>
                                </button>
                                <div class="ml-2 border-l border-slate-300 pl-2">
                                    <select id="calendarColorModeSelect" onchange="toggleCalendarColorMode()" class="px-3 py-2 bg-white border border-slate-200 rounded-lg text-sm font-medium focus:outline-none focus:ring-2 focus:ring-indigo-500">
                                        <option value="status">Color by Status</option>
                                        <option value="category">Color by Category</option>
                                    </select>
                                </div>
                                <div class="ml-2 border-l border-slate-300 pl-2">
                                    <select id="viewByModeSelect" onchange="toggleViewByMode()" class="px-3 py-2 bg-white border border-slate-200 rounded-lg text-sm font-medium focus:outline-none focus:ring-2 focus:ring-indigo-500">
                                        <option value="wo_num">View by WO#</option>
                                        <option value="bom_num">View by BOM#</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                        <div id="monthCalendar" class="relative" style="min-height: 400px; margin-left: 82px;">
                            <!-- Calendar will be rendered here (inset to align with capacity planning days) -->
                        </div>
                    </div>

                    <div class="bg-white rounded-2xl shadow-md border border-slate-300 p-6">
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="text-lg font-bold text-slate-800">Weekly Capacity Planning</h3>
                            <div class="flex items-center gap-2">
                                <button onclick="openCapacitySettingsModal()" class="px-3 py-2 bg-slate-100 hover:bg-slate-200 border border-slate-300 rounded-lg text-sm font-medium transition-colors" title="Capacity Settings">
                                    <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path>
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                                    </svg>
                                    Settings
                                </button>
                                <button onclick="changeCapacityWeek(-1)" class="px-3 py-2 bg-slate-100 hover:bg-slate-200 border border-slate-300 rounded-lg text-sm font-medium transition-colors">
                                    <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 19l-7-7 7-7m8 14l-7-7 7-7"></path>
                                    </svg>
                                    Week
                                </button>
                                <button onclick="goToCapacityToday()" class="px-3 py-2 bg-indigo-50 hover:bg-indigo-100 border border-indigo-300 rounded-lg text-sm font-semibold text-indigo-700 transition-colors">
                                    Today
                                </button>
                                <span id="capacityWeekDisplay" class="text-sm font-semibold text-slate-600 px-4"></span>
                                <button onclick="changeCapacityWeek(1)" class="px-3 py-2 bg-slate-100 hover:bg-slate-200 border border-slate-300 rounded-lg text-sm font-medium transition-colors">
                                    Week
                                    <svg class="w-4 h-4 inline ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 5l7 7-7 7M5 5l7 7-7 7"></path>
                                    </svg>
                                </button>
                            </div>
                        </div>

                        <div class="capacity-table-wrapper overflow-auto custom-scrollbar" style="max-height: 800px;">
                            <table id="capacityTable" class="w-full border-collapse">
                                <!-- Will be populated dynamically -->
                            </table>
                        </div>
                    </div>
                </div>

                <!-- Debug Console -->
                <div id="debugConsoleContainer" class="bg-white rounded-2xl shadow-sm border border-slate-200 overflow-hidden" style="display: none;">
                    <button onclick="toggleDebugConsole()" class="w-full px-6 py-3 flex items-center justify-between hover:bg-slate-50 transition-colors">
                        <div class="flex items-center gap-2">
                            <svg class="w-4 h-4 text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4"></path>
                            </svg>
                            <span class="text-sm font-semibold text-slate-700">Debug Console</span>
                            <span class="text-xs text-slate-400 font-normal">Auto-scrolls to latest entry</span>
                        </div>
                        <svg id="debugChevron" class="w-5 h-5 text-slate-400 transition-transform rotate-180" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                        </svg>
                    </button>

                    <div id="debugContent" class="border-t border-slate-200">
                        <div class="bg-slate-900 px-4 py-2 flex items-center justify-between">
                            <span class="text-xs text-slate-400 font-mono">Fishbowl Connection Diagnostics</span>
                            <button onclick="clearDebugLog()" class="text-xs text-slate-400 hover:text-white transition-colors">
                                Clear
                            </button>
                        </div>
                        <div id="debugLog" class="bg-slate-950 text-slate-200 p-4 font-mono text-xs max-h-96 overflow-y-auto custom-scrollbar">
                            <div class="text-slate-500 italic">Waiting for application to initialize...</div>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

<script>
// ============================================
// DEBUG MODE CONFIGURATION
// ============================================
// Check if debug mode should be enabled via Fishbowl property
const BI_SHOW_DEBUG_PROP = typeof getProperty === 'function' ? getProperty('BI_SHOW_DEBUG', 'false') : 'false';
const DEBUG_MODE = BI_SHOW_DEBUG_PROP === 'true' || BI_SHOW_DEBUG_PROP === true;

// ============================================
// GLOBAL VARIABLES
// ============================================
let allWorkOrders = [];
let filteredWorkOrders = [];
let manufacturingOrders = [];
let categories = [];
let stagingDependencies = [];
let conflicts = new Set();

let viewMode = 'mo'; // 'mo', 'category', 'capacity'
let currentCapacityWeek = null;
let capacitySettings = { categories: [] };
let collapsedMOs = new Set(); // Track which MOs are collapsed in MO view

// Undo/Redo
let undoStack = [];
let redoStack = [];
const MAX_UNDO_STACK = 50;

// D3 Gantt Settings
let ganttScale = 80; // pixels per day
let ganttStartDate = null; // Will be initialized in DOMContentLoaded
let ganttEndDate = null; // Will be initialized in DOMContentLoaded

// Settings
let allowSameDayStarts = false;
let shiftDependentWOs = false; // When dragging a WO in gantt view, shift dependent WOs relatively
let skipWeekends = false; // When dragging/resizing WOs in gantt view, skip weekends to land on weekdays
let showArrows = true;
let dateFormat = 'DD/MM/YYYY'; // 'DD/MM/YYYY' or 'MM/DD/YYYY'
let calendarColorMode = 'status'; // 'status' or 'category'
let viewByMode = 'wo_num'; // 'wo_num' or 'bom_num' - controls label display in calendar and capacity tiles
let showCompletedWOs = true; // Show completed WOs in capacity planning and calendar views
let scrollToDateAfterRender = null; // Used to scroll to a specific date after render completes
let activeStatusFilters = new Set(['10', '30', '40', 'conflict']); // Track current status filters (multi-select)

// Debug Console
let debugLogInitialized = false;

// Standard WO Status Colors - used across all views for consistency
const WO_STATUS_COLORS = {
    10: { // Entered/Planned - Light Blue (Fishbowl blue based)
        fill: '#C5E9F7',      // Light version of #2d9cdb
        stroke: '#2d9cdb',    // Fishbowl blue
        border: 'border-blue-400',
        bg: 'bg-blue-100',
        text: 'text-slate-900'
    },
    20: { // Issued
        fill: '#FEF3C7',      // amber-100
        stroke: '#F59E0B',    // amber-500
        border: 'border-amber-400',
        bg: 'bg-amber-100',
        text: 'text-slate-900'
    },
    30: { // Started/In Progress - Light Orange
        fill: '#FFE4CC',      // Light orange
        stroke: '#FF8C42',    // Orange
        border: 'border-orange-400',
        bg: 'bg-orange-100',
        text: 'text-slate-900'
    },
    40: { // Fulfilled/Completed - Light Green
        fill: '#D1FAE5',      // green-100
        stroke: '#10B981',    // green-500
        border: 'border-green-400',
        bg: 'bg-green-100',
        text: 'text-slate-900'
    },
    50: { // Closed
        fill: '#E5E7EB',      // gray-200
        stroke: '#6B7280',    // gray-500
        border: 'border-gray-400',
        bg: 'bg-gray-200',
        text: 'text-gray-700'
    }
};

// ============================================
// UTILITY FUNCTIONS
// ============================================
function formatDate(momentObj, includeTime = false) {
    // Format a moment object according to the user's date format preference
    if (!momentObj || !momentObj.isValid()) return 'N/A';

    if (includeTime) {
        return dateFormat === 'DD/MM/YYYY'
            ? momentObj.format('DD/MM/YYYY HH:mm')
            : momentObj.format('MM/DD/YYYY HH:mm');
    } else {
        return dateFormat === 'DD/MM/YYYY'
            ? momentObj.format('DD/MM/YYYY')
            : momentObj.format('MM/DD/YYYY');
    }
}

function debugLog(type, message, ...args) {
    // Only log if DEBUG_MODE is enabled
    if (!DEBUG_MODE) return;

    const timestamp = moment().format('HH:mm:ss.SSS');
    const prefix = `[${timestamp}] [${type.toUpperCase()}]`;
    console.log(prefix, message, ...args);

    // Add to UI debug console
    const debugLogEl = document.getElementById('debugLog');
    if (debugLogEl) {
        // Clear placeholder message on first log
        if (!debugLogInitialized) {
            debugLogEl.innerHTML = '';
            debugLogInitialized = true;
        }

        const colorMap = {
            'success': 'text-emerald-400',
            'error': 'text-red-400',
            'warn': 'text-amber-400',
            'info': 'text-blue-400'
        };
        const entry = document.createElement('div');
        entry.className = `${colorMap[type] || 'text-slate-300'} py-0.5`;
        const argsStr = args.length > 0 ? ' ' + args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ') : '';
        entry.textContent = `${prefix} ${message}${argsStr}`;
        debugLogEl.appendChild(entry);
        debugLogEl.scrollTop = debugLogEl.scrollHeight; // Auto-scroll to bottom
    }
}

function showToast(message, type = 'info', duration = 3000) {
    const container = document.querySelector('.toast-container');
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;

    const icon = type === 'success' ? '✓' : type === 'error' ? '✕' : 'ℹ';
    toast.innerHTML = `
        <div class="flex items-center gap-3">
            <span class="text-lg">${icon}</span>
            <span class="text-sm font-medium text-slate-700">${message}</span>
        </div>
    `;

    container.appendChild(toast);

    setTimeout(() => {
        toast.style.opacity = '0';
        setTimeout(() => toast.remove(), 300);
    }, duration);
}

// Custom Tooltip Functions
function showWOTooltip(event, content) {
    const tooltip = document.getElementById('woTooltip');
    tooltip.innerHTML = content;
    tooltip.classList.add('show');

    // Position tooltip near mouse, but keep it on screen
    const x = event.pageX + 15;
    const y = event.pageY + 15;
    const tooltipWidth = 300; // max-width from CSS
    const tooltipHeight = 200; // estimated max height

    const adjustedX = (x + tooltipWidth > window.innerWidth) ? event.pageX - tooltipWidth - 15 : x;
    const adjustedY = (y + tooltipHeight > window.innerHeight) ? event.pageY - tooltipHeight - 15 : y;

    tooltip.style.left = `${adjustedX}px`;
    tooltip.style.top = `${adjustedY}px`;
}

function hideWOTooltip() {
    const tooltip = document.getElementById('woTooltip');
    tooltip.classList.remove('show');
}

function openOffcanvas(id) {
    document.getElementById('modalOverlay').classList.add('show');
    document.getElementById(id).classList.add('show');
}

function closeOffcanvas(id) {
    document.getElementById('modalOverlay').classList.remove('show');
    document.getElementById(id).classList.remove('show');
}

// Close offcanvas on overlay click
document.getElementById('modalOverlay').addEventListener('click', () => {
    document.querySelectorAll('.offcanvas').forEach(el => el.classList.remove('show'));
    document.getElementById('modalOverlay').classList.remove('show');
});

function toggleSidebar() {
    const sidebar = document.getElementById('sidebar');
    sidebar.classList.toggle('sidebar-collapsed');
    sidebar.classList.toggle('sidebar-expanded');

    // Hide text when collapsed
    const texts = sidebar.querySelectorAll('.sidebar-text');
    const title = sidebar.querySelector('.sidebar-title');
    const status = sidebar.querySelector('.sidebar-status');

    if (sidebar.classList.contains('sidebar-collapsed')) {
        texts.forEach(t => t.style.display = 'none');
        title.style.display = 'none';
        if (status) status.style.display = 'none';
    } else {
        texts.forEach(t => t.style.display = '');
        title.style.display = '';
        if (status) status.style.display = '';
    }
}

function toggleDebugConsole() {
    const content = document.getElementById('debugContent');
    const chevron = document.getElementById('debugChevron');
    content.classList.toggle('hidden');
    chevron.style.transform = content.classList.contains('hidden') ? '' : 'rotate(180deg)';
}

function clearDebugLog() {
    const debugLogEl = document.getElementById('debugLog');
    if (debugLogEl) {
        debugLogEl.innerHTML = '';
        debugLogInitialized = false; // Reset flag so next log clears properly
        debugLog('info', '═══ Debug console cleared by user ═══');
    }
}

// ============================================
// DATA LOADING (Fishbowl API)
// ============================================
// Note: runQuery() and runApiRequest() are provided by Fishbowl as global functions
// We call them directly without wrappers to avoid overwriting them
function loadWorkOrders() {
    debugLog('info', 'Loading work orders from Fishbowl...');
    document.getElementById('refreshBtn').style.opacity = '0.5';

    // Check if Fishbowl API is available
    if (typeof runQuery !== 'function') {
        const errorMsg = 'This file must be opened within Fishbowl to access work order data. The Fishbowl API (runQuery) is not available.';
        debugLog('error', errorMsg);
        showToast(errorMsg, 'error', 10000);
        document.getElementById('refreshBtn').style.opacity = '1';

        // Show helpful message in UI
        const debugLogEl = document.getElementById('debugLog');
        if (debugLogEl) {
            debugLogEl.innerHTML = `
                <div class="text-amber-400 py-2">
                    <strong>[ERROR]</strong> This application must run inside Fishbowl.
                </div>
                <div class="text-slate-300 py-1 text-sm">
                    Please open this file through Fishbowl's Report module to access the database.
                </div>
            `;
        }
        return;
    }

    const woQuery = `
        SELECT
            mo.num AS mo_num,
            mo.id AS mo_id,
            wo.id AS wo_id,
            wo.num AS wo_num,
            wo.statusid AS wo_status,
            CASE wo.statusid
                WHEN 10 THEN 'Entered'
                WHEN 30 THEN 'In Progress'
                WHEN 40 THEN 'Fulfilled'
                ELSE 'Unknown'
            END AS wo_status_name,
            moitem.description AS description,
            COALESCE(bom.estimatedDuration, 0) * COALESCE(wo.qtyTarget, 0) AS estimated_duration,
            COALESCE(wo.datescheduled, moitem.datescheduled) AS date_scheduled,
            COALESCE(wo.datescheduledtostart, moitem.datescheduledtostart) AS date_scheduled_start,
            wo.datefinished AS date_finished,
            COALESCE(calcat.name, '') AS calendar_category,
            COALESCE(calcat.color, 'CCCCCC') AS category_color,
            COALESCE(calcat.id, 0) AS calcategory_id,
            wo.qtyTarget AS qty_target,
            COALESCE(bom.estimatedDuration, 0) AS bom_duration_minutes,
            bom.num AS bom_num,
            (SELECT part.num FROM woitem
             LEFT JOIN part ON woitem.partid = part.id
             WHERE woitem.woid = wo.id AND woitem.typeid = 10
             LIMIT 1) AS part_num,
            (SELECT SUM(
                CASE
                    WHEN bomitem.uomid = (SELECT id FROM uom WHERE name = 'Hour' LIMIT 1) THEN
                        COALESCE(bomitem.quantity, 0)
                    WHEN EXISTS (
                        SELECT 1 FROM uomconversion
                        WHERE fromuomid = bomitem.uomid
                        AND touomid = (SELECT id FROM uom WHERE name = 'Hour' LIMIT 1)
                    ) THEN
                        COALESCE(bomitem.quantity, 0) * (
                            SELECT (multiply / factor)
                            FROM uomconversion
                            WHERE fromuomid = bomitem.uomid
                            AND touomid = (SELECT id FROM uom WHERE name = 'Hour' LIMIT 1)
                            LIMIT 1
                        )
                    WHEN EXISTS (
                        SELECT 1 FROM uomconversion
                        WHERE fromuomid = (SELECT id FROM uom WHERE name = 'Hour' LIMIT 1)
                        AND touomid = bomitem.uomid
                    ) THEN
                        COALESCE(bomitem.quantity, 0) / (
                            SELECT (multiply / factor)
                            FROM uomconversion
                            WHERE fromuomid = (SELECT id FROM uom WHERE name = 'Hour' LIMIT 1)
                            AND touomid = bomitem.uomid
                            LIMIT 1
                        )
                    ELSE 0
                END
            )
            FROM bomitem
            INNER JOIN part ON bomitem.partid = part.id
            WHERE bomitem.bomid = bom.id
            AND part.typeid = 21) AS labor_hours_from_bom
        FROM wo
        LEFT JOIN moitem ON wo.moitemid = moitem.id
        LEFT JOIN mo ON moitem.moid = mo.id
        LEFT JOIN bom ON moitem.bomid = bom.id
        LEFT JOIN calcategory AS calcat ON wo.calcategoryid = calcat.id
        WHERE wo.num IS NOT NULL
            AND wo.statusid IN (10, 30, 40)
            AND moitem.typeid = 50
            AND mo.statusid NOT IN (60, 70, 80)
        ORDER BY mo.num, wo.num
    `;

    const depQuery = `
        SELECT DISTINCT
            wo.id AS wo_id,
            wo.num AS wo_num,
            staging_wo.id AS staging_wo_id,
            staging_wo.num AS staging_wo_num,
            COALESCE(staging_wo.datescheduled, staging_moitem.datescheduled) AS staging_wo_finish,
            COALESCE(wo.datescheduledtostart, current_moitem.datescheduledtostart) AS wo_start,
            part.num AS part_num
        FROM wo
        LEFT JOIN moitem AS current_moitem ON wo.moitemid = current_moitem.id
        LEFT JOIN mo AS current_mo ON current_moitem.moid = current_mo.id
        LEFT JOIN woitem ON woitem.woid = wo.id AND woitem.typeid = 20
        LEFT JOIN part ON woitem.partid = part.id
        LEFT JOIN woitem AS staging_woitem ON staging_woitem.partid = part.id AND staging_woitem.typeid = 10
        LEFT JOIN wo AS staging_wo ON staging_woitem.woid = staging_wo.id
        LEFT JOIN moitem AS staging_moitem ON staging_wo.moitemid = staging_moitem.id
        LEFT JOIN mo AS staging_mo ON staging_moitem.moid = staging_mo.id
        WHERE wo.num IS NOT NULL
            AND wo.statusid IN (10, 30, 40)
            AND staging_wo.num IS NOT NULL
            AND staging_wo.id != wo.id
            AND current_mo.id = staging_mo.id
            AND current_mo.statusid NOT IN (60, 70, 80)
    `;

    const moQuery = `
        SELECT DISTINCT
            mo.num AS mo_num,
            mo.id AS mo_id,
            mo.statusid AS mo_status,
            mo.datescheduled AS mo_date_scheduled,
            part.num AS part_num,
            moitem.description AS description,
            moitem.qtytofulfill AS qty,
            bom.num AS bom_num,
            so.num AS so_num,
            so.customerpo AS customer_po,
            customer.name AS customer_name
        FROM mo
        LEFT JOIN moitem ON moitem.moid = mo.id
        LEFT JOIN part ON moitem.partid = part.id
        LEFT JOIN bom ON moitem.bomid = bom.id
        LEFT JOIN soitem ON moitem.soitemid = soitem.id
        LEFT JOIN so ON soitem.soid = so.id
        LEFT JOIN customer ON so.customerid = customer.id
        WHERE moitem.typeid = 50
            AND moitem.parentid IS NULL
            AND mo.statusid NOT IN (60, 70, 80)
            AND mo.id IN (
                SELECT DISTINCT mo.id
                FROM wo
                LEFT JOIN moitem ON wo.moitemid = moitem.id
                LEFT JOIN mo ON moitem.moid = mo.id
                WHERE wo.num IS NOT NULL AND wo.statusid IN (10, 30, 40) AND mo.statusid NOT IN (60, 70, 80)
            )
        ORDER BY mo.num
    `;

    try {
        debugLog('info', 'Starting to load work orders...');

        let usingMockData = false;

        // Load WOs
        const woResults = JSON.parse(runQuery(woQuery));
        allWorkOrders = processWorkOrdersWithHours(woResults);
        debugLog('success', `Loaded ${allWorkOrders.length} work orders`);

        // Load staging dependencies
        const depResults = JSON.parse(runQuery(depQuery));
        stagingDependencies = depResults;
        debugLog('success', `Loaded ${stagingDependencies.length} staging dependencies`);

        // Load MO finished goods
        const moResults = JSON.parse(runQuery(moQuery));
        manufacturingOrders = moResults;
        debugLog('success', `Loaded ${manufacturingOrders.length} MO finished goods`);

        // Extract unique MOs and categories
        const uniqueMOs = [...new Set(allWorkOrders.map(wo => wo.mo_num))].sort();
        manufacturingOrders = uniqueMOs.map(mo => {
            const existing = manufacturingOrders.find(m => m.mo_num === mo);
            return existing || { mo_num: mo };
        });

        const catMap = new Map();
        allWorkOrders.forEach(wo => {
            const catName = wo.calendar_category || wo.category_name || 'Uncategorized';
            if (!catMap.has(catName)) {
                catMap.set(catName, {
                    id: wo.calcategory_id || 0,
                    name: catName,
                    color: wo.category_color ? '#' + wo.category_color : '#6366f1'
                });
            }
        });
        categories = Array.from(catMap.values());

        filteredWorkOrders = [...allWorkOrders];

        // Calculate initial date range from work orders
        if (allWorkOrders.length > 0) {
            const allDates = allWorkOrders.flatMap(wo => [
                moment(wo.date_scheduled_start),
                moment(wo.date_scheduled)
            ]);
            const minDate = moment.min(allDates);
            const maxDate = moment.max(allDates);

            // Add 1 week padding on each side
            ganttStartDate = minDate.clone().subtract(1, 'week').startOf('isoWeek');
            ganttEndDate = maxDate.clone().add(1, 'week').endOf('isoWeek');

            debugLog('info', `Date range: ${ganttStartDate.format('YYYY-MM-DD')} to ${ganttEndDate.format('YYYY-MM-DD')}`);
        }

        // Initialize capacity planning settings
        initializeCapacitySettings();

        // Load saved settings from database AFTER categories are initialized
        // (updateKPIs will be called by applySettings after settings are loaded)
        const settingsLoaded = loadSettingsFromDatabase();

        // If no settings were loaded, update KPIs with defaults
        if (!settingsLoaded) {
            updateKPIs();
        }

        if (!currentCapacityWeek) {
            currentCapacityWeek = moment().startOf('isoWeek');
        }

        renderCurrentView();

        // Show appropriate message based on data source
        const statusTitle = document.getElementById('systemStatusTitle');
        const statusText = document.getElementById('systemStatusText');

        if (usingMockData) {
            showToast(`⚠ Using MOCK DATA (${allWorkOrders.length} WOs) - Fishbowl not connected`, 'info', 5000);
            if (statusTitle) statusTitle.className = 'flex items-center gap-2 text-xs font-semibold mb-2 text-amber-400';
            if (statusText) statusText.textContent = 'Mock Data Mode';
        } else {
            showToast(`✓ Loaded ${allWorkOrders.length} work orders from Fishbowl`, 'success');
            if (statusTitle) statusTitle.className = 'flex items-center gap-2 text-xs font-semibold mb-2 text-emerald-400';
            if (statusText) statusText.textContent = 'Fishbowl Connected';
        }
    } catch (error) {
        debugLog('error', 'Failed to load work orders', error);
        showToast('Failed to load data: ' + error.message, 'error');
    } finally {
        document.getElementById('refreshBtn').style.opacity = '1';
    }
}

// ============================================
// DATA PROCESSING FUNCTIONS
// ============================================
function processWorkOrdersWithHours(workOrders) {
    return workOrders.map(wo => {
        const totalHours = calculateWOHours(wo);
        const dailyHours = calculateDailyHours(wo, totalHours);

        // Normalize category name
        const category_name = wo.calendar_category || 'Uncategorized';

        return {
            ...wo,
            category_name: category_name,
            total_hours: totalHours,
            daily_hours: dailyHours,
            date_range_days: moment(wo.date_scheduled).diff(
                moment(wo.date_scheduled_start),
                'days'
            ) + 1
        };
    });
}

function calculateWOHours(wo) {
    let totalHours = 0;

    // Priority 1: BOM estimated duration (convert minutes to hours)
    if (wo.bom_duration_minutes && wo.bom_duration_minutes > 0) {
        totalHours = (wo.bom_duration_minutes / 60) * wo.qty_target;
        debugLog('info', `WO ${wo.wo_num}: Using BOM duration ${wo.bom_duration_minutes}min * ${wo.qty_target}qty = ${totalHours.toFixed(2)}hrs`);
    }
    // Priority 2: Labor hours from BOM parts (already in hours)
    else if (wo.labor_hours_from_bom && wo.labor_hours_from_bom > 0) {
        totalHours = wo.labor_hours_from_bom * wo.qty_target;
        debugLog('info', `WO ${wo.wo_num}: Using labor parts ${wo.labor_hours_from_bom}hrs * ${wo.qty_target}qty = ${totalHours.toFixed(2)}hrs`);
    }
    // Priority 3: Default fallback (1 hour per day)
    else {
        const dateRange = moment(wo.date_scheduled).diff(
            moment(wo.date_scheduled_start),
            'days'
        ) + 1;
        totalHours = Math.max(1, dateRange) * 1; // 1 hour per day, minimum 1 hour
        debugLog('warn', `WO ${wo.wo_num}: No BOM data found, using fallback ${totalHours}hrs (1hr/day * ${dateRange}days)`);
    }

    return Math.max(0, totalHours); // Ensure non-negative
}

function calculateDailyHours(wo, totalHours) {
    const startDate = moment(wo.date_scheduled_start);
    const endDate = moment(wo.date_scheduled);
    const days = endDate.diff(startDate, 'days') + 1;

    if (days <= 0) return [];

    const hoursPerDay = totalHours / days;
    const dailyHours = [];

    for (let i = 0; i < days; i++) {
        const currentDate = startDate.clone().add(i, 'days');
        dailyHours.push({
            date: currentDate.format('YYYY-MM-DD'),
            hours: hoursPerDay
        });
    }

    return dailyHours;
}

// ============================================
// SAVE WO DATES
// ============================================
function scrollToWO(woNum) {
    // Scroll to and highlight a specific WO in the gantt chart
    const woBar = document.querySelector(`[data-wo-num="${woNum}"]`);

    if (woBar) {
        const ganttWrapper = document.getElementById('ganttWrapper');
        if (!ganttWrapper) return;

        // Get the WO bar position relative to the SVG
        const barRect = woBar.getBoundingClientRect();
        const wrapperRect = ganttWrapper.getBoundingClientRect();

        // Calculate the scroll position to center the WO
        const scrollTop = ganttWrapper.scrollTop + (barRect.top - wrapperRect.top) - (wrapperRect.height / 2) + (barRect.height / 2);
        const scrollLeft = ganttWrapper.scrollLeft + (barRect.left - wrapperRect.left) - (wrapperRect.width / 2) + (barRect.width / 2);

        // Smooth scroll to the WO
        ganttWrapper.scrollTo({
            top: scrollTop,
            left: scrollLeft,
            behavior: 'smooth'
        });

        // Briefly highlight the WO
        const originalStroke = woBar.getAttribute('stroke');
        const originalStrokeWidth = woBar.getAttribute('stroke-width');

        woBar.setAttribute('stroke', '#fbbf24');
        woBar.setAttribute('stroke-width', '4');

        setTimeout(() => {
            woBar.setAttribute('stroke', originalStroke || 'none');
            woBar.setAttribute('stroke-width', originalStrokeWidth || '1');
        }, 2000);

        debugLog('info', `Scrolled to WO ${woNum}`);
    } else {
        debugLog('warn', `Could not find WO ${woNum} in gantt chart`);
    }
}

async function saveWOCategory(woNum, newCategoryId) {
    debugLog('info', `Saving WO ${woNum} category to ${newCategoryId}`);

    try {
        // Get the full WO record from Fishbowl
        const woRequest = {
            GetWorkOrderRq: {
                WorkOrderNumber: woNum
            }
        };

        const woResponse = JSON.parse(runApiRequest('GetWorkOrderRq', JSON.stringify(woRequest)));

        if (woResponse.GetWorkOrderRs && woResponse.GetWorkOrderRs.statusCode === 1000 && woResponse.GetWorkOrderRs.WO) {
            const wo = woResponse.GetWorkOrderRs.WO;

            // Update the calendar category ID
            wo.CalCategoryID = newCategoryId;

            // Save the updated WO
            const saveRequest = {
                SaveWorkOrderRq: {
                    WO: wo
                }
            };

            const saveResponse = JSON.parse(runApiRequest('SaveWorkOrderRq', JSON.stringify(saveRequest)));

            if (saveResponse.SaveWorkOrderRs && saveResponse.SaveWorkOrderRs.statusCode === 1000) {
                debugLog('success', `WO ${woNum} category updated successfully`);
                showToast(`WO ${woNum} category updated successfully`, 'success');
                return true;
            } else {
                const errorMsg = saveResponse.SaveWorkOrderRs ? saveResponse.SaveWorkOrderRs.statusMessage : 'Unknown error';
                throw new Error('Failed to save WO: ' + errorMsg);
            }
        } else {
            const errorMsg = woResponse.GetWorkOrderRs ? woResponse.GetWorkOrderRs.statusMessage : 'Failed to retrieve WO';
            throw new Error('Failed to get WO: ' + errorMsg);
        }
    } catch (error) {
        debugLog('error', `Failed to save WO ${woNum} category`, error);
        showToast(`Failed to save WO category: ${error.message}`, 'error', 5000);
        return false;
    }
}

async function saveWODates(woNum, newStartDate, newEndDate) {
    debugLog('info', `Saving WO ${woNum} dates: ${newStartDate} to ${newEndDate}`);

    try {
        // Get the full WO record from Fishbowl
        const woRequest = {
            GetWorkOrderRq: {
                WorkOrderNumber: woNum
            }
        };

        const woResponse = JSON.parse(runApiRequest('GetWorkOrderRq', JSON.stringify(woRequest)));

        if (woResponse.GetWorkOrderRs && woResponse.GetWorkOrderRs.statusCode === 1000 && woResponse.GetWorkOrderRs.WO) {
            const wo = woResponse.GetWorkOrderRs.WO;

            // Parse original dates to preserve time component
            const originalStart = moment(wo.DateScheduledToStart);
            const originalEnd = moment(wo.DateScheduled);

            // Create new date moments, preserving original time
            const newStartMoment = moment(newStartDate).hour(originalStart.hour()).minute(originalStart.minute()).second(originalStart.second());
            const newEndMoment = moment(newEndDate).hour(originalEnd.hour()).minute(originalEnd.minute()).second(originalEnd.second());

            // Update the dates with time preserved
            wo.DateScheduledToStart = newStartMoment.format('YYYY-MM-DD[T]HH:mm:ss');
            wo.DateScheduled = newEndMoment.format('YYYY-MM-DD[T]HH:mm:ss');

            // Also update WO items if they exist
            if (wo.WOItems && wo.WOItems.WOItem) {
                const items = Array.isArray(wo.WOItems.WOItem) ? wo.WOItems.WOItem : [wo.WOItems.WOItem];
                items.forEach(item => {
                    if (item.DateScheduled) {
                        const originalItemDate = moment(item.DateScheduled);
                        const newItemMoment = moment(newStartDate).hour(originalItemDate.hour()).minute(originalItemDate.minute()).second(originalItemDate.second());
                        item.DateScheduled = newItemMoment.format('YYYY-MM-DD[T]HH:mm:ss');
                    }
                });
            }

            // Save the updated WO
            const saveRequest = {
                SaveWorkOrderRq: {
                    WO: wo
                }
            };

            const saveResponse = JSON.parse(runApiRequest('SaveWorkOrderRq', JSON.stringify(saveRequest)));

            if (saveResponse.SaveWorkOrderRs && saveResponse.SaveWorkOrderRs.statusCode === 1000) {
                debugLog('success', `WO ${woNum} updated successfully`);
                showToast(`WO ${woNum} dates updated successfully`, 'success');

                // Save current scroll position
                const ganttWrapper = document.getElementById('ganttWrapper');
                const savedScrollLeft = ganttWrapper ? ganttWrapper.scrollLeft : 0;
                const savedScrollTop = ganttWrapper ? ganttWrapper.scrollTop : 0;

                // Set flag to skip auto-scroll on next render
                window.skipAutoScroll = true;

                // Reload data to reflect changes
                loadWorkOrders();

                // Restore scroll position after render
                setTimeout(() => {
                    if (ganttWrapper) {
                        ganttWrapper.scrollLeft = savedScrollLeft;
                        ganttWrapper.scrollTop = savedScrollTop;
                    }
                    window.skipAutoScroll = false;
                }, 150);

                return true;
            } else {
                const errorMsg = saveResponse.SaveWorkOrderRs ? saveResponse.SaveWorkOrderRs.statusMessage : 'Unknown error';
                throw new Error('Failed to save WO: ' + errorMsg);
            }
        } else {
            const errorMsg = woResponse.GetWorkOrderRs ? woResponse.GetWorkOrderRs.statusMessage : 'Failed to retrieve WO';
            throw new Error('Failed to get WO: ' + errorMsg);
        }
    } catch (error) {
        debugLog('error', `Failed to save WO ${woNum}`, error);
        showToast(`Failed to save WO: ${error.message}`, 'error', 5000);
        return false;
    }
}

function generateMockData() {
    const statuses = [
        { id: 10, name: 'Entered' },
        { id: 30, name: 'In Progress' },
        { id: 40, name: 'Fulfilled' }
    ];

    const categories = [
        { name: 'Fabrication', color: '#3b82f6' },
        { name: 'Machining', color: '#10b981' },
        { name: 'Assembly', color: '#f59e0b' },
        { name: 'Quality Control', color: '#8b5cf6' }
    ];

    const mockWOs = [];
    const today = moment();

    for (let i = 1; i <= 20; i++) {
        const mo = `MO-${1000 + Math.floor(i / 3)}`;
        const cat = categories[i % categories.length];
        const status = statuses[i % statuses.length];
        const startOffset = Math.floor(i / 2) - 5;
        const duration = 2 + (i % 4);

        mockWOs.push({
            wo_id: i,
            wo_num: `WO-${2000 + i}`,
            wo_status: status.id,
            wo_status_name: status.name,
            date_scheduled_start: today.clone().add(startOffset, 'days').format('YYYY-MM-DD[T]08:00:00'),
            date_scheduled: today.clone().add(startOffset + duration, 'days').format('YYYY-MM-DD[T]17:00:00'),
            date_finished: status.id === 40 ? today.clone().add(startOffset + duration - 1, 'days').format('YYYY-MM-DD[T]15:00:00') : null,
            mo_num: mo,
            mo_date_scheduled: today.clone().add(startOffset + duration + 2, 'days').format('YYYY-MM-DD[T]17:00:00'),
            category_name: cat.name,
            category_color: cat.color,
            qty_target: 100
        });
    }

    return mockWOs;
}

// ============================================
// KPI DASHBOARD
// ============================================
function updateKPIs() {
    const container = document.getElementById('kpiCards');

    const startedWOs = filteredWorkOrders.filter(wo => wo.wo_status === 30).length;
    const enteredWOs = filteredWorkOrders.filter(wo => wo.wo_status === 10).length;
    const fulfilledWOs = filteredWorkOrders.filter(wo => wo.wo_status === 40).length;
    const totalWOs = filteredWorkOrders.length;

    // Calculate dependency conflicts (WOs that start before their dependencies are fulfilled)
    let dependencyConflicts = 0;
    let stagingConflicts = 0;
    let sameDayConflicts = 0;
    const stagingIssueMOs = new Map(); // Track conflict count per MO number

    debugLog('info', `Checking ${stagingDependencies.length} staging dependencies, allowSameDayStarts=${allowSameDayStarts}`);

    // Check staging dependencies
    stagingDependencies.forEach(dep => {
        const dependentWO = filteredWorkOrders.find(wo => wo.wo_id === dep.wo_id);
        const stagingWO = filteredWorkOrders.find(wo => wo.wo_id === dep.staging_wo_id);

        if (dependentWO && stagingWO) {
            const dependentStart = moment(dependentWO.date_scheduled_start).startOf('day');
            const stagingEnd = moment(stagingWO.date_scheduled).startOf('day');

            // Conflict logic matching arrow rendering
            let isConflict;
            if (allowSameDayStarts) {
                // Allow same-day: only conflict if staging finishes AFTER dependent starts
                isConflict = stagingEnd.isAfter(dependentStart);
            } else {
                // Don't allow same-day: conflict if staging finishes on or after dependent starts
                isConflict = stagingEnd.isSameOrAfter(dependentStart);
            }

            if (isConflict) {
                stagingConflicts++;
                dependencyConflicts++;
                // Count conflicts per MO
                const moNum = dependentWO.mo_num;
                stagingIssueMOs.set(moNum, (stagingIssueMOs.get(moNum) || 0) + 1);
                debugLog('warn', `Staging dependency conflict: ${stagingWO.wo_num} ends ${stagingEnd.format('YYYY-MM-DD')} vs ${dependentWO.wo_num} starts ${dependentStart.format('YYYY-MM-DD')}`);
            }
        }
    });

    // Also check same-day starts in same MO if setting is disabled
    if (!allowSameDayStarts) {
        const moGroups = {};
        filteredWorkOrders.forEach(wo => {
            if (!moGroups[wo.mo_num]) moGroups[wo.mo_num] = [];
            moGroups[wo.mo_num].push(wo);
        });

        Object.values(moGroups).forEach(wos => {
            if (wos.length > 1) {
                const startDates = {};
                wos.forEach(wo => {
                    const startDate = moment(wo.date_scheduled_start).format('YYYY-MM-DD');
                    if (startDates[startDate]) {
                        sameDayConflicts++;
                        dependencyConflicts++;
                        const moNum = wo.mo_num;
                        stagingIssueMOs.set(moNum, (stagingIssueMOs.get(moNum) || 0) + 1);
                        debugLog('warn', `Same-day start conflict in MO: ${wo.wo_num} starts ${startDate}`);
                    } else {
                        startDates[startDate] = true;
                    }
                });
            }
        });
    }

    debugLog('info', `Dependency conflicts breakdown: ${stagingConflicts} from staging deps, ${sameDayConflicts} from same-day MO starts, total=${dependencyConflicts}`);

    // Calculate capacity issues (count each category-day combination that exceeds capacity)
    let capacityIssues = 0;
    const daysToCheck = 90;
    const today = moment();
    const categoryDaysWithIssues = new Set();
    const capacityIssueDetails = []; // Track category-date pairs with usage/capacity for tooltip

    debugLog('info', `Checking capacity for ${capacitySettings.categories.length} categories over ${daysToCheck} days`);

    for (let i = 0; i < daysToCheck; i++) {
        const checkDay = today.clone().add(i, 'days');

        capacitySettings.categories.forEach(cat => {
            const dayOfWeek = checkDay.isoWeekday() - 1;
            const capacity = cat.limits[dayOfWeek];

            if (capacity > 0) {
                const { usage } = getUsageForCategoryAndDay(cat.id, checkDay);

                // Debug: Log when usage is significant
                if (usage > 0) {
                    debugLog('debug', `${checkDay.format('YYYY-MM-DD')} - Category ${cat.name}: usage=${usage.toFixed(2)}hrs, capacity=${capacity}hrs`);
                }

                // If this category exceeds capacity on this day, count it as a separate issue
                if (usage > capacity) {
                    const issueKey = `${cat.id}-${checkDay.format('YYYY-MM-DD')}`;
                    if (!categoryDaysWithIssues.has(issueKey)) {
                        categoryDaysWithIssues.add(issueKey);
                        capacityIssues++;
                        // Track details for tooltip
                        capacityIssueDetails.push({
                            category: cat.name,
                            date: checkDay.format('YYYY-MM-DD'),
                            usage: usage,
                            capacity: capacity
                        });
                        debugLog('warn', `Capacity issue on ${checkDay.format('YYYY-MM-DD')}: ${cat.name} has ${usage.toFixed(2)}hrs usage but only ${capacity}hrs capacity`);
                    }
                }
            }
        });
    }

    debugLog('info', `Total capacity issues found: ${capacityIssues}`);
    debugLog('info', `Total dependency conflicts found: ${dependencyConflicts}`);
    debugLog('info', `KPI Summary - Dependency Conflicts: ${dependencyConflicts}, Capacity Issues: ${capacityIssues}`);

    // Check for WOs with missing or low labor hours
    const wosWithNoLabor = filteredWorkOrders.filter(wo => !wo.labor_hours_from_bom || parseFloat(wo.labor_hours_from_bom) === 0);
    const wosWithLowLabor = filteredWorkOrders.filter(wo => {
        const hours = parseFloat(wo.labor_hours_from_bom) || 0;
        return hours > 0 && hours < 2; // Less than 2 hours total seems suspiciously low
    });

    if (wosWithNoLabor.length > 0) {
        debugLog('warn', `⚠️ ${wosWithNoLabor.length} WO(s) have NO labor hours: ${wosWithNoLabor.map(wo => wo.wo_num).join(', ')}`);
    }
    if (wosWithLowLabor.length > 0) {
        debugLog('warn', `⚠️ ${wosWithLowLabor.length} WO(s) have suspiciously LOW labor hours (<2hrs): ${wosWithLowLabor.map(wo => `${wo.wo_num}(${wo.labor_hours_from_bom}hrs)`).join(', ')}`);
    }

    const kpis = [
        {
            title: 'Entered WOs',
            value: enteredWOs,
            color: 'blue', // Match WO status 10 color (#2d9cdb)
            icon: `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>`
        },
        {
            title: 'Started WOs',
            value: startedWOs,
            color: 'orange', // Match WO status 30 color (#FF8C42)
            icon: `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>`
        },
        {
            title: 'Fulfilled WOs',
            value: fulfilledWOs,
            color: 'green', // Match WO status 40 color (#10B981)
            icon: `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>`
        },
        {
            title: 'Total WOs',
            value: totalWOs,
            color: 'slate',
            icon: `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path>`
        },
        {
            title: 'Staging Issues',
            value: dependencyConflicts,
            color: 'rose',
            icon: `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>`,
            tooltipHTML: stagingIssueMOs.size > 0
                ? '<div style="font-weight: 600; margin-bottom: 0.5rem;">MO Numbers with Conflicts:</div>' +
                  '<div style="color: #ffffff;">' +
                  Array.from(stagingIssueMOs.keys())
                      .sort((a, b) => a - b)
                      .map(moNum => `MO ${moNum}`)
                      .join(', ') +
                  '</div>'
                : null
        },
        {
            title: 'Capacity Issues',
            value: capacityIssues,
            color: 'amber', // Changed from orange to amber to avoid confusion with Started WOs
            icon: `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 17h8m0 0V9m0 8l-8-8-4 4-6-6"></path>`,
            tooltipHTML: capacityIssueDetails.length > 0
                ? '<div style="font-weight: 600; margin-bottom: 0.5rem;">Capacity Overages:</div>' +
                  capacityIssueDetails
                    .sort((a, b) => a.date.localeCompare(b.date) || a.category.localeCompare(b.category))
                    .map(issue => {
                        const dateStr = moment(issue.date).format('MMM DD');
                        const usageStr = issue.usage ? `${issue.usage.toFixed(1)}h` : 'N/A';
                        const capacityStr = issue.capacity ? `${issue.capacity}h` : 'N/A';
                        return `<div><span class="wo-tooltip-label">${dateStr} - ${issue.category}:</span><span class="wo-tooltip-value">${usageStr}/${capacityStr}</span></div>`;
                    })
                    .join('')
                : null
        }
    ];

    const colorClasses = {
        blue: 'bg-blue-100 text-blue-700',        // WO status 10 (Entered) - darker for visibility
        orange: 'bg-orange-100 text-orange-700',  // WO status 30 (Started) - darker for visibility
        green: 'bg-green-100 text-green-700',     // WO status 40 (Fulfilled) - darker for visibility
        amber: 'bg-amber-100 text-amber-700',
        slate: 'bg-slate-100 text-slate-700',
        rose: 'bg-rose-100 text-rose-700'
    };

    container.innerHTML = kpis.map(kpi => `
        <div class="kpi-tile bg-white rounded-md px-2 py-1.5 shadow-sm border border-slate-300 flex flex-col gap-1 flex-1 min-w-0">
            <p class="text-slate-600 text-[10px] font-bold uppercase tracking-wide truncate">${kpi.title}</p>
            <div class="flex items-center gap-1.5">
                <div class="${colorClasses[kpi.color]} p-1 rounded flex-shrink-0">
                    <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        ${kpi.icon}
                    </svg>
                </div>
                <h3 class="text-lg font-bold text-slate-800">${kpi.value}</h3>
            </div>
        </div>
    `).join('');

    // Add event handlers for tooltips
    kpis.forEach((kpi, index) => {
        if (kpi.tooltipHTML) {
            const tile = container.querySelectorAll('.kpi-tile')[index];
            if (tile) {
                tile.style.cursor = 'pointer';
                tile.addEventListener('mouseover', (e) => showWOTooltip(e, kpi.tooltipHTML));
                tile.addEventListener('mouseout', () => hideWOTooltip());
                tile.addEventListener('mousemove', (e) => showWOTooltip(e, kpi.tooltipHTML));
            }
        }
    });
}

// ============================================
// VIEW SWITCHING
// ============================================
function switchView(mode) {
    viewMode = mode;

    // Update view switcher buttons
    const moBtn = document.getElementById('view-btn-mo');
    const capacityBtn = document.getElementById('view-btn-capacity');

    // Reset both buttons
    [moBtn, capacityBtn].forEach(btn => {
        btn.classList.remove('bg-white', 'text-indigo-600', 'shadow-sm');
        btn.classList.add('text-slate-400', 'hover:text-slate-600');
    });

    // Activate the appropriate button based on mode
    if (mode === 'mo' || mode === 'category') {
        moBtn.classList.remove('text-slate-400', 'hover:text-slate-600');
        moBtn.classList.add('bg-white', 'text-indigo-600', 'shadow-sm');
    } else if (mode === 'capacity') {
        capacityBtn.classList.remove('text-slate-400', 'hover:text-slate-600');
        capacityBtn.classList.add('bg-white', 'text-indigo-600', 'shadow-sm');
    }

    // Update view title
    const titles = {
        mo: 'Gantt View',
        category: 'Category View',
        capacity: 'Capacity'
    };
    document.getElementById('viewTitle').textContent = titles[mode];

    // Show/hide appropriate containers
    if (mode === 'capacity') {
        document.getElementById('ganttContainer').style.display = 'none';
        document.getElementById('capacityContainer').style.display = 'block';

        if (!currentCapacityWeek) {
            currentCapacityWeek = moment().startOf('isoWeek');
        }
        buildCapacityTable(currentCapacityWeek);
        buildMonthCalendar(); // Always build calendar when switching to capacity view
    } else {
        document.getElementById('ganttContainer').style.display = 'block';
        document.getElementById('capacityContainer').style.display = 'none';

        renderGanttChart();
    }
}

function renderCurrentView() {
    if (viewMode === 'capacity') {
        if (currentCapacityWeek) {
            buildCapacityTable(currentCapacityWeek);
        }
        buildMonthCalendar(); // Rebuild calendar when data updates
    } else {
        renderGanttChart();
    }
}

// ============================================
// WO PACKING FOR CATEGORY VIEW
// ============================================
function packWOsIntoLanes(wos) {
    // Sort WOs by start date
    const sortedWOs = [...wos].sort((a, b) =>
        moment(a.date_scheduled_start).valueOf() - moment(b.date_scheduled_start).valueOf()
    );

    const lanes = [];

    sortedWOs.forEach(wo => {
        // Use full day spans for overlap detection (matching rendering logic)
        const woStart = moment(wo.date_scheduled_start).startOf('day');
        const woEnd = moment(wo.date_scheduled).endOf('day');

        // Find first lane where this WO doesn't overlap
        let placed = false;
        for (let i = 0; i < lanes.length; i++) {
            const lane = lanes[i];
            const overlaps = lane.some(existingWO => {
                const existingStart = moment(existingWO.date_scheduled_start).startOf('day');
                const existingEnd = moment(existingWO.date_scheduled).endOf('day');
                return woStart.isBefore(existingEnd) && woEnd.isAfter(existingStart);
            });

            if (!overlaps) {
                lane.push(wo);
                wo._lane = i; // Store lane index on WO object
                placed = true;
                break;
            }
        }

        // If no suitable lane found, create new lane
        if (!placed) {
            wo._lane = lanes.length;
            lanes.push([wo]);
        }
    });

    return lanes.length; // Return number of lanes needed
}

// ============================================
// TOPOLOGICAL SORT FOR WO ORDERING
// ============================================
function sortWOsByDependencies(wos) {
    // Build dependency graph from staging relationships
    // If WO A produces a part used in WO B, then A should come before B

    const woMap = new Map(wos.map(wo => [wo.wo_id, wo]));
    const dependencies = new Map(); // wo_id -> array of wo_ids it depends on
    const dependents = new Map(); // wo_id -> array of wo_ids that depend on it

    // Initialize maps
    wos.forEach(wo => {
        dependencies.set(wo.wo_id, []);
        dependents.set(wo.wo_id, []);
    });

    // Build dependency graph from staging relationships
    stagingDependencies.forEach(dep => {
        // dep.staging_wo_id produces a part that dep.wo_id consumes
        // So dep.wo_id depends on dep.staging_wo_id
        if (woMap.has(dep.wo_id) && woMap.has(dep.staging_wo_id)) {
            dependencies.get(dep.wo_id).push(dep.staging_wo_id);
            dependents.get(dep.staging_wo_id).push(dep.wo_id);
        }
    });

    // Topological sort using Kahn's algorithm
    const sorted = [];
    const inDegree = new Map();

    wos.forEach(wo => {
        inDegree.set(wo.wo_id, dependencies.get(wo.wo_id).length);
    });

    // Start with WOs that have no dependencies
    const queue = wos.filter(wo => inDegree.get(wo.wo_id) === 0);

    while (queue.length > 0) {
        // Sort queue by WO number to maintain stable sort for WOs at same level
        queue.sort((a, b) => a.wo_num.localeCompare(b.wo_num));

        const wo = queue.shift();
        sorted.push(wo);

        // Reduce in-degree for dependent WOs
        const deps = dependents.get(wo.wo_id) || [];
        deps.forEach(depWoId => {
            inDegree.set(depWoId, inDegree.get(depWoId) - 1);
            if (inDegree.get(depWoId) === 0) {
                queue.push(woMap.get(depWoId));
            }
        });
    }

    // If there are cycles or orphaned WOs, append them sorted by WO number
    const remaining = wos.filter(wo => !sorted.includes(wo));
    if (remaining.length > 0) {
        remaining.sort((a, b) => a.wo_num.localeCompare(b.wo_num));
        sorted.push(...remaining);
    }

    return sorted;
}

// ============================================
// SKIP WEEKENDS HELPER
// ============================================
function applySkipWeekends(date) {
    if (!skipWeekends) {
        return date;
    }

    const m = moment(date);
    const dayOfWeek = m.day();
    const originalDate = m.format('YYYY-MM-DD');

    // If Saturday (6), move to Monday (+2 days)
    if (dayOfWeek === 6) {
        const newDate = m.add(2, 'days').toDate();
        debugLog('info', `Skip weekends: ${originalDate} (Sat) → ${moment(newDate).format('YYYY-MM-DD')} (Mon)`);
        return newDate;
    }
    // If Sunday (0), move to Monday (+1 day)
    if (dayOfWeek === 0) {
        const newDate = m.add(1, 'day').toDate();
        debugLog('info', `Skip weekends: ${originalDate} (Sun) → ${moment(newDate).format('YYYY-MM-DD')} (Mon)`);
        return newDate;
    }

    return date;
}

function countWeekdaysInRange(startDate, endDate) {
    // Count weekdays (Mon-Fri) in inclusive date range
    let count = 0;
    let current = startDate.clone();

    while (current.isSameOrBefore(endDate)) {
        const dayOfWeek = current.day();
        // 1=Mon, 2=Tue, 3=Wed, 4=Thu, 5=Fri
        if (dayOfWeek >= 1 && dayOfWeek <= 5) {
            count++;
        }
        current.add(1, 'day');
    }

    return count;
}

// ============================================
// CUSTOM D3 GANTT CHART
// ============================================
function renderGanttChart() {
    debugLog('info', `Rendering ${viewMode} Gantt chart...`);

    // Clear conflicts
    conflicts.clear();

    // Apply status filter (multi-select)
    let displayedWorkOrders = filteredWorkOrders;
    if (activeStatusFilters.size > 0 && activeStatusFilters.size < 4) {
        // Only filter if not all statuses are selected
        displayedWorkOrders = filteredWorkOrders.filter(wo => {
            // Check if WO status matches any selected filter
            const statusMatch = activeStatusFilters.has(String(wo.wo_status));

            // Check if conflicts filter is active
            if (activeStatusFilters.has('conflict')) {
                const conflictWOIds = new Set();
                stagingDependencies.forEach(dep => {
                    conflictWOIds.add(dep.wo_id);
                    conflictWOIds.add(dep.staging_wo_id);
                });
                if (conflictWOIds.has(wo.wo_id)) {
                    return true;
                }
            }

            return statusMatch;
        });
        debugLog('info', `Status filters active: ${Array.from(activeStatusFilters).join(', ')}, showing ${displayedWorkOrders.length}/${filteredWorkOrders.length} WOs`);
    }

    const svg = d3.select('#ganttSvg');
    svg.selectAll('*').remove();

    if (displayedWorkOrders.length === 0) {
        svg.append('text')
            .attr('x', '50%')
            .attr('y', 100)
            .attr('text-anchor', 'middle')
            .attr('class', 'text-slate-400 text-sm')
            .text('No work orders to display');
        return;
    }

    // Dimensions
    const margin = { top: 110, right: 40, bottom: 40, left: 200 }; // Increased top margin for date headers
    const dayWidth = ganttScale;
    const days = moment(ganttEndDate).diff(ganttStartDate, 'days') + 1;
    const width = days * dayWidth + margin.left + margin.right;
    const rowHeight = 25; // Reduced to minimize space around 20px tiles

    // Build groups based on view mode
    let groups = [];
    if (viewMode === 'mo') {
        // Hierarchical view: Each MO gets a header row + WO child rows
        const moNums = [...new Set(displayedWorkOrders.map(wo => wo.mo_num))].sort((a, b) => a - b);

        moNums.forEach(moNum => {
            const moWOs = displayedWorkOrders.filter(wo => wo.mo_num === moNum);

            // Sort WOs by staging dependencies for natural workflow order
            const sortedMoWOs = sortWOsByDependencies(moWOs);

            const moData = manufacturingOrders.find(mo => mo.mo_num === moNum);
            const bomInfo = moData ? `${moData.bom_num || 'N/A'} x ${moData.qty || '?'}` : '';

            // Add MO header row
            groups.push({
                id: `mo_${moNum}`,
                name: `MO ${moNum} (${bomInfo})`,
                type: 'mo-header',
                moNum: moNum,
                wos: sortedMoWOs,
                isCollapsed: collapsedMOs.has(moNum)
            });

            // Add WO rows (if expanded)
            if (!collapsedMOs.has(moNum)) {
                sortedMoWOs.forEach((wo, idx) => {
                    groups.push({
                        id: `mo_${moNum}_wo_${idx}`,
                        name: `  WO ${wo.wo_num}`,
                        type: 'wo-row',
                        moNum: moNum,
                        wos: [wo]
                    });
                });
            }
        });

        debugLog('info', `MO view: ${moNums.length} MOs, ${groups.filter(g => g.type === 'wo-row').length} WO rows visible`);
    } else {
        // Category view - group by category_name with lane packing for overlapping WOs
        const catNames = [...new Set(displayedWorkOrders.map(wo => wo.category_name))].sort();
        groups = catNames.map(cat => {
            const wo = displayedWorkOrders.find(wo => wo.category_name === cat);
            const categoryWOs = displayedWorkOrders.filter(wo => wo.category_name === cat);
            const laneCount = packWOsIntoLanes(categoryWOs);

            return {
                id: cat,
                name: cat,
                color: wo?.category_color ? '#' + wo.category_color : '#94a3b8',
                wos: categoryWOs,
                laneCount: laneCount // Number of lanes needed for stacking
            };
        });
        debugLog('info', `Category view: ${groups.length} categories, ${groups.map(g => `${g.name}(${g.wos.length} WOs, ${g.laneCount} lanes)`).join(', ')}`);
    }

    // Calculate total height based on lane counts
    const totalHeight = groups.reduce((sum, g) => {
        const groupHeight = g.laneCount ? g.laneCount * 35 + 15 : rowHeight; // 35px per lane + 15px padding
        return sum + groupHeight;
    }, 0);
    const height = totalHeight + margin.top + margin.bottom;

    svg.attr('width', width).attr('height', height);

    // Scales
    const xScale = d3.scaleTime()
        .domain([ganttStartDate.toDate(), ganttEndDate.toDate()])
        .range([margin.left, width - margin.right]);

    // Custom yScale for variable-height rows (category view uses lanes)
    const yPositions = new Map();
    const yHeights = new Map();
    let currentY = margin.top;

    groups.forEach(g => {
        yPositions.set(g.id, currentY);
        const groupHeight = g.laneCount ? g.laneCount * 40 + 15 : rowHeight; // Match capacity planning lane height (40px)
        yHeights.set(g.id, groupHeight);
        currentY += groupHeight;
    });

    // yScale function that returns position
    const yScale = (id) => yPositions.get(id) || 0;
    yScale.bandwidth = (id) => yHeights.get(id) || rowHeight;

    // Grid lines only (weekends rendered later)
    const gridGroup = svg.append('g').attr('class', 'grid');
    let currentDay = ganttStartDate.clone();
    while (currentDay.isSameOrBefore(ganttEndDate)) {
        const dayX = xScale(currentDay.toDate());
        const isMonday = currentDay.day() === 1; // ISO week starts on Monday

        // Grid line - thicker for week starts (Mondays), darker for better visibility
        gridGroup.append('line')
            .attr('x1', dayX)
            .attr('x2', dayX)
            .attr('y1', margin.top)
            .attr('y2', height - margin.bottom)
            .attr('stroke', isMonday ? '#64748b' : '#cbd5e1') // slate-500 for Mondays, slate-300 for others (darker)
            .attr('stroke-width', isMonday ? 2 : 1.5)
            .attr('opacity', 1);

        currentDay.add(1, 'day');
    }

    // Row backgrounds with borders
    svg.selectAll('.row-bg')
        .data(groups)
        .enter()
        .append('rect')
        .attr('class', 'row-bg')
        .attr('x', margin.left)
        .attr('y', d => yScale(d.id))
        .attr('width', width - margin.left - margin.right)
        .attr('height', d => yScale.bandwidth(d.id))
        .attr('fill', viewMode === 'category' ? d => d.color || '#6366f1' : (d, i) => i % 2 === 0 ? '#ffffff' : '#f8fafc')
        .attr('fill-opacity', viewMode === 'category' ? 0.2 : 1)
        .attr('stroke', '#cbd5e1')  // slate-300 for darker row borders
        .attr('stroke-width', 1.5)
        .attr('rx', 4);

    // Weekend highlighting (after row backgrounds to show on top) - matching capacity planning style
    const weekendGroup = svg.append('g').attr('class', 'weekends');
    currentDay = ganttStartDate.clone();
    while (currentDay.isSameOrBefore(ganttEndDate)) {
        if (currentDay.day() === 0 || currentDay.day() === 6) {
            const dayX = xScale(currentDay.toDate());
            weekendGroup.append('rect')
                .attr('x', dayX)
                .attr('y', margin.top)
                .attr('width', dayWidth)
                .attr('height', height - margin.top - margin.bottom)
                .attr('fill', '#fffbeb')  // amber-50 to match capacity planning
                .attr('opacity', 0.5)
                .attr('stroke', '#cbd5e1')  // Add visible borders to weekend columns
                .attr('stroke-width', 1.5)
                .attr('pointer-events', 'none');
        }
        currentDay.add(1, 'day');
    }

    // Today marker (drawn after weekends, before MO/WO bars)
    const todayX = xScale(moment().toDate());
    if (todayX >= margin.left && todayX <= width - margin.right) {
        svg.append('line')
            .attr('x1', todayX)
            .attr('x2', todayX)
            .attr('y1', margin.top)
            .attr('y2', height - margin.bottom)
            .attr('stroke', '#ef4444')
            .attr('stroke-width', 2)
            .attr('stroke-dasharray', '5,5')
            .attr('opacity', 0.7);
    }

    // Group labels with colored backgrounds for category view
    if (viewMode === 'category') {
        svg.selectAll('.group-label-bg')
            .data(groups)
            .enter()
            .append('rect')
            .attr('class', 'group-label-bg')
            .attr('x', 0)
            .attr('y', d => yScale(d.id))
            .attr('width', margin.left - 15)
            .attr('height', d => yScale.bandwidth(d.id))
            .attr('fill', d => d.color || '#6366f1')
            .attr('fill-opacity', 0.15)
            .attr('stroke', d => d.color || '#6366f1')
            .attr('stroke-width', 2)
            .attr('rx', 4);
    }

    // Group labels - use HTML overlay for both category and MO views
    const labelsOverlay = document.getElementById('categoryLabelsOverlay');
    if (viewMode === 'category' || viewMode === 'mo') {
        labelsOverlay.style.display = 'block';
        labelsOverlay.style.height = `${height}px`;
        labelsOverlay.innerHTML = '';

        groups.forEach(group => {
            const labelDiv = document.createElement('div');

            if (viewMode === 'category') {
                // Category view labels
                labelDiv.style.cssText = `
                    position: absolute;
                    top: ${yScale(group.id)}px;
                    left: 0;
                    width: 185px;
                    height: ${yScale.bandwidth(group.id)}px;
                    display: flex;
                    align-items: center;
                    justify-content: flex-end;
                    padding-right: 10px;
                    background: ${group.color}26;
                    border: 2px solid ${group.color};
                    border-radius: 4px;
                    font-size: 13px;
                    font-weight: 600;
                    color: #1e293b;
                    pointer-events: none;
                `;
                labelDiv.textContent = group.name;
            } else if (viewMode === 'mo') {
                // MO view labels
                const isMOHeader = group.type === 'mo-header';
                const expandIcon = group.isCollapsed ? '▶' : '▼';
                const labelText = isMOHeader ? `${expandIcon} ${group.name}` : `  ${group.name}`;

                labelDiv.style.cssText = `
                    position: absolute;
                    top: ${yScale(group.id)}px;
                    left: 0;
                    width: 185px;
                    height: ${yScale.bandwidth()}px;
                    display: flex;
                    align-items: center;
                    padding-left: ${isMOHeader ? '8px' : '24px'};
                    background: ${isMOHeader ? '#f59e0b26' : '#ffffff'};
                    border: 1px solid ${isMOHeader ? '#f59e0b' : '#e2e8f0'};
                    border-radius: 4px;
                    font-size: ${isMOHeader ? '13px' : '12px'};
                    font-weight: ${isMOHeader ? '700' : '500'};
                    color: #1e293b;
                    cursor: ${isMOHeader ? 'pointer' : 'default'};
                    pointer-events: ${isMOHeader ? 'auto' : 'none'};
                    overflow: hidden;
                    text-overflow: ellipsis;
                    white-space: nowrap;
                `;
                labelDiv.textContent = labelText;

                // Add tooltip for MO headers with detailed info
                if (isMOHeader) {
                    const moData = manufacturingOrders.find(mo => mo.mo_num === group.moNum);
                    if (moData) {
                        const moScheduledDate = moData.mo_date_scheduled ? formatDate(moment(moData.mo_date_scheduled)) : 'N/A';
                        const bomInfo = moData.part_num ? `${moData.part_num} x ${moData.qty || '?'}` : 'N/A';
                        let tooltipText = `MO ${group.moNum}\nBOM: ${bomInfo}`;
                        if (moData.so_num && moData.so_num.trim() !== '') {
                            tooltipText += `\nSO: ${moData.so_num}`;
                        }
                        if (moData.customer_name && moData.customer_name.trim() !== '') {
                            tooltipText += `\nCustomer: ${moData.customer_name}`;
                        }
                        if (moData.customer_po && moData.customer_po.trim() !== '') {
                            tooltipText += `\nCustomer PO: ${moData.customer_po}`;
                        }
                        tooltipText += `\nScheduled: ${moScheduledDate}\nWO Count: ${group.wos.length}`;
                        labelDiv.title = tooltipText;
                    } else {
                        labelDiv.title = labelText;
                    }
                } else {
                    labelDiv.title = labelText;
                }

                // Add click handlers for MO headers
                if (isMOHeader) {
                    labelDiv.dataset.moNum = group.moNum;

                    // Single click: scroll to MO start date
                    let clickTimeout;
                    labelDiv.addEventListener('click', function(e) {
                        clickTimeout = setTimeout(() => {
                            const starts = group.wos.map(wo => moment(wo.date_scheduled_start));
                            const moStart = moment.min(starts);
                            const moStartX = xScale(moStart.toDate());

                            // Scroll to show the MO start date
                            const wrapper = document.getElementById('ganttWrapper');
                            wrapper.scrollLeft = Math.max(0, moStartX - margin.left - 100);

                            debugLog('info', `Scrolled to MO ${group.moNum} start date`);
                        }, 250); // Delay to allow double-click detection
                    });

                    // Double click: toggle collapse/expand
                    labelDiv.addEventListener('dblclick', function(e) {
                        clearTimeout(clickTimeout);

                        const wasCollapsed = collapsedMOs.has(group.moNum);

                        if (wasCollapsed) {
                            collapsedMOs.delete(group.moNum);
                            debugLog('info', `Expanded MO ${group.moNum}`);
                            // Set scroll target to MO start date
                            scrollToDateAfterRender = moment(group.start);
                        } else {
                            collapsedMOs.add(group.moNum);
                            debugLog('info', `Collapsed MO ${group.moNum}`);
                        }

                        renderGanttChart();
                        saveSettingsToDatabase();  // Auto-save collapsed MOs state
                    });
                }
            }

            labelsOverlay.appendChild(labelDiv);
        });
    } else {
        labelsOverlay.style.display = 'none';
    }

    // Day column borders - vertical lines for each day to help with alignment (drawn early so they appear behind all tiles)
    const columnBordersGroup = svg.append('g').attr('class', 'day-column-borders');
    let borderDay = ganttStartDate.clone();
    while (borderDay.isSameOrBefore(ganttEndDate)) {
        const dayX = xScale(borderDay.toDate());
        const isToday = borderDay.isSame(moment(), 'day');

        // Draw vertical line from top to bottom of chart
        columnBordersGroup.append('line')
            .attr('x1', dayX)
            .attr('x2', dayX)
            .attr('y1', 95)  // Start below headers
            .attr('y2', height)  // Extend to bottom of chart
            .attr('stroke', isToday ? '#818CF8' : '#cbd5e1')  // indigo-400 for today, slate-300 for others (darker)
            .attr('stroke-width', isToday ? 2 : 1.5)
            .attr('opacity', 0.7)  // Slightly more opaque for better visibility
            .attr('pointer-events', 'none');  // Don't interfere with mouse events

        borderDay.add(1, 'day');
    }

    // MO Header Rows (in MO view only) - drawn BEFORE WO bars
    if (viewMode === 'mo') {
        groups.forEach(group => {
            if (group.type === 'mo-header') {
                // Calculate MO bar span (earliest start to latest end of all WOs)
                const starts = group.wos.map(wo => moment(wo.date_scheduled_start).startOf('day'));
                const ends = group.wos.map(wo => moment(wo.date_scheduled).startOf('day'));
                const moStart = moment.min(starts);

                // Check for conflicts with MO scheduled date
                const moData = manufacturingOrders.find(mo => mo.mo_num === group.moNum);
                const bomInfo = moData ? `${moData.bom_num || 'N/A'} x ${moData.qty || '?'}` : '';
                let moEnd;
                let hasConflict = false;
                if (moData && moData.mo_date_scheduled) {
                    moEnd = moment(moData.mo_date_scheduled).startOf('day');
                    group.wos.forEach(wo => {
                        if (moment(wo.date_scheduled).startOf('day').isAfter(moEnd)) {
                            hasConflict = true;
                            conflicts.add(wo.wo_id);
                        }
                    });
                } else {
                    moEnd = moment.max(ends);
                }

                // MO tiles span full days with visual margin
                const tilePadding = dayWidth * 0.08;
                const moX = xScale(moStart.toDate()) + tilePadding;
                const moEndX = xScale(moEnd.clone().add(1, 'day').toDate()) - tilePadding;
                const moWidth = Math.max(20, moEndX - moX);
                const groupY = yScale(group.id);
                const rowHeight = yScale.bandwidth();

                // Match calendar tile sizing - 20px bar height
                const moHeight = 20;
                const moY = groupY + (rowHeight - moHeight) / 2; // Center vertically in row

                // MO header bar - orange/amber for MOs, red if conflict
                const moBar = svg.append('rect')
                    .attr('class', 'mo-header-bar')
                    .attr('x', moX)
                    .attr('y', moY)
                    .attr('width', moWidth)
                    .attr('height', moHeight)
                    .attr('rx', 6)
                    .attr('fill', hasConflict ? '#ef4444' : '#f59e0b')
                    .attr('stroke', hasConflict ? '#dc2626' : '#d97706')
                    .attr('stroke-width', 2)
                    .attr('data-mo-num', group.moNum)
                    .style('filter', 'drop-shadow(0 2px 4px rgba(0,0,0,0.1))');

                // Add MO tooltip
                let moTooltipHTML = '<div><span class="wo-tooltip-label">MO:</span><span class="wo-tooltip-value">' + group.moNum + '</span></div>';
                moTooltipHTML += '<div><span class="wo-tooltip-label">BOM:</span><span class="wo-tooltip-value">' + bomInfo + '</span></div>';
                if (moData && moData.so_num && moData.so_num.trim() !== '') {
                    moTooltipHTML += '<div><span class="wo-tooltip-label">SO:</span><span class="wo-tooltip-value">' + moData.so_num + '</span></div>';
                }
                if (moData && moData.customer_name && moData.customer_name.trim() !== '') {
                    moTooltipHTML += '<div><span class="wo-tooltip-label">Customer:</span><span class="wo-tooltip-value">' + moData.customer_name + '</span></div>';
                }
                if (moData && moData.customer_po && moData.customer_po.trim() !== '') {
                    moTooltipHTML += '<div><span class="wo-tooltip-label">Customer PO:</span><span class="wo-tooltip-value">' + moData.customer_po + '</span></div>';
                }
                moTooltipHTML += '<div><span class="wo-tooltip-label">Start:</span><span class="wo-tooltip-value">' + formatDate(moStart) + '</span></div>';
                moTooltipHTML += '<div><span class="wo-tooltip-label">Scheduled Finish:</span><span class="wo-tooltip-value">' + formatDate(moEnd) + '</span></div>';
                moTooltipHTML += '<div><span class="wo-tooltip-label">WO Count:</span><span class="wo-tooltip-value">' + group.wos.length + '</span></div>';
                if (hasConflict) {
                    moTooltipHTML += '<div><span class="wo-tooltip-label">Status:</span><span class="wo-tooltip-value" style="color: #ef4444;">⚠ Conflict - WOs exceed MO date</span></div>';
                }

                moBar.on('mouseover', function(event) {
                    showWOTooltip(event, moTooltipHTML);
                }).on('mouseout', function() {
                    hideWOTooltip();
                }).on('mousemove', function(event) {
                    showWOTooltip(event, moTooltipHTML);
                });

                // MO label - single line format: "MO 5 - FG2100 x 3"
                const moLabelText = `MO ${group.moNum} - ${bomInfo}${hasConflict ? ' ⚠' : ''}`;
                svg.append('text')
                    .attr('x', moX + 10)
                    .attr('y', moY + moHeight / 2 + 4)  // Vertically center
                    .attr('font-size', '11px')
                    .attr('font-weight', '600')
                    .attr('fill', '#1e293b')
                    .attr('pointer-events', 'none')
                    .text(moLabelText);
            }
        });
    }

    // Month header background
    const monthHeaderGroup = svg.append('g');
    let currentMonth = ganttStartDate.clone().startOf('month');
    const processedMonths = new Set();

    while (currentMonth.isSameOrBefore(ganttEndDate)) {
        const monthKey = currentMonth.format('YYYY-MM');
        if (!processedMonths.has(monthKey)) {
            processedMonths.add(monthKey);

            const monthStart = moment.max(currentMonth.clone().startOf('month'), ganttStartDate);
            const monthEnd = moment.min(currentMonth.clone().endOf('month'), ganttEndDate);

            const monthX = xScale(monthStart.toDate());
            const monthWidth = xScale(monthEnd.toDate()) - monthX + dayWidth;

            // Month background
            monthHeaderGroup.append('rect')
                .attr('x', monthX)
                .attr('y', 10)
                .attr('width', monthWidth)
                .attr('height', 30)
                .attr('fill', '#f8fafc')
                .attr('stroke', '#e2e8f0')
                .attr('stroke-width', 1);

            // Month label
            monthHeaderGroup.append('text')
                .attr('x', monthX + monthWidth / 2)
                .attr('y', 28)
                .attr('text-anchor', 'middle')
                .attr('font-size', '14px')
                .attr('font-weight', '700')
                .attr('fill', '#334155')
                .text(currentMonth.format('MMMM YYYY'));
        }
        currentMonth.add(1, 'month');
    }

    // Day header
    const headerGroup = svg.append('g');
    currentDay = ganttStartDate.clone();
    while (currentDay.isSameOrBefore(ganttEndDate)) {
        const isWeekend = currentDay.day() === 0 || currentDay.day() === 6;
        const dayX = xScale(currentDay.toDate());

        // Day background
        headerGroup.append('rect')
            .attr('x', dayX)
            .attr('y', 45)
            .attr('width', dayWidth)
            .attr('height', 50)
            .attr('fill', isWeekend ? '#fef3c7' : '#ffffff')
            .attr('stroke', '#e2e8f0')
            .attr('stroke-width', 1);

        // Day label
        headerGroup.append('text')
            .attr('x', dayX + dayWidth / 2)
            .attr('y', 62)
            .attr('text-anchor', 'middle')
            .attr('font-size', '12px')
            .attr('font-weight', isWeekend ? '700' : '600')
            .attr('fill', isWeekend ? '#92400e' : '#64748b')
            .text(currentDay.format('ddd'));

        // Date number
        headerGroup.append('text')
            .attr('x', dayX + dayWidth / 2)
            .attr('y', 62)
            .attr('dy', '1.1em')
            .attr('text-anchor', 'middle')
            .attr('font-size', '11px')
            .attr('font-weight', '500')
            .attr('fill', isWeekend ? '#92400e' : '#94a3b8')
            .text(currentDay.format('D'));

        currentDay.add(1, 'day');
    }

    // WO Bars
    groups.forEach(group => {
        // Skip MO header rows - they're rendered above
        if (group.type === 'mo-header') return;

        group.wos.forEach(wo => {
            const start = moment(wo.date_scheduled_start).startOf('day');
            const end = moment(wo.date_scheduled).startOf('day');

            // Visual margin for better appearance
            const tilePadding = dayWidth * 0.08; // 8% margin on each side

            // Default: span from start of day to end of day with margins
            let startX = xScale(start.toDate()) + tilePadding;
            let endX = xScale(end.clone().add(1, 'day').toDate()) - tilePadding;

            // Check for same-day dependencies
            const stagingDep = stagingDependencies.find(d => d.wo_id === wo.wo_id);
            const dependentDep = stagingDependencies.find(d => d.staging_wo_id === wo.wo_id);

            if (stagingDep) {
                const stagingWO = filteredWorkOrders.find(w => w.wo_id === stagingDep.staging_wo_id);
                if (stagingWO) {
                    const stagingEnd = moment(stagingWO.date_scheduled).startOf('day');
                    // If staging WO ends same day this WO starts, position from midday
                    if (stagingEnd.isSame(start, 'day')) {
                        startX = xScale(start.toDate()) + dayWidth / 2 + tilePadding;
                    }
                }
            }

            if (dependentDep) {
                const dependentWO = filteredWorkOrders.find(w => w.wo_id === dependentDep.wo_id);
                if (dependentWO) {
                    const dependentStart = moment(dependentWO.date_scheduled_start).startOf('day');
                    // If dependent WO starts same day this WO ends, position to midday
                    if (dependentStart.isSame(end, 'day')) {
                        endX = xScale(end.toDate()) + dayWidth / 2 - tilePadding;
                    }
                }
            }

            const x = startX;
            const barWidth = Math.max(10, endX - startX);

            // Calculate y position and bar height - match capacity planning sizing (35px bars)
            let y, barHeight;
            if (viewMode === 'category' && wo._lane !== undefined) {
                const groupY = yScale(group.id);
                const laneHeight = 40; // Match capacity planning lane spacing
                y = groupY + (wo._lane * laneHeight) + 2.5; // 2.5px padding for centering
                barHeight = 20; // Match calendar tile height
            } else {
                // MO view: center 20px bar within row
                const groupY = yScale(group.id);
                const rowHeight = yScale.bandwidth(group.id);
                barHeight = 20; // Match calendar tile height
                y = groupY + (rowHeight - barHeight) / 2; // Center vertically in row
            }

            // Use standard color scheme
            const colors = WO_STATUS_COLORS[wo.wo_status] || WO_STATUS_COLORS[10];

            // Bar with tooltip - compact styling to match capacity planning
            const bar = svg.append('rect')
                .attr('class', 'wo-bar')
                .attr('x', x)
                .attr('y', y)
                .attr('width', barWidth)
                .attr('height', barHeight)
                .attr('rx', 4)
                .attr('fill', colors.fill)
                .attr('stroke', colors.stroke)
                .attr('stroke-width', 2)
                .attr('data-wo-id', wo.wo_id)
                .attr('data-wo-num', wo.wo_num);

            // Add custom CSS tooltip with BOM, Qty, dates, and category
            const statusName = wo.wo_status === 10 ? 'Entered' : wo.wo_status === 30 ? 'Started' : wo.wo_status === 40 ? 'Fulfilled' : 'Unknown';
            // Use WO's specific part number and quantity (not MO's BOM)
            const bomInfo = wo.part_num ? `${wo.part_num} x ${wo.qty_target || '?'}` : 'N/A';
            const tooltipHTML = `
                <div><span class="wo-tooltip-label">WO:</span><span class="wo-tooltip-value">${wo.wo_num}</span></div>
                <div><span class="wo-tooltip-label">MO:</span><span class="wo-tooltip-value">${wo.mo_num}</span></div>
                <div><span class="wo-tooltip-label">Category:</span><span class="wo-tooltip-value">${wo.category_name || 'Uncategorized'}</span></div>
                <div><span class="wo-tooltip-label">BOM:</span><span class="wo-tooltip-value">${bomInfo}</span></div>
                <div><span class="wo-tooltip-label">Status:</span><span class="wo-tooltip-value">${statusName}</span></div>
                <div><span class="wo-tooltip-label">Start:</span><span class="wo-tooltip-value">${formatDate(start, true)}</span></div>
                <div><span class="wo-tooltip-label">Finish:</span><span class="wo-tooltip-value">${formatDate(end, true)}</span></div>
            `;

            // Add tooltip events
            bar.on('mouseover', function(event) {
                showWOTooltip(event, tooltipHTML);
            }).on('mouseout', function() {
                hideWOTooltip();
            }).on('mousemove', function(event) {
                showWOTooltip(event, tooltipHTML);
            });

            // Add arrow highlighting on hover
            bar.on('mouseenter', function() {
                const woId = wo.wo_id;
                // Find and highlight all arrows connected to this WO (source or target)
                svg.selectAll('.dependency-arrow')
                    .filter(function() {
                        const sourceId = parseInt(d3.select(this).attr('data-source-wo-id'));
                        const targetId = parseInt(d3.select(this).attr('data-target-wo-id'));
                        return sourceId === woId || targetId === woId;
                    })
                    .attr('stroke-width', 2.5)
                    .attr('opacity', 0.9);
            }).on('mouseleave', function() {
                // Reset all arrows to light state
                svg.selectAll('.dependency-arrow')
                    .attr('stroke-width', 1.5)
                    .attr('opacity', 0.25);
            });

            // Add drag behavior
            let isDragging = false;
            let dragStartX = 0;

            const drag = d3.drag()
                .on('start', function(event) {
                    isDragging = false;
                    dragStartX = event.x;

                    d3.select(this)
                        .classed('dragging', true);

                    // Don't change opacity during drag - let hover classes handle it
                })
                .on('drag', function(event) {
                    // Only consider it a drag if moved more than 5 pixels
                    if (Math.abs(event.x - dragStartX) > 5) {
                        isDragging = true;
                    }

                    if (isDragging) {
                        const newX = Math.max(margin.left, event.x);
                        d3.select(this).attr('x', newX);

                        // Update label position
                        const labelElement = d3.select(this.nextSibling);
                        labelElement.attr('x', newX + 8);
                    }
                })
                .on('end', async function(event) {
                    d3.select(this)
                        .classed('dragging', false);

                    // Only save if actually dragged
                    if (!isDragging) {
                        // Reset position
                        d3.select(this).attr('x', x);
                        const labelElement = d3.select(this.nextSibling);
                        labelElement.attr('x', x + 8);
                        return;
                    }

                    // Add to undo stack only on actual drag
                    undoStack.push(captureState());
                    if (undoStack.length > MAX_UNDO_STACK) {
                        undoStack.shift();
                    }
                    redoStack = [];
                    updateUndoRedoButtons();

                    const newX = Math.max(margin.left, event.x);
                    const newStartDate = xScale.invert(newX);
                    let newStart = moment(newStartDate).startOf('day');

                    // Apply skip weekends if enabled
                    newStart = moment(applySkipWeekends(newStart.toDate()));

                    // Calculate duration and new end date
                    const duration = moment(wo.date_scheduled).diff(moment(wo.date_scheduled_start), 'days');
                    let newEnd = newStart.clone().add(duration, 'days');

                    // Apply skip weekends to end date as well
                    newEnd = moment(applySkipWeekends(newEnd.toDate()));

                    const woNum = d3.select(this).attr('data-wo-num');
                    debugLog('info', `Dropped WO ${woNum}: ${newStart.format('YYYY-MM-DD')} to ${newEnd.format('YYYY-MM-DD')}`);

                    // Update in Fishbowl
                    await saveWODates(woNum, newStart.format('YYYY-MM-DD'), newEnd.format('YYYY-MM-DD'));

                    // Shift dependent WOs if setting is enabled
                    if (shiftDependentWOs) {
                        const daysDiff = newStart.diff(moment(wo.date_scheduled_start), 'days');
                        if (daysDiff !== 0) {
                            // Find all WOs that depend on this WO (where this WO is the staging_wo_id)
                            const dependentRelations = stagingDependencies.filter(dep => dep.staging_wo_id === wo.wo_id);

                            for (const relation of dependentRelations) {
                                const dependentWO = allWorkOrders.find(w => w.wo_id === relation.wo_id);
                                if (dependentWO) {
                                    let depStart = moment(dependentWO.date_scheduled_start).add(daysDiff, 'days');
                                    let depEnd = moment(dependentWO.date_scheduled).add(daysDiff, 'days');

                                    // Apply skip weekends to dependent WOs as well
                                    depStart = moment(applySkipWeekends(depStart.toDate()));
                                    depEnd = moment(applySkipWeekends(depEnd.toDate()));

                                    debugLog('info', `Shifting dependent WO ${dependentWO.wo_num} by ${daysDiff} days: ${depStart.format('YYYY-MM-DD')} to ${depEnd.format('YYYY-MM-DD')}`);
                                    await saveWODates(dependentWO.wo_num, depStart.format('YYYY-MM-DD'), depEnd.format('YYYY-MM-DD'));
                                }
                            }
                        }
                    }
                });

            bar.call(drag);

            // Double-click to open WO in Fishbowl
            bar.on('dblclick', function() {
                debugLog('info', `Opening WO ${wo.wo_num} in Fishbowl...`);
                try {
                    if (typeof openModule === 'function') {
                        openModule('Work Order', wo.wo_num);
                        showToast(`Opening WO ${wo.wo_num}`, 'info');
                    } else {
                        debugLog('warn', 'openModule function not available in Fishbowl');
                        showToast('Cannot open WO - not running in Fishbowl', 'error');
                    }
                } catch (error) {
                    debugLog('error', 'Error opening WO:', error);
                    showToast('Error opening WO: ' + error.message, 'error');
                }
            });

            // Label - single line format: "WO 5:001 - FG2100 x 3"
            const labelText = `WO ${wo.wo_num} - ${bomInfo}`;
            const label = svg.append('text')
                .attr('x', x + 8)
                .attr('y', y + barHeight / 2 + 4)  // Vertically center
                .attr('font-size', '11px')
                .attr('font-weight', '600')
                .attr('fill', '#1e293b')
                .attr('pointer-events', 'none')
                .text(labelText);

            // Left resize handle
            const handleWidth = 8;
            const leftHandle = svg.append('rect')
                .attr('class', 'resize-handle-left')
                .attr('x', x)
                .attr('y', y)
                .attr('width', handleWidth)
                .attr('height', barHeight)
                .attr('fill', 'transparent')
                .style('cursor', 'ew-resize');

            const leftDrag = d3.drag()
                .on('start', function() {
                    d3.select(this).style('fill', 'rgba(255,255,255,0.3)');
                })
                .on('drag', function(event) {
                    const newX = Math.max(margin.left, Math.min(event.x, x + barWidth - 20));
                    const newWidth = barWidth + (x - newX);

                    bar.attr('x', newX).attr('width', newWidth);
                    d3.select(this).attr('x', newX);
                    label.attr('x', newX + 8);
                })
                .on('end', async function(event) {
                    d3.select(this).style('fill', 'transparent');

                    const newX = Math.max(margin.left, Math.min(event.x, x + barWidth - 20));
                    const newStartDate = xScale.invert(newX);
                    let newStart = moment(newStartDate).startOf('day');

                    const woNum = wo.wo_num;
                    const currentEnd = moment(wo.date_scheduled).format('YYYY-MM-DD');
                    debugLog('info', `Resized WO ${woNum} start: ${newStart.format('YYYY-MM-DD')}`);

                    undoStack.push(captureState());
                    if (undoStack.length > MAX_UNDO_STACK) undoStack.shift();
                    redoStack = [];
                    updateUndoRedoButtons();

                    await saveWODates(woNum, newStart.format('YYYY-MM-DD'), currentEnd);
                });

            leftHandle.call(leftDrag);

            // Right resize handle
            const rightHandle = svg.append('rect')
                .attr('class', 'resize-handle-right')
                .attr('x', x + barWidth - handleWidth)
                .attr('y', y)
                .attr('width', handleWidth)
                .attr('height', barHeight)
                .attr('fill', 'transparent')
                .style('cursor', 'ew-resize');

            const rightDrag = d3.drag()
                .on('start', function() {
                    d3.select(this).style('fill', 'rgba(255,255,255,0.3)');
                })
                .on('drag', function(event) {
                    const newWidth = Math.max(20, event.x - x);
                    bar.attr('width', newWidth);
                    d3.select(this).attr('x', x + newWidth - handleWidth);
                })
                .on('end', async function(event) {
                    d3.select(this).style('fill', 'transparent');

                    const newWidth = Math.max(20, event.x - x);
                    const newEndX = x + newWidth;
                    const newEndDate = xScale.invert(newEndX);
                    let newEnd = moment(newEndDate).startOf('day');

                    const woNum = wo.wo_num;
                    const currentStart = moment(wo.date_scheduled_start).format('YYYY-MM-DD');
                    debugLog('info', `Resized WO ${woNum} end: ${newEnd.format('YYYY-MM-DD')}`);

                    undoStack.push(captureState());
                    if (undoStack.length > MAX_UNDO_STACK) undoStack.shift();
                    redoStack = [];
                    updateUndoRedoButtons();

                    await saveWODates(woNum, currentStart, newEnd.format('YYYY-MM-DD'));
                });

            rightHandle.call(rightDrag);
        });
    });

    // Dependency Arrows
    // Defer arrow rendering to next frame to ensure tiles are fully laid out
    if (showArrows && stagingDependencies.length > 0) {
        requestAnimationFrame(() => {
            const arrowGroup = svg.append('g').attr('class', 'arrows');

        stagingDependencies.forEach(dep => {
            // Find the WO bars for source and target
            const sourceWO = filteredWorkOrders.find(wo => wo.wo_id === dep.staging_wo_id);
            const targetWO = filteredWorkOrders.find(wo => wo.wo_id === dep.wo_id);

            if (!sourceWO || !targetWO) return;

            // Find groups differently based on view mode
            let sourceGroup, targetGroup;
            if (viewMode === 'mo') {
                // In MO view, find the WO row (not MO header) that contains this WO
                sourceGroup = groups.find(g => g.type === 'wo-row' && g.wos.some(wo => wo.wo_id === sourceWO.wo_id));
                targetGroup = groups.find(g => g.type === 'wo-row' && g.wos.some(wo => wo.wo_id === targetWO.wo_id));
            } else {
                // In category view, group by category name
                sourceGroup = groups.find(g => g.id === sourceWO.category_name);
                targetGroup = groups.find(g => g.id === targetWO.category_name);
            }

            if (!sourceGroup || !targetGroup) return;

            // Calculate tile edge positions (matching tile rendering logic exactly)
            const tilePadding = dayWidth * 0.08;

            // Source tile end (right edge)
            const sourceEndDate = moment(sourceWO.date_scheduled).startOf('day');
            let sourceEnd = xScale(sourceEndDate.clone().add(1, 'day').toDate()) - tilePadding;

            // Check if source has a dependent WO that starts same day it ends (same-day logic)
            const sourceDependentDep = stagingDependencies.find(d => d.staging_wo_id === sourceWO.wo_id);
            if (sourceDependentDep) {
                const sourceDependentWO = filteredWorkOrders.find(w => w.wo_id === sourceDependentDep.wo_id);
                if (sourceDependentWO) {
                    const dependentStart = moment(sourceDependentWO.date_scheduled_start).startOf('day');
                    // If dependent WO starts same day this WO ends, position to midday
                    if (dependentStart.isSame(sourceEndDate, 'day')) {
                        sourceEnd = xScale(sourceEndDate.toDate()) + dayWidth / 2 - tilePadding;
                    }
                }
            }

            // Target tile start (left edge)
            const targetStartDate = moment(targetWO.date_scheduled_start).startOf('day');
            let targetStart = xScale(targetStartDate.toDate()) + tilePadding;

            // Check if target has a staging dependency that ends same day it starts (same-day logic)
            const targetStagingDep = stagingDependencies.find(d => d.wo_id === targetWO.wo_id);
            if (targetStagingDep) {
                const targetStagingWO = filteredWorkOrders.find(w => w.wo_id === targetStagingDep.staging_wo_id);
                if (targetStagingWO) {
                    const stagingEnd = moment(targetStagingWO.date_scheduled).startOf('day');
                    // If staging WO ends same day this WO starts, position from midday
                    if (stagingEnd.isSame(targetStartDate, 'day')) {
                        targetStart = xScale(targetStartDate.toDate()) + dayWidth / 2 + tilePadding;
                    }
                }
            }

            // Calculate Y position accounting for lanes and bar sizes
            let sourceY, targetY;
            const barHeight = 20; // Match calendar tile height

            if (viewMode === 'category' && sourceWO._lane !== undefined) {
                const groupY = yScale(sourceGroup.id);
                const laneHeight = 40; // Match capacity planning
                sourceY = groupY + (sourceWO._lane * laneHeight) + 2.5 + (barHeight / 2);
            } else {
                // MO view: center of 35px bar within row
                const groupY = yScale(sourceGroup.id);
                const rowHeight = yScale.bandwidth(sourceGroup.id);
                sourceY = groupY + (rowHeight - barHeight) / 2 + (barHeight / 2);
            }

            if (viewMode === 'category' && targetWO._lane !== undefined) {
                const groupY = yScale(targetGroup.id);
                const laneHeight = 40; // Match capacity planning
                targetY = groupY + (targetWO._lane * laneHeight) + 2.5 + (barHeight / 2);
            } else {
                // MO view: center of 35px bar within row
                const groupY = yScale(targetGroup.id);
                const rowHeight = yScale.bandwidth(targetGroup.id);
                targetY = groupY + (rowHeight - barHeight) / 2 + (barHeight / 2);
            }

            // Check for conflict based on allowSameDayStarts setting
            const sourceFinish = sourceEndDate;
            const targetStartDay = targetStartDate;

            let isConflict;
            if (allowSameDayStarts) {
                // Allow same-day: only conflict if source finishes AFTER target starts
                isConflict = sourceFinish.isAfter(targetStartDay);
            } else {
                // Don't allow same-day: conflict if source finishes on or after target starts
                isConflict = sourceFinish.isSameOrAfter(targetStartDay);
            }

            const arrowColor = isConflict ? '#ef4444' : '#64748b';

            // Draw arrow path
            let path;

            // Check if WOs end and start on the same day
            if (sourceEnd >= targetStart) {
                // Same-day: draw L-shape going straight down then left
                path = `M ${sourceEnd},${sourceY}
                       L ${sourceEnd},${targetY}
                       L ${targetStart},${targetY}`;
            } else {
                // Normal case: source ends before target starts
                const midX = (sourceEnd + targetStart) / 2;
                path = `M ${sourceEnd},${sourceY}
                       L ${midX},${sourceY}
                       L ${midX},${targetY}
                       L ${targetStart},${targetY}`;
            }

            arrowGroup.append('path')
                .attr('d', path)
                .attr('stroke', arrowColor)
                .attr('stroke-width', 1.5)
                .attr('fill', 'none')
                .attr('marker-end', `url(#arrow-${isConflict ? 'conflict' : 'normal'})`)
                .attr('opacity', 0.25)  // Lighter by default
                .attr('class', isConflict ? 'dependency-arrow conflict' : 'dependency-arrow')
                .attr('data-source-wo-id', dep.staging_wo_id)
                .attr('data-target-wo-id', dep.wo_id);  // Track both source and target

            // Track conflicts
            if (isConflict) {
                conflicts.add(dep.wo_id);
                conflicts.add(dep.staging_wo_id);
            }
        });

        // Define arrow markers
        const defs = svg.append('defs');

        // Normal arrow
        defs.append('marker')
            .attr('id', 'arrow-normal')
            .attr('viewBox', '0 0 10 10')
            .attr('refX', 9)
            .attr('refY', 5)
            .attr('markerWidth', 6)
            .attr('markerHeight', 6)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M 0 0 L 10 5 L 0 10 z')
            .attr('fill', '#64748b');

        // Conflict arrow
        defs.append('marker')
            .attr('id', 'arrow-conflict')
            .attr('viewBox', '0 0 10 10')
            .attr('refX', 9)
            .attr('refY', 5)
            .attr('markerWidth', 6)
            .attr('markerHeight', 6)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M 0 0 L 10 5 L 0 10 z')
            .attr('fill', '#ef4444');

        // Highlight conflicted WO bars
        svg.selectAll('.wo-bar').each(function() {
            const woId = parseInt(d3.select(this).attr('data-wo-id'));
            if (conflicts.has(woId)) {
                d3.select(this)
                    .attr('stroke', '#ef4444')
                    .attr('stroke-width', 3);
            }
        });

            debugLog('success', `Gantt chart rendered with ${filteredWorkOrders.length} WOs, ${stagingDependencies.length} dependencies, ${conflicts.size} conflicts`);
        });
    } else {
        debugLog('success', `Gantt chart rendered with ${filteredWorkOrders.length} WOs, no dependencies or arrows disabled`);
    }

    // Setup sticky labels on scroll (for category and MO views)
    if (viewMode === 'category' || viewMode === 'mo') {
        setupStickyLabels(groups, yScale);
    }

    // Setup pan and zoom
    setupGanttPanZoom();

    // Scroll to specific date if requested (e.g., after MO expansion)
    if (scrollToDateAfterRender) {
        const wrapper = document.getElementById('ganttWrapper');
        const targetX = xScale(scrollToDateAfterRender.toDate());
        const viewportWidth = wrapper.clientWidth;
        const scrollTarget = Math.max(0, targetX - viewportWidth / 2);

        // Use setTimeout to ensure DOM is fully updated
        setTimeout(() => {
            wrapper.scrollLeft = scrollTarget;
            debugLog('info', `Scrolled to date: ${scrollToDateAfterRender.format('MMM D, YYYY')}`);
        }, 100);

        // Clear the scroll target
        scrollToDateAfterRender = null;
    }
    // Scroll to current week when MO view loads (unless skipAutoScroll flag is set or we just scrolled to a specific date)
    else if (viewMode === 'mo' && !window.skipAutoScroll) {
        const wrapper = document.getElementById('ganttWrapper');
        const currentWeekStart = moment().startOf('isoWeek'); // Monday of current week
        const todayX = xScale(currentWeekStart.toDate());

        // Center the current week in the viewport
        const viewportWidth = wrapper.clientWidth;
        const scrollTarget = Math.max(0, todayX - viewportWidth / 2);

        // Use setTimeout to ensure DOM is fully updated
        setTimeout(() => {
            wrapper.scrollLeft = scrollTarget;
            debugLog('info', `Scrolled MO view to current week (${currentWeekStart.format('MMM D, YYYY')})`);
        }, 100);
    }
}

// ============================================
// STICKY LABELS (CATEGORY AND MO VIEWS)
// ============================================
function setupStickyLabels(groups, yScale) {
    const wrapper = document.getElementById('ganttWrapper');
    const overlay = document.getElementById('categoryLabelsOverlay');

    // Remove existing scroll listener to avoid duplicates
    const existingListener = wrapper._categoryScrollListener;
    if (existingListener) {
        wrapper.removeEventListener('scroll', existingListener);
    }

    // Scroll handler to keep labels fixed on the left during horizontal scroll
    const scrollHandler = () => {
        const scrollLeft = wrapper.scrollLeft;
        // Update overlay position to compensate for horizontal scroll
        overlay.style.left = `${scrollLeft}px`;
    };

    // Attach scroll listener
    wrapper.addEventListener('scroll', scrollHandler);
    wrapper._categoryScrollListener = scrollHandler;

    // Initial call to position labels correctly
    scrollHandler();
}

// ============================================
// PAN AND ZOOM
// ============================================
function setupGanttPanZoom() {
    const wrapper = document.getElementById('ganttWrapper');

    // Pan (click and drag to scroll)
    let isPanning = false;
    let startX = 0;
    let startY = 0;
    let scrollLeft = 0;
    let scrollTop = 0;

    wrapper.addEventListener('mousedown', (e) => {
        // Don't pan if clicking on a WO bar or resize handle
        if (e.target.closest('.wo-bar') || e.target.classList.contains('resize-handle-left') || e.target.classList.contains('resize-handle-right')) {
            return;
        }

        isPanning = true;
        startX = e.pageX - wrapper.offsetLeft;
        startY = e.pageY - wrapper.offsetTop;
        scrollLeft = wrapper.scrollLeft;
        scrollTop = wrapper.scrollTop;
        wrapper.style.cursor = 'grabbing';
    });

    wrapper.addEventListener('mouseleave', () => {
        isPanning = false;
        wrapper.style.cursor = 'default';
    });

    wrapper.addEventListener('mouseup', () => {
        isPanning = false;
        wrapper.style.cursor = 'default';
    });

    wrapper.addEventListener('mousemove', (e) => {
        if (!isPanning) return;
        e.preventDefault();

        const x = e.pageX - wrapper.offsetLeft;
        const y = e.pageY - wrapper.offsetTop;
        const walkX = (x - startX) * 2; // Scroll speed
        const walkY = (y - startY) * 2;

        wrapper.scrollLeft = scrollLeft - walkX;
        wrapper.scrollTop = scrollTop - walkY;
    });

}

// ============================================
// ZOOM CONTROLS
// ============================================
function zoomIn() {
    ganttScale = Math.min(200, ganttScale + 20);
    renderGanttChart();
    saveSettingsToDatabase();  // Auto-save zoom level
}

function zoomOut() {
    ganttScale = Math.max(40, ganttScale - 20);
    renderGanttChart();
    saveSettingsToDatabase();  // Auto-save zoom level
}

// ============================================
// DATE NAVIGATION
// ============================================
function prevWeek() {
    // Move to previous Monday
    ganttStartDate = ganttStartDate.clone().subtract(7, 'days').startOf('isoWeek');
    // Keep same range duration
    const rangeDays = ganttEndDate.diff(ganttStartDate, 'days');
    ganttEndDate = ganttStartDate.clone().add(rangeDays, 'days');
    renderGanttChart();
}

function nextWeek() {
    // Move to next Monday
    ganttStartDate = ganttStartDate.clone().add(7, 'days').startOf('isoWeek');
    // Keep same range duration
    const rangeDays = ganttEndDate.diff(ganttStartDate, 'days');
    ganttEndDate = ganttStartDate.clone().add(rangeDays, 'days');
    renderGanttChart();
}

function goToToday() {
    // Calculate current range duration
    const rangeDays = ganttEndDate.diff(ganttStartDate, 'days');

    // Center the current range on this week's Monday
    ganttStartDate = moment().startOf('isoWeek');
    ganttEndDate = ganttStartDate.clone().add(rangeDays, 'days');

    // Set scroll target to today
    scrollToDateAfterRender = moment().startOf('day');

    renderGanttChart();
}

function setTimeRange(days) {
    // Adjust zoom scale to fit specified days in viewport
    // Viewport width is roughly 1200px (common container width)
    const viewportWidth = document.getElementById('ganttWrapper').clientWidth || 1200;
    const margin = 200; // left margin for labels
    const availableWidth = viewportWidth - margin;

    // Calculate scale to fit days in available width
    ganttScale = Math.max(40, Math.min(200, availableWidth / days));

    renderGanttChart();
    debugLog('info', `Zoom adjusted to fit ${days} days (scale: ${ganttScale.toFixed(1)}px/day)`);
}

// ============================================
// TOGGLE SETTINGS
// ============================================
function toggleArrows() {
    showArrows = !showArrows;
    const btn = document.getElementById('toggleArrowsBtn');
    if (showArrows) {
        btn.querySelector('svg').classList.remove('text-slate-400');
        btn.querySelector('svg').classList.add('text-emerald-600');
    } else {
        btn.querySelector('svg').classList.remove('text-emerald-600');
        btn.querySelector('svg').classList.add('text-slate-400');
    }
    renderGanttChart();
    debugLog('info', `Dependency arrows ${showArrows ? 'enabled' : 'disabled'}`);
}

// ============================================
// CAPACITY PLANNING VIEW
// ============================================
function buildCapacityTable(weekStart) {
    debugLog('info', 'Building capacity table...');
    // Placeholder - will implement full capacity table
    const container = document.getElementById('capacityTable');
    container.innerHTML = `
        <thead>
            <tr class="bg-slate-50">
                <th class="p-4 text-left font-semibold text-slate-700">Category</th>
                ${[0,1,2,3,4,5,6].map(day => `
                    <th class="p-4 text-center font-semibold text-slate-700">
                        ${weekStart.clone().add(day, 'days').format('ddd D')}
                    </th>
                `).join('')}
            </tr>
        </thead>
        <tbody>
            <tr>
                <td colspan="8" class="p-8 text-center text-slate-400">
                    Capacity planning table coming soon...
                </td>
            </tr>
        </tbody>
    `;

    const display = document.getElementById('capacityWeekDisplay');
    display.textContent = `${weekStart.format('MMM D')} - ${weekStart.clone().add(6, 'days').format('MMM D, YYYY')}`;
}

// ============================================
// UNDO/REDO
// ============================================
function undo() {
    if (undoStack.length === 0) return;
    const state = undoStack.pop();
    redoStack.push(captureState());
    restoreState(state);
    updateUndoRedoButtons();
}

function redo() {
    if (redoStack.length === 0) return;
    const state = redoStack.pop();
    undoStack.push(captureState());
    restoreState(state);
    updateUndoRedoButtons();
}

function captureState() {
    return JSON.stringify(allWorkOrders);
}

function restoreState(state) {
    allWorkOrders = JSON.parse(state);
    filteredWorkOrders = [...allWorkOrders];
    renderCurrentView();
}

function updateUndoRedoButtons() {
    document.getElementById('undoBtn').disabled = undoStack.length === 0;
    document.getElementById('redoBtn').disabled = redoStack.length === 0;
}

// ============================================
// SETTINGS PERSISTENCE
// ============================================
function gatherSettings() {
    // Compile all settings into a single object
    // Only save capacity limits (not category names/colors which come from DB)
    const categoryLimits = {};
    capacitySettings.categories.forEach(cat => {
        categoryLimits[cat.id] = cat.limits;
    });

    return {
        version: '1.0',
        categoryLimits: categoryLimits, // Map of category_id -> limits array
        ganttScale: ganttScale,
        showArrows: showArrows,
        allowSameDayStarts: allowSameDayStarts,
        shiftDependentWOs: shiftDependentWOs,
        skipWeekends: skipWeekends,
        dateFormat: dateFormat,
        calendarColorMode: calendarColorMode,
        viewByMode: viewByMode,
        showCompletedWOs: showCompletedWOs,
        calendarExpanded: calendarExpanded,
        collapsedMOs: Array.from(collapsedMOs), // Convert Set to Array for JSON
        savedAt: new Date().toISOString()
    };
}

function applySettings(settings) {
    // Apply loaded settings to global variables
    if (!settings || !settings.version) {
        debugLog('warn', 'Invalid settings object, using defaults');
        return false;
    }

    try {
        // Apply category limits to existing categories (don't replace category metadata)
        if (settings.categoryLimits && typeof settings.categoryLimits === 'object') {
            capacitySettings.categories.forEach(cat => {
                if (settings.categoryLimits[cat.id]) {
                    cat.limits = settings.categoryLimits[cat.id];
                }
            });
        }

        if (typeof settings.ganttScale === 'number') {
            ganttScale = settings.ganttScale;
        }
        if (typeof settings.showArrows === 'boolean') {
            showArrows = settings.showArrows;
            // Update UI checkbox
            const showArrowsCheckbox = document.getElementById('showArrowsToggle');
            if (showArrowsCheckbox) showArrowsCheckbox.checked = showArrows;
        }
        if (typeof settings.allowSameDayStarts === 'boolean') {
            allowSameDayStarts = settings.allowSameDayStarts;
            // Update UI checkbox
            const sameDayStartsCheckbox = document.getElementById('sameDayStartsToggle');
            if (sameDayStartsCheckbox) sameDayStartsCheckbox.checked = allowSameDayStarts;
        }
        if (typeof settings.shiftDependentWOs === 'boolean') {
            shiftDependentWOs = settings.shiftDependentWOs;
            // Update UI checkbox
            const shiftDependentWOsCheckbox = document.getElementById('shiftDependentWOsToggle');
            if (shiftDependentWOsCheckbox) shiftDependentWOsCheckbox.checked = shiftDependentWOs;
        }
        if (typeof settings.skipWeekends === 'boolean') {
            skipWeekends = settings.skipWeekends;
            // Update UI checkbox
            const skipWeekendsCheckbox = document.getElementById('skipWeekendsToggle');
            if (skipWeekendsCheckbox) skipWeekendsCheckbox.checked = skipWeekends;
        }
        if (settings.dateFormat && (settings.dateFormat === 'DD/MM/YYYY' || settings.dateFormat === 'MM/DD/YYYY')) {
            dateFormat = settings.dateFormat;
            // Update UI select
            const dateFormatSelect = document.getElementById('dateFormatSelect');
            if (dateFormatSelect) dateFormatSelect.value = dateFormat;
        }
        if (settings.calendarColorMode && (settings.calendarColorMode === 'status' || settings.calendarColorMode === 'category')) {
            calendarColorMode = settings.calendarColorMode;
            // Update UI select
            const calendarColorModeSelect = document.getElementById('calendarColorModeSelect');
            if (calendarColorModeSelect) calendarColorModeSelect.value = calendarColorMode;
        }
        if (settings.viewByMode && (settings.viewByMode === 'wo_num' || settings.viewByMode === 'bom_num')) {
            viewByMode = settings.viewByMode;
            // Update UI select
            const viewByModeSelect = document.getElementById('viewByModeSelect');
            if (viewByModeSelect) viewByModeSelect.value = viewByMode;
        }
        if (typeof settings.showCompletedWOs === 'boolean') {
            showCompletedWOs = settings.showCompletedWOs;
            // Update UI checkbox
            const showCompletedWOsCheckbox = document.getElementById('showCompletedWOsToggle');
            if (showCompletedWOsCheckbox) showCompletedWOsCheckbox.checked = showCompletedWOs;
        }
        if (typeof settings.calendarExpanded === 'boolean') {
            calendarExpanded = settings.calendarExpanded;
        }
        if (Array.isArray(settings.collapsedMOs)) {
            collapsedMOs = new Set(settings.collapsedMOs);
        }

        // Sync UI checkboxes with current global variable values
        // This ensures UI reflects state even if some settings weren't in the saved JSON
        const showArrowsCheckbox = document.getElementById('showArrowsToggle');
        if (showArrowsCheckbox) showArrowsCheckbox.checked = showArrows;

        const sameDayStartsCheckbox = document.getElementById('sameDayStartsToggle');
        if (sameDayStartsCheckbox) sameDayStartsCheckbox.checked = allowSameDayStarts;

        const shiftDependentWOsCheckbox = document.getElementById('shiftDependentWOsToggle');
        if (shiftDependentWOsCheckbox) shiftDependentWOsCheckbox.checked = shiftDependentWOs;

        const skipWeekendsCheckbox = document.getElementById('skipWeekendsToggle');
        if (skipWeekendsCheckbox) skipWeekendsCheckbox.checked = skipWeekends;

        debugLog('success', `Settings loaded from ${settings.savedAt || 'unknown date'}`);

        // Update KPIs after settings are loaded (especially capacity limits)
        updateKPIs();

        return true;
    } catch (error) {
        debugLog('error', 'Error applying settings:', error);
        return false;
    }
}

function saveSettingsToDatabase() {
    // Save settings to database via part.details field using ImportRq API
    const settings = gatherSettings();
    const settingsJson = JSON.stringify(settings);

    // First, query the headers to know the column order
    const headers = queryImportHeaders();

    if (!headers) {
        debugLog('error', 'Could not retrieve import headers');
        showToast('Failed to save: Could not get import format', 'error');
        return false;
    }

    // Parse headers - they are quoted CSV values like "PartNumber","PartDescription",...
    const headerColumns = headers.match(/(".*?"|[^",\s]+)(?=\s*,|\s*$)/g) || [];
    const cleanColumns = headerColumns.map(col => col.replace(/^"|"$/g, '').trim());

    // Try base64 encoding instead of CSV escaping to avoid issues with commas/quotes in JSON
    const base64Json = btoa(settingsJson);

    // Define our field values matching the ImportPart example format exactly
    const fieldValues = {
        'PartNumber': '"_settingsCapacityPlanner"',
        'PartDescription': '"_settingsCapacityPlanner"',
        'PartDetails': '"' + base64Json + '"',
        'UOM': '"ea"',
        'PartType': '"Internal Use"',
        'Active': '"true"',
        'ABCCode': '"N"',
        'Weight': '"0"',
        'WeightUOM': '"kg"',
        'Width': '"0"',
        'Height': '"0"',
        'Length': '"0"',
        'SizeUOM': '"ft"',
        'ConsumptionRate': '"0"',
        'POItemType': '"Purchase"',
        'DefaultOutsourcedReturnItem': '"_settingsCapacityPlanner"',
        'Tracks-Lot Number': '"false"',
        'Tracks-Revision Level': '"false"',
        'Tracks-Expiration Date': '"false"',
        'Tracks-Serial Number': '"false"'
    };

    // Build CSV row by mapping header columns to field values
    const csvFields = cleanColumns.map(col => {
        if (fieldValues.hasOwnProperty(col)) {
            return fieldValues[col];
        }
        return '';  // Empty string for unmapped columns
    });

    const csvDataRow = csvFields.join(',');

    // Build API request with BOTH header row and data row
    const payload = {
        "ImportRq": {
            "Type": "ImportPart",
            "Rows": {
                "Row": [
                    headers,      // Header row with column names
                    csvDataRow    // Data row with values
                ]
            }
        }
    };

    try {
        const response = runApiRequest('ImportRq', JSON.stringify(payload));

        if (!response) {
            debugLog('error', 'Save settings failed: No response from API');
            showToast('Failed to save settings: No response', 'error');
            return false;
        }

        const result = typeof response === 'string' ? JSON.parse(response) : response;

        if (result && result.ImportRs && result.ImportRs.statusCode === 1000) {
            const saveTimestamp = new Date().toLocaleString();
            debugLog('success', `✅ Settings saved at ${saveTimestamp}`);
            showToast(`Settings saved at ${saveTimestamp}`, 'success', 3000);
            return true;
        } else {
            let errorMsg = 'Save settings failed';
            if (result && result.ImportRs) {
                errorMsg += ` (Status: ${result.ImportRs.statusCode})`;
                if (result.ImportRs.statusMessage) {
                    errorMsg += `: ${result.ImportRs.statusMessage}`;
                }
            }
            debugLog('error', 'Save Settings Error:', result);
            showToast(errorMsg, 'error');
            return false;
        }
    } catch (error) {
        debugLog('error', 'Error saving settings:', error);
        showToast('Error saving settings: ' + error.message, 'error');
        return false;
    }
}

function queryImportHeaders() {
    // Query the required headers for ImportPart (for debugging/verification)
    const headerPayload = {
        "ImportHeaderRq": {
            "Type": "ImportPart"
        }
    };

    try {
        const headerResponse = runApiRequest('ImportHeaderRq', JSON.stringify(headerPayload));
        debugLog('info', 'Import Headers Response:', headerResponse);

        if (headerResponse) {
            const headerResult = typeof headerResponse === 'string' ? JSON.parse(headerResponse) : headerResponse;
            debugLog('info', 'Import Headers Parsed:', headerResult);

            if (headerResult && headerResult.ImportHeaderRs && headerResult.ImportHeaderRs.Header && headerResult.ImportHeaderRs.Header.Row) {
                const headerRow = headerResult.ImportHeaderRs.Header.Row;
                debugLog('info', 'Expected CSV Headers:', headerRow);
                return headerRow;
            }
        }
    } catch (e) {
        debugLog('error', 'Error querying import headers:', e);
    }
    return null;
}

function loadSettingsFromDatabase() {
    // Load settings from database via part.details field
    const selectQuery = `
        SELECT details
        FROM part
        WHERE num = '_settingsCapacityPlanner'
        LIMIT 1
    `;

    try {
        const result = JSON.parse(runQuery(selectQuery));
        if (result && result.length > 0 && result[0].details) {
            const base64Details = result[0].details;

            // Decode base64 to get JSON string
            const settingsJson = atob(base64Details);
            const settings = JSON.parse(settingsJson);

            const savedAtTime = settings.savedAt || 'unknown';
            debugLog('success', `✅ Settings loaded (saved at ${savedAtTime})`);

            return applySettings(settings);
        } else {
            debugLog('info', 'No saved settings found in database');
            return false;
        }
    } catch (error) {
        debugLog('warn', 'Could not load settings from database:', error);
        return false;
    }
}

// ============================================
// EVENT LISTENERS INITIALIZATION
// ============================================
function initializeEventListeners() {
    debugLog('info', 'Initializing event listeners...');

    // FILTERS
    const searchInput = document.getElementById('searchInput');
    if (searchInput) {
        searchInput.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            if (!term) {
                filteredWorkOrders = [...allWorkOrders];
            } else {
                filteredWorkOrders = allWorkOrders.filter(wo =>
                    wo.wo_num.toLowerCase().includes(term) ||
                    wo.mo_num.toLowerCase().includes(term) ||
                    (wo.category_name && wo.category_name.toLowerCase().includes(term)) ||
                    (wo.part_num && wo.part_num.toLowerCase().includes(term)) ||
                    (wo.description && wo.description.toLowerCase().includes(term))
                );
            }
            updateKPIs();
            renderCurrentView();  // Updates all views (gantt and capacity)
        });
        debugLog('info', '✓ searchInput event listener attached');
    }

    // SETTINGS
    const sameDayStartsToggle = document.getElementById('sameDayStartsToggle');
    if (sameDayStartsToggle) {
        sameDayStartsToggle.addEventListener('change', (e) => {
            allowSameDayStarts = e.target.checked;
            saveSettingsToDatabase();  // Auto-save when toggled
        });
        debugLog('info', '✓ sameDayStartsToggle event listener attached');
    }

    const shiftDependentWOsToggle = document.getElementById('shiftDependentWOsToggle');
    if (shiftDependentWOsToggle) {
        shiftDependentWOsToggle.addEventListener('change', (e) => {
            shiftDependentWOs = e.target.checked;
            saveSettingsToDatabase();  // Auto-save when toggled
        });
        debugLog('info', '✓ shiftDependentWOsToggle event listener attached');
    }

    const skipWeekendsToggle = document.getElementById('skipWeekendsToggle');
    if (skipWeekendsToggle) {
        skipWeekendsToggle.addEventListener('change', (e) => {
            skipWeekends = e.target.checked;
            saveSettingsToDatabase();  // Auto-save when toggled
        });
        debugLog('info', '✓ skipWeekendsToggle event listener attached');
    }

    // Status filter multi-select dropdown
    const statusFilterButton = document.getElementById('statusFilterButton');
    const statusFilterDropdown = document.getElementById('statusFilterDropdown');
    const statusFilterLabel = document.getElementById('statusFilterLabel');
    const statusFilterCheckboxes = document.querySelectorAll('.status-filter-checkbox');

    if (statusFilterButton && statusFilterDropdown) {
        // Toggle dropdown
        statusFilterButton.addEventListener('click', (e) => {
            e.stopPropagation();
            statusFilterDropdown.classList.toggle('hidden');
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            if (!statusFilterDropdown.contains(e.target) && !statusFilterButton.contains(e.target)) {
                statusFilterDropdown.classList.add('hidden');
            }
        });

        // Handle checkbox changes
        statusFilterCheckboxes.forEach(checkbox => {
            checkbox.addEventListener('change', () => {
                const value = checkbox.value;
                if (checkbox.checked) {
                    activeStatusFilters.add(value);
                } else {
                    activeStatusFilters.delete(value);
                }

                // Update label
                const checkedCount = document.querySelectorAll('.status-filter-checkbox:checked').length;
                if (checkedCount === 4) {
                    statusFilterLabel.textContent = 'All Status';
                } else if (checkedCount === 0) {
                    statusFilterLabel.textContent = 'None';
                } else {
                    statusFilterLabel.textContent = `${checkedCount} Selected`;
                }

                debugLog('info', `Status filters: ${Array.from(activeStatusFilters).join(', ')}`);
                renderGanttChart();
            });
        });

        debugLog('info', '✓ statusFilter multi-select event listeners attached');
    }

    const showArrowsToggle = document.getElementById('showArrowsToggle');
    if (showArrowsToggle) {
        showArrowsToggle.addEventListener('change', (e) => {
            showArrows = e.target.checked;
            renderGanttChart();
            saveSettingsToDatabase();  // Auto-save when toggled
        });
        debugLog('info', '✓ showArrowsToggle event listener attached');
    } else {
        debugLog('warn', '✗ showArrowsToggle element not found');
    }

    const showCompletedWOsToggle = document.getElementById('showCompletedWOsToggle');
    if (showCompletedWOsToggle) {
        showCompletedWOsToggle.addEventListener('change', (e) => {
            showCompletedWOs = e.target.checked;
            renderCurrentView();  // Re-render capacity planning and calendar
            saveSettingsToDatabase();  // Auto-save when toggled
        });
        debugLog('info', '✓ showCompletedWOsToggle event listener attached');
    } else {
        debugLog('warn', '✗ showCompletedWOsToggle element not found');
    }

    const dateFormatSelect = document.getElementById('dateFormatSelect');
    if (dateFormatSelect) {
        dateFormatSelect.addEventListener('change', (e) => {
            dateFormat = e.target.value;
            renderCurrentView();  // Re-render to apply new date format
            saveSettingsToDatabase();  // Auto-save when changed
        });
        debugLog('info', '✓ dateFormatSelect event listener attached');
    } else {
        debugLog('warn', '✗ dateFormatSelect element not found');
    }

    debugLog('success', 'Event listeners initialization complete');
}

// ============================================
// CAPACITY PLANNING
// ============================================

function initializeCapacitySettings() {
    // Extract unique categories from work orders
    const uniqueCategories = new Map();

    filteredWorkOrders.forEach(wo => {
        if (wo.calcategory_id && !uniqueCategories.has(wo.calcategory_id)) {
            uniqueCategories.set(wo.calcategory_id, {
                id: wo.calcategory_id,
                name: wo.calendar_category || 'Uncategorized',
                color: '#' + (wo.category_color || 'CCCCCC'),
                limits: [8, 8, 8, 8, 8, 0, 0] // Default: 8hrs Mon-Fri, 0hrs weekends
            });
        }
    });

    // Add uncategorized if needed
    if (!uniqueCategories.has(0)) {
        uniqueCategories.set(0, {
            id: 0,
            name: 'Uncategorized',
            color: '#CCCCCC',
            limits: [8, 8, 8, 8, 8, 0, 0]
        });
    }

    capacitySettings.categories = Array.from(uniqueCategories.values());
    debugLog('info', `Initialized ${capacitySettings.categories.length} categories for capacity planning`);
}

function getCapacity(categoryId, dayOfWeek) {
    const cat = capacitySettings.categories.find(c => c.id === categoryId);
    return cat ? cat.limits[dayOfWeek] : 0;
}

function setCapacity(categoryId, dayOfWeek, hours) {
    const cat = capacitySettings.categories.find(c => c.id === categoryId);
    if (cat) {
        cat.limits[dayOfWeek] = hours;
    }
}

function buildCapacityTable(weekStart) {
    const table = document.getElementById('capacityTable');
    if (!table) return;

    table.innerHTML = '';

    // Ensure weekStart is always a Monday
    if (weekStart.isoWeekday() !== 1) {
        weekStart = weekStart.clone().isoWeekday(1);
        currentCapacityWeek = weekStart;
    }

    // Show 1 week (7 days) - aligns with monthly calendar above
    const numWeeks = 1;
    const numDays = 7;
    const viewEnd = weekStart.clone().add(numDays, 'days');

    // Update week display to show full date range
    const weekDisplay = document.getElementById('capacityWeekDisplay');
    if (weekDisplay) {
        weekDisplay.textContent = `${weekStart.format('MMM D')} - ${viewEnd.clone().subtract(1, 'day').format('MMM D, YYYY')}`;
    }

    // Build header
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');
    headerRow.innerHTML = `<th class="sticky left-0 bg-slate-100 z-10 px-2 py-2 text-center text-sm font-bold text-slate-700 border-b-2 border-r-2 border-slate-300 w-20">
        <svg class="w-5 h-5 mx-auto text-slate-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z"></path>
        </svg>
    </th>`;

    const dayNames = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
    for (let day = 0; day < numDays; day++) {
        const currentDay = weekStart.clone().add(day, 'days');
        const dayOfWeek = day % 7;
        const isWeekend = dayOfWeek >= 5;
        const isToday = currentDay.isSame(moment(), 'day');
        const isWeekStart = dayOfWeek === 0;

        headerRow.innerHTML += `
            <th class="px-3 py-3 text-center text-xs font-bold ${isWeekend ? 'bg-amber-100' : 'bg-slate-100'} ${isToday ? 'bg-indigo-100 border-l-2 border-r-2 border-indigo-500' : 'border-l border-slate-300'} border-b-2 border-slate-400 min-w-[120px]">
                <div${isToday ? ' class="text-indigo-700 font-extrabold"' : ''}>${dayNames[dayOfWeek]}</div>
                <div class="text-slate-500 font-normal">${currentDay.format('D MMM')}</div>
            </th>
        `;
    }
    thead.appendChild(headerRow);
    table.appendChild(thead);

    // Build body with categories (sorted alphabetically by name)
    const tbody = document.createElement('tbody');

    const sortedCategories = [...capacitySettings.categories].sort((a, b) =>
        a.name.localeCompare(b.name)
    );

    sortedCategories.forEach(category => {
        // Category name row
        const row = document.createElement('tr');
        row.className = 'border-b-2 border-slate-300 group';

        // Category name cell spanning both WO row and stats row
        const categoryCell = document.createElement('td');
        categoryCell.rowSpan = 2; // Span both the WO tile row and stats row
        categoryCell.className = 'sticky left-0 bg-white z-10 px-2 py-2 border-r-2 border-slate-300 w-20';
        categoryCell.style.writingMode = 'vertical-rl';
        categoryCell.style.textOrientation = 'mixed';

        // Truncate long category names and add title attribute for full text
        const maxLength = 30;
        const displayName = category.name.length > maxLength ? category.name.substring(0, maxLength) + '...' : category.name;

        categoryCell.innerHTML = `
            <div class="flex flex-col items-center justify-center h-full gap-2">
                <span class="text-sm font-semibold text-slate-700" title="${category.name}" style="hyphens: auto; word-wrap: break-word;">${displayName}</span>
                <div class="w-3 h-3 rounded-full flex-shrink-0" style="background-color: ${category.color}"></div>
            </div>
        `;

        row.appendChild(categoryCell);

        // SVG cell spanning all days for WO bars
        const svgCell = document.createElement('td');
        svgCell.colSpan = numDays;
        svgCell.className = 'p-0 relative border-b border-slate-300';

        // Get all WOs for this category in this view
        const categoryWOs = getWOsForCategory(category.id, weekStart, numWeeks);

        // Create SVG container for WO bars
        const svgId = `capacity-svg-${category.id}`;
        const svgHeight = categoryWOs.lanes > 0 ? categoryWOs.lanes * 40 + 10 : 50;
        svgCell.innerHTML = `<svg id="${svgId}" width="100%" height="${svgHeight}"></svg>`;

        row.appendChild(svgCell);
        tbody.appendChild(row);

        // Create separate row for stat cells
        const statsRow = document.createElement('tr');
        statsRow.className = 'border-b-2 border-slate-300';

        // No category cell needed here - it spans from the row above

        // Individual stat cells to match header structure
        for (let day = 0; day < numDays; day++) {
            const dayOfWeek = day % 7;
            const capacity = category.limits[dayOfWeek];
            const isWeekend = dayOfWeek >= 5;
            const currentDay = weekStart.clone().add(day, 'days');
            const isToday = currentDay.isSame(moment(), 'day');
            const { usage } = getUsageForCategoryAndDay(category.id, currentDay);
            const percentage = capacity > 0 ? (usage / capacity) * 100 : 0;
            const isOverCapacity = usage > capacity;

            const statCell = document.createElement('td');
            // Match header border styling exactly
            statCell.className = `px-3 py-2 text-center border-t-2 border-slate-400 ${isWeekend ? 'bg-amber-100' : 'bg-slate-50'} ${isToday ? 'bg-indigo-100 border-l-2 border-r-2 border-indigo-500' : 'border-l border-slate-300'} ${isOverCapacity ? 'ring-2 ring-inset ring-red-600' : ''}`;
            statCell.innerHTML = `
                <div class="text-xs font-semibold ${isOverCapacity ? 'text-red-600' : 'text-slate-600'}">${usage.toFixed(2)}h / ${capacity}h</div>
                <div class="w-full bg-slate-200 rounded-full h-1.5 mt-1">
                    <div class="h-1.5 rounded-full ${isOverCapacity ? 'bg-red-500' : 'bg-green-500'}" style="width: ${Math.min(percentage, 100)}%"></div>
                </div>
            `;
            statsRow.appendChild(statCell);
        }
        tbody.appendChild(statsRow);
    });

    table.appendChild(tbody);

    // Render WO bars after browser finishes laying out the table
    // Use requestAnimationFrame to ensure table layout is complete
    requestAnimationFrame(() => {
        const sortedCategories = [...capacitySettings.categories].sort((a, b) =>
            a.name.localeCompare(b.name)
        );
        sortedCategories.forEach(category => {
            renderCapacityWOs(category, weekStart, numWeeks);
        });
        debugLog('info', `Capacity table built for week ${weekStart.format('MMM D, YYYY')}`);
    });
}

function getWOsForCategory(categoryId, weekStart, numWeeks = 1) {
    const viewEnd = weekStart.clone().add(numWeeks * 7, 'days');
    const wos = [];

    filteredWorkOrders.forEach(wo => {
        // Filter out completed WOs if setting is disabled
        if (!showCompletedWOs && wo.wo_status === 40) return;

        // Match category
        if (wo.calcategory_id !== categoryId) return;

        const woStart = moment(wo.date_scheduled_start);
        const woEnd = moment(wo.date_scheduled);

        // Check if WO overlaps with this view
        if (woStart.isBefore(viewEnd) && woEnd.isAfter(weekStart)) {
            wos.push(wo);
        }
    });

    // Pack WOs into lanes
    const lanes = packWOsIntoLanes(wos);

    return { wos, lanes };
}

function getUsageForCategoryAndDay(categoryId, currentDay) {
    const checkDay = currentDay.clone().startOf('day');

    let usage = 0;
    let matchedWOs = 0;
    let wosWithNoLabor = 0;

    filteredWorkOrders.forEach(wo => {
        // Filter out completed WOs if setting is disabled
        if (!showCompletedWOs && wo.wo_status === 40) return;

        // Match category
        if (wo.calcategory_id !== categoryId) return;

        // Use startOf('day') for both dates to match tile rendering logic
        const woStart = moment(wo.date_scheduled_start).startOf('day');
        let woEnd = moment(wo.date_scheduled).startOf('day');

        // For completed WOs, use date_finished if available and earlier than date_scheduled
        // This prevents completed WOs from inflating capacity in future days
        if (wo.wo_status === 40 && wo.date_finished) {
            const dateFinished = moment(wo.date_finished).startOf('day');
            // Use the earlier of date_finished or date_scheduled
            woEnd = moment.min(woEnd, dateFinished);
        }

        // Check if this day falls within the WO date range (inclusive)
        if (checkDay.isSameOrAfter(woStart) && checkDay.isSameOrBefore(woEnd)) {
            // If skip weekends is enabled and this is a weekend day, skip it
            if (skipWeekends) {
                const dayOfWeek = checkDay.day();
                if (dayOfWeek === 0 || dayOfWeek === 6) {
                    // Weekend day - don't count any hours
                    return;
                }
            }

            // Calculate hours for this day
            const laborHoursPerUnit = parseFloat(wo.labor_hours_from_bom) || 0;
            const qtyTarget = parseFloat(wo.qty_target) || 1;
            const totalHours = laborHoursPerUnit * qtyTarget;

            // Calculate days to divide hours across
            let daysInWO;
            if (skipWeekends) {
                // Count only weekdays
                daysInWO = countWeekdaysInRange(woStart, woEnd);
            } else {
                // Count all days (inclusive)
                daysInWO = woEnd.diff(woStart, 'days') + 1;
            }

            const hoursPerDay = daysInWO > 0 ? totalHours / daysInWO : 0;

            if (totalHours > 0) {
                matchedWOs++;
                const dayType = skipWeekends ? 'weekdays' : 'days';
                debugLog('debug', `  WO ${wo.wo_num}: ${totalHours}hrs / ${daysInWO}${dayType} = ${hoursPerDay.toFixed(2)}hrs/day (${woStart.format('YYYY-MM-DD')} to ${woEnd.format('YYYY-MM-DD')})`);
            } else {
                wosWithNoLabor++;
                debugLog('warn', `  WO ${wo.wo_num} has NO labor hours (labor_hours_from_bom = ${wo.labor_hours_from_bom})`);
            }

            usage += hoursPerDay;
        }
    });

    if (matchedWOs > 0) {
        debugLog('debug', `  Total: ${matchedWOs} WOs matched for category ${categoryId} on ${checkDay.format('YYYY-MM-DD')}`);
    }

    if (wosWithNoLabor > 0) {
        debugLog('warn', `  ⚠️ ${wosWithNoLabor} WO(s) have no labor hours and contribute 0 to capacity!`);
    }

    return { usage };
}

function renderCapacityWOs(category, weekStart, numWeeks = 1) {
    const svgId = `capacity-svg-${category.id}`;
    const svg = d3.select(`#${svgId}`);
    if (svg.empty()) return;

    svg.selectAll('*').remove();

    const viewEnd = weekStart.clone().add(numWeeks * 7, 'days');

    const svgNode = svg.node();
    const height = parseInt(svg.attr('height'));
    const numDays = numWeeks * 7;

    // Read actual column positions from table headers after they're rendered
    const table = document.getElementById('capacityTable');
    const headerCells = table.querySelectorAll('thead th');

    // Get the SVG's bounding rectangle
    const svgRect = svgNode.getBoundingClientRect();

    // Build arrays of column positions and widths
    const dayPositions = [];
    const dayWidths = [];

    // Skip first header (category column) and read day columns
    for (let i = 1; i < headerCells.length && i <= numDays; i++) {
        const cell = headerCells[i];
        const cellRect = cell.getBoundingClientRect();
        // Calculate position relative to SVG's left edge
        const relativeLeft = cellRect.left - svgRect.left;
        dayPositions.push(relativeLeft);
        dayWidths.push(cellRect.width);
    }

    // Set SVG width to match the total width of all day columns
    const totalWidth = dayPositions.length > 0
        ? (dayPositions[dayPositions.length - 1] + dayWidths[dayWidths.length - 1])
        : numDays * 120;
    svg.attr('width', totalWidth);

    // Create xScale based on actual column positions
    const xScale = (date) => {
        const dayIndex = moment(date).diff(weekStart, 'days');
        if (dayIndex < 0 || dayPositions.length === 0) return dayPositions[0] || 0;
        if (dayIndex >= dayPositions.length) return dayPositions[dayPositions.length - 1] + dayWidths[dayWidths.length - 1];
        return dayPositions[dayIndex];
    };

    // Draw day dividers and weekend backgrounds
    for (let day = 0; day < dayPositions.length; day++) {
        const dayOfWeek = day % 7;
        const isWeekend = dayOfWeek >= 5;
        const dayStart = weekStart.clone().add(day, 'days');
        const x = dayPositions[day];
        const dayWidth = dayWidths[day];

        const isToday = dayStart.isSame(moment(), 'day');

        if (isWeekend) {
            svg.append('rect')
                .attr('x', x)
                .attr('y', 0)
                .attr('width', dayWidth)
                .attr('height', height)
                .attr('fill', '#fffbeb')
                .attr('opacity', 0.5);
        }

        // Today indicator - indigo background
        if (isToday) {
            svg.append('rect')
                .attr('x', x)
                .attr('y', 0)
                .attr('width', dayWidth)
                .attr('height', height)
                .attr('fill', '#EEF2FF') // indigo-50
                .attr('opacity', 0.8);
        }

        // Day divider - no special Monday border, today gets indigo borders
        svg.append('line')
            .attr('x1', x)
            .attr('x2', x)
            .attr('y1', 0)
            .attr('y2', height)
            .attr('stroke', isToday ? '#818CF8' : '#e2e8f0') // indigo-400 for today
            .attr('stroke-width', isToday ? 2 : 1);

        // Right border for today column
        if (isToday) {
            svg.append('line')
                .attr('x1', x + dayWidth)
                .attr('x2', x + dayWidth)
                .attr('y1', 0)
                .attr('y2', height)
                .attr('stroke', '#818CF8') // indigo-400
                .attr('stroke-width', 2);
        }
    }

    // Get WOs for this category
    const { wos } = getWOsForCategory(category.id, weekStart, numWeeks);
    if (wos.length === 0) return;

    // Render each WO
    wos.forEach(wo => {
        // Use start of day for start and end of day for finish to ignore time component
        const woStart = moment(wo.date_scheduled_start).startOf('day');
        let woEnd = moment(wo.date_scheduled).endOf('day');

        // For completed WOs, use date_finished if available and earlier than date_scheduled
        // This ensures visual representation matches capacity calculations
        if (wo.wo_status === 40 && wo.date_finished) {
            const dateFinished = moment(wo.date_finished).endOf('day');
            // Use the earlier of date_finished or date_scheduled
            woEnd = moment.min(woEnd, dateFinished);
        }

        // Clamp to visible view
        const visibleStart = moment.max(woStart, weekStart);
        const visibleEnd = moment.min(woEnd, viewEnd);

        const x = xScale(visibleStart.toDate());

        // For end position, we need the RIGHT edge of the day, not the left edge
        const endDayIndex = moment(visibleEnd).diff(weekStart, 'days');
        const xEnd = (endDayIndex >= 0 && endDayIndex < dayPositions.length)
            ? dayPositions[endDayIndex] + dayWidths[endDayIndex]
            : xScale(visibleEnd.toDate());
        const barWidth = xEnd - x;

        // Add padding so tiles don't touch cell edges
        const horizontalPadding = 4;
        const paddedX = x + horizontalPadding;
        const paddedWidth = Math.max(0, barWidth - (horizontalPadding * 2));

        const lane = wo._lane || 0;
        const y = 10 + (lane * 40);
        const barHeight = 35; // Keep larger for capacity view (has 2 lines of text)

        // Calculate total hours and hours per day
        const laborHoursPerUnit = parseFloat(wo.labor_hours_from_bom) || 0;
        const qtyTarget = parseFloat(wo.qty_target) || 1;
        const totalHours = laborHoursPerUnit * qtyTarget;

        // Calculate days to divide hours across
        let daysInWO;
        if (skipWeekends) {
            // Count only weekdays
            daysInWO = countWeekdaysInRange(woStart, woEnd);
        } else {
            // Count all days
            daysInWO = Math.ceil(woEnd.diff(woStart, 'days', true)) || 1;
        }

        const hoursPerDay = daysInWO > 0 ? totalHours / daysInWO : 0;

        // Status colors
        // Use standard color scheme
        const colors = WO_STATUS_COLORS[wo.wo_status] || WO_STATUS_COLORS[10];
        const barColor = colors.fill;
        const borderColor = colors.stroke;

        // WO bar background (with padding)
        const bar = svg.append('rect')
            .attr('x', paddedX)
            .attr('y', y)
            .attr('width', paddedWidth)
            .attr('height', barHeight)
            .attr('fill', barColor)
            .attr('stroke', borderColor)
            .attr('stroke-width', 2)
            .attr('rx', 4)
            .attr('class', 'wo-bar')
            .attr('data-wo-id', wo.wo_id)
            .attr('data-wo-num', wo.wo_num);

        // Custom CSS tooltip
        const finishedGoodInfo = wo.part_num ? `${wo.part_num}` : 'N/A';
        const descriptionInfo = wo.description ? wo.description : '';
        const capacityTooltipHTML = `
            <div><span class="wo-tooltip-label">WO:</span><span class="wo-tooltip-value">${wo.wo_num}</span></div>
            <div><span class="wo-tooltip-label">Finished Good:</span><span class="wo-tooltip-value">${finishedGoodInfo}</span></div>
            ${descriptionInfo ? `<div><span class="wo-tooltip-label">Description:</span><span class="wo-tooltip-value">${descriptionInfo}</span></div>` : ''}
            <div><span class="wo-tooltip-label">Total Hours:</span><span class="wo-tooltip-value">${totalHours.toFixed(2)}h</span></div>
            <div><span class="wo-tooltip-label">Hours per Day:</span><span class="wo-tooltip-value">${hoursPerDay.toFixed(2)}h</span></div>
        `;

        bar.on('mouseover', function(event) {
            showWOTooltip(event, capacityTooltipHTML);
        }).on('mouseout', function() {
            hideWOTooltip();
        }).on('mousemove', function(event) {
            showWOTooltip(event, capacityTooltipHTML);
        });

        // Double-click to open WO in Fishbowl
        bar.on('dblclick', function() {
            debugLog('info', `Opening WO ${wo.wo_num} in Fishbowl...`);
            try {
                if (typeof openModule === 'function') {
                    openModule('Work Order', wo.wo_num);
                    showToast(`Opening WO ${wo.wo_num}`, 'info');
                } else {
                    debugLog('warn', 'openModule function not available in Fishbowl');
                    showToast('Cannot open WO - not running in Fishbowl', 'error');
                }
            } catch (error) {
                debugLog('error', 'Error opening WO:', error);
                showToast('Error opening WO: ' + error.message, 'error');
            }
        });

        // Add drag behavior
        const woId = wo.wo_id;
        let dragStartX = paddedX;
        let dragStartY = y;
        let isDragging = false;
        let totalDragDistance = 0;
        let associatedTexts = []; // Store text elements that belong to this WO
        let dragOverlay = null; // Overlay element for cross-category dragging

        const dragBehavior = d3.drag()
            .on('start', function(event) {
                dragStartX = parseFloat(d3.select(this).attr('x'));
                dragStartY = parseFloat(d3.select(this).attr('y'));
                isDragging = false;
                totalDragDistance = 0;
                hideWOTooltip();

                // Find and store all text elements that belong to this WO
                associatedTexts = [];
                svg.selectAll('text').each(function() {
                    const text = d3.select(this);
                    const textX = parseFloat(text.attr('x'));
                    const textY = parseFloat(text.attr('y'));

                    // Check if this text belongs to this WO by initial position
                    // Label text is at (paddedX + 6, y + barHeight/2 - 4)
                    if (Math.abs(textX - (dragStartX + 6)) < 5 &&
                        Math.abs(textY - (dragStartY + barHeight / 2 - 4)) < 5) {
                        associatedTexts.push({
                            element: text,
                            offsetX: textX - dragStartX,
                            offsetY: textY - dragStartY
                        });
                    }
                    // Daily hours text is centered in each day column
                    else if (textY >= dragStartY + barHeight / 2 &&
                             textY <= dragStartY + barHeight &&
                             text.attr('text-anchor') === 'middle') {
                        // Check if it's roughly within the WO's horizontal span
                        const woStartX = dragStartX;
                        const woEndX = dragStartX + parseFloat(d3.select('.wo-bar[data-wo-id="' + woId + '"]').attr('width'));
                        if (textX >= woStartX - 20 && textX <= woEndX + 20) {
                            associatedTexts.push({
                                element: text,
                                offsetX: textX - dragStartX,
                                offsetY: textY - dragStartY
                            });
                        }
                    }
                });
            })
            .on('drag', function(event) {
                // Track total drag distance
                totalDragDistance += Math.abs(event.dx) + Math.abs(event.dy);

                // Only start visual dragging if we've moved more than 5 pixels
                if (totalDragDistance > 5) {
                    if (!isDragging) {
                        // First time exceeding threshold - apply drag styling
                        isDragging = true;
                        const draggedBar = d3.select(this);

                        // Hide the original bar and text
                        draggedBar.attr('opacity', 0.3);
                        associatedTexts.forEach(t => t.element.attr('opacity', 0.3));

                        // Create a drag overlay that sits above everything
                        const barRect = this.getBoundingClientRect();
                        dragOverlay = document.createElement('div');
                        dragOverlay.style.position = 'fixed';
                        dragOverlay.style.left = barRect.left + 'px';
                        dragOverlay.style.top = barRect.top + 'px';
                        dragOverlay.style.width = barRect.width + 'px';
                        dragOverlay.style.height = barHeight + 'px';
                        dragOverlay.style.backgroundColor = barColor;
                        dragOverlay.style.border = `2px solid ${borderColor}`;
                        dragOverlay.style.borderRadius = '4px';
                        dragOverlay.style.opacity = '0.7';
                        dragOverlay.style.pointerEvents = 'none';
                        dragOverlay.style.zIndex = '10000';
                        dragOverlay.style.boxShadow = '0 4px 6px rgba(0,0,0,0.2)';
                        dragOverlay.innerHTML = `<div style="padding: 4px 6px; font-size: 11px; font-weight: 600; color: #06162d;">${labelText}</div>`;
                        document.body.appendChild(dragOverlay);
                    }

                    // Update overlay position to follow mouse
                    if (dragOverlay) {
                        const currentLeft = parseFloat(dragOverlay.style.left);
                        const currentTop = parseFloat(dragOverlay.style.top);
                        dragOverlay.style.left = (currentLeft + event.dx) + 'px';
                        dragOverlay.style.top = (currentTop + event.dy) + 'px';
                    }

                    // Still move the original bar (hidden) for position tracking
                    const newX = parseFloat(d3.select(this).attr('x')) + event.dx;
                    const newY = parseFloat(d3.select(this).attr('y')) + event.dy;
                    d3.select(this).attr('x', newX).attr('y', newY);

                    // Move associated text elements
                    associatedTexts.forEach(textInfo => {
                        textInfo.element
                            .attr('x', newX + textInfo.offsetX)
                            .attr('y', newY + textInfo.offsetY);
                    });
                }
            })
            .on('end', function(event) {
                // Remove drag overlay
                if (dragOverlay) {
                    dragOverlay.remove();
                    dragOverlay = null;
                }

                // Reset styling
                d3.select(this)
                    .attr('opacity', 1)
                    .attr('stroke-width', 2);

                // Reset text opacity
                associatedTexts.forEach(t => t.element.attr('opacity', 1));

                // If we never started dragging, it was just a click - do nothing
                if (!isDragging) {
                    return;
                }

                // Get the final position
                const finalX = parseFloat(d3.select(this).attr('x'));
                const finalY = parseFloat(d3.select(this).attr('y'));

                // Calculate which day based on X position
                let targetDay = null;
                for (let i = 0; i < dayPositions.length; i++) {
                    const dayX = dayPositions[i];
                    const dayW = dayWidths[i];
                    if (finalX >= dayX && finalX < dayX + dayW) {
                        targetDay = weekStart.clone().add(i, 'days');
                        break;
                    }
                }

                // Calculate which category based on Y position
                // Only check for category change if Y movement was significant
                const draggedY = finalY - dragStartY;
                const draggedX = finalX - dragStartX;
                let targetCategory = null;

                // Only detect category change if vertical movement is significant (>30px)
                // AND greater than horizontal movement (primarily vertical drag)
                if (Math.abs(draggedY) > 30 && Math.abs(draggedY) > Math.abs(draggedX)) {
                    debugLog('info', `Category drag detected: Y=${draggedY.toFixed(1)}px, X=${draggedX.toFixed(1)}px`);
                    const table = document.getElementById('capacityTable');
                    const tbody = table.querySelector('tbody');
                    const categoryRows = tbody.querySelectorAll('tr:nth-child(odd)'); // Odd rows are category WO rows

                    // Get sorted categories to match table row order (categories are sorted alphabetically in buildCapacityTable)
                    const sortedCategories = [...capacitySettings.categories].sort((a, b) =>
                        a.name.localeCompare(b.name)
                    );

                    categoryRows.forEach((row, idx) => {
                        const svgCell = row.querySelector('td:last-child');
                        if (svgCell) {
                            const svgElement = svgCell.querySelector('svg');
                            if (svgElement) {
                                const rect = svgElement.getBoundingClientRect();
                                const mouseY = event.sourceEvent.clientY;
                                if (mouseY >= rect.top && mouseY <= rect.bottom) {
                                    // Use sortedCategories instead of capacitySettings.categories to match table order
                                    const detectedCategory = sortedCategories[idx];
                                    debugLog('info', `Mouse over category ${idx}: ${detectedCategory?.name} (ID: ${detectedCategory?.id}), WO current category: ${wo.calcategory_id}`);
                                    // Only set if different from current category
                                    if (detectedCategory && detectedCategory.id !== wo.calcategory_id) {
                                        targetCategory = detectedCategory;
                                        debugLog('success', `Target category set to: ${targetCategory.name} (ID: ${targetCategory.id})`);
                                    }
                                }
                            }
                        }
                    });
                }

                // Only process drop if something actually changed
                let hasChanges = false;
                let categoryChanged = false;

                // Check if category actually changed
                if (targetCategory) {
                    categoryChanged = true;
                    hasChanges = true;
                }

                // Check if day changed (only if we found a valid target day)
                if (targetDay) {
                    const originalStart = moment(wo.date_scheduled_start).startOf('day');
                    if (!targetDay.isSame(originalStart, 'day')) {
                        hasChanges = true;
                    }
                }

                // Handle the drop only if there are actual changes
                if (hasChanges) {
                    handleCapacityWODrop(wo, targetDay, categoryChanged ? targetCategory : null, weekStart);
                } else {
                    // No changes - snap back to original position
                    renderCurrentView();
                }
            });

        bar.call(dragBehavior);

        // WO label - show WO number or BOM number (based on viewByMode) and total hours
        const woLabel = getWOLabel(wo, 17); // Truncate to 17 chars for capacity tiles
        const labelText = viewByMode === 'bom_num'
            ? `${woLabel} (${totalHours.toFixed(2)}h)`
            : `WO ${woLabel} (${totalHours.toFixed(2)}h)`;
        svg.append('text')
            .attr('x', paddedX + 6)
            .attr('y', y + barHeight / 2 - 4)
            .attr('font-size', '11px')
            .attr('font-weight', '600')
            .attr('fill', '#06162d') // Fishbowl dark text
            .attr('pointer-events', 'none')
            .text(labelText);

        // Daily breakdown - show hours per day aligned under each day
        // Since we're using full days now, each day gets equal hours
        let currentDay = visibleStart.clone().startOf('day');
        const breakdown = [];
        while (currentDay.isBefore(visibleEnd)) {
            const dayEnd = currentDay.clone().add(1, 'day');

            // Check if this day overlaps with the WO
            if (currentDay.isBefore(woEnd) && dayEnd.isAfter(woStart)) {
                const dayIndex = currentDay.diff(weekStart, 'days');
                if (dayIndex >= 0 && dayIndex < dayPositions.length) {
                    const dayX = dayPositions[dayIndex];
                    const dayWidth = dayWidths[dayIndex];

                    // Calculate the visible portion of this day within the WO bar (with padding)
                    const visibleDayStart = Math.max(dayX, paddedX);
                    const visibleDayEnd = Math.min(dayX + dayWidth, paddedX + paddedWidth);
                    const visibleDayWidth = visibleDayEnd - visibleDayStart;

                    // Only show hours if there's enough space (at least 30px)
                    if (visibleDayWidth >= 30) {
                        // Center the hours text within the visible portion
                        svg.append('text')
                            .attr('x', visibleDayStart + visibleDayWidth / 2)
                            .attr('y', y + barHeight / 2 + 10)
                            .attr('font-size', '9px')
                            .attr('fill', '#64748b')
                            .attr('text-anchor', 'middle')
                            .attr('pointer-events', 'none')
                            .text(`${hoursPerDay.toFixed(2)}h`);
                    }
                }
            }

            currentDay.add(1, 'day');
        }

        // TODO: Add drag and resize handlers
    });
}

function openCapacitySettingsModal() {
    const dayNames = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];

    const modalHtml = `
        <div class="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center" id="capacityModal" onclick="if(event.target===this) closeCapacityModal()">
            <div class="bg-white rounded-lg shadow-xl max-w-4xl w-full m-4 max-h-[90vh] overflow-auto">
                <div class="sticky top-0 bg-white flex items-center justify-between p-4 border-b border-slate-200">
                    <h3 class="text-lg font-bold text-slate-800">Capacity Settings</h3>
                    <button onclick="closeCapacityModal()" class="p-1 hover:bg-slate-100 rounded">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
                <div class="p-4">
                    <table class="w-full border-collapse">
                        <thead>
                            <tr>
                                <th class="border border-slate-300 bg-slate-50 px-3 py-2 text-left text-sm font-bold text-slate-700">Category</th>
                                ${dayNames.map(day => `<th class="border border-slate-300 bg-slate-50 px-3 py-2 text-center text-sm font-bold text-slate-700">${day}</th>`).join('')}
                            </tr>
                        </thead>
                        <tbody>
                            ${capacitySettings.categories.map((category, catIdx) => `
                                <tr>
                                    <td class="border border-slate-300 px-3 py-2 text-sm font-medium text-slate-700 bg-slate-50">
                                        <div class="flex items-center gap-2">
                                            <div class="w-3 h-3 rounded-full flex-shrink-0" style="background-color: ${category.color}"></div>
                                            ${category.name}
                                        </div>
                                    </td>
                                    ${dayNames.map((day, dayIdx) => `
                                        <td class="border border-slate-300 px-2 py-2 text-center">
                                            <input type="number"
                                                   class="capacity-input w-full px-2 py-1 border border-slate-300 rounded text-sm text-center"
                                                   data-category="${catIdx}"
                                                   data-day="${dayIdx}"
                                                   value="${category.limits[dayIdx]}"
                                                   min="0"
                                                   max="24"
                                                   step="0.5">
                                        </td>
                                    `).join('')}
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
                <div class="sticky bottom-0 bg-white flex items-center justify-end gap-2 p-4 border-t border-slate-200">
                    <button onclick="closeCapacityModal()" class="px-4 py-2 text-sm font-medium text-slate-700 hover:bg-slate-100 rounded-lg">
                        Cancel
                    </button>
                    <button onclick="saveAllCapacitySettings()" class="px-4 py-2 text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 rounded-lg">
                        Save All
                    </button>
                </div>
            </div>
        </div>
    `;

    document.body.insertAdjacentHTML('beforeend', modalHtml);
}

function closeCapacityModal() {
    debugLog('info', 'closeCapacityModal called');
    const modal = document.getElementById('capacityModal');
    if (!modal) {
        debugLog('warn', 'Modal not found');
        return;
    }

    // Save any changed settings before closing
    const inputs = modal.querySelectorAll('.capacity-input');
    debugLog('info', `Found ${inputs.length} capacity inputs`);
    let hasChanges = false;

    inputs.forEach(input => {
        const categoryIndex = parseInt(input.dataset.category);
        const dayIndex = parseInt(input.dataset.day);
        const hours = parseFloat(input.value);

        if (!isNaN(categoryIndex) && !isNaN(dayIndex) && !isNaN(hours)) {
            const category = capacitySettings.categories[categoryIndex];
            if (category) {
                debugLog('info', `Setting capacity for category ${category.id}, day ${dayIndex}: ${hours} hours`);
                setCapacity(category.id, dayIndex, hours);
                hasChanges = true;
            }
        }
    });

    debugLog('info', `hasChanges: ${hasChanges}`);
    modal.remove();

    // Rebuild capacity table and save settings
    if (hasChanges) {
        buildCapacityTable(currentCapacityWeek);
        debugLog('info', 'Capacity settings updated, saving to database...');
        saveSettingsToDatabase();

        // Refresh KPIs to reflect new capacity limits
        updateKPIs();
        debugLog('info', 'KPIs refreshed with updated capacity settings');
    } else {
        debugLog('info', 'No changes detected, skipping save');
    }
}

function saveAllCapacitySettings() {
    // This function is kept for the "Save" button, but it just calls closeCapacityModal now
    closeCapacityModal();
}

function changeCapacityWeek(direction) {
    if (!currentCapacityWeek) {
        currentCapacityWeek = moment().startOf('isoWeek');
    }

    // Add/subtract weeks and ensure we snap to Monday
    currentCapacityWeek = currentCapacityWeek.clone().add(direction, 'weeks').startOf('isoWeek');
    buildCapacityTable(currentCapacityWeek);
}

function goToCapacityToday() {
    // Snap to current week's Monday
    currentCapacityWeek = moment().startOf('isoWeek');
    buildCapacityTable(currentCapacityWeek);
    showToast('Jumped to current week', 'info');
}

// ============================================
// MONTHLY CALENDAR VIEW
// ============================================
let currentCalendarMonth = moment();
let calendarExpanded = false;

function toggleMonthCalendar() {
    calendarExpanded = !calendarExpanded;
    const content = document.getElementById('monthCalendarContent');
    const chevron = document.getElementById('calendarChevron');

    if (calendarExpanded) {
        content.style.display = 'block';
        chevron.style.transform = 'rotate(180deg)';
        buildMonthCalendar();
    } else {
        content.style.display = 'none';
        chevron.style.transform = 'rotate(0deg)';
    }
    saveSettingsToDatabase();  // Auto-save calendar expanded state
}

function changeCalendarMonth(direction) {
    currentCalendarMonth = currentCalendarMonth.clone().add(direction, 'months');
    buildMonthCalendar();
}

function goToCalendarToday() {
    currentCalendarMonth = moment();
    buildMonthCalendar();
    debugLog('info', 'Jumped to current month in calendar');
}

function toggleCalendarColorMode() {
    const select = document.getElementById('calendarColorModeSelect');
    calendarColorMode = select.value;
    buildMonthCalendar();
    saveSettingsToDatabase();
    debugLog('info', `Calendar color mode changed to: ${calendarColorMode}`);
}

function toggleViewByMode() {
    const select = document.getElementById('viewByModeSelect');
    viewByMode = select.value;
    buildMonthCalendar();
    buildCapacityTable(currentCapacityWeek);
    saveSettingsToDatabase();
    debugLog('info', `View by mode changed to: ${viewByMode}`);
}

function getWOLabel(wo, maxLength = null) {
    if (viewByMode === 'bom_num') {
        const bomNum = wo.bom_num || 'N/A';
        const qty = wo.qty_target || '?';
        let label = `${bomNum} x${qty}`;
        // Truncate if needed
        if (maxLength && label.length > maxLength) {
            label = label.substring(0, maxLength - 1) + '…';
        }
        return label;
    } else {
        // Default: WO number
        return wo.wo_num;
    }
}

function scrollCapacityToWeek(weekStart) {
    // Update capacity view to show this week
    currentCapacityWeek = weekStart.clone().startOf('isoWeek');
    buildCapacityTable(currentCapacityWeek);

    // Scroll the capacity table into view smoothly
    const capacityTable = document.getElementById('capacityTable');
    if (capacityTable) {
        capacityTable.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
}

async function handleCalendarWODrop(dragData, dropDateStr) {
    // Find the WO in allWorkOrders
    const wo = allWorkOrders.find(w => w.wo_id === dragData.wo_id);
    if (!wo) {
        debugLog('error', `WO ${dragData.wo_num} not found in allWorkOrders`);
        return;
    }

    // Calculate the date shift
    const originalStart = moment(dragData.originalStart);
    const originalEnd = moment(dragData.originalEnd);
    const dropDate = moment(dropDateStr);
    const daysDiff = dropDate.diff(originalStart, 'days');

    if (daysDiff === 0) {
        debugLog('info', `WO ${dragData.wo_num} dropped on same date, no change needed`);
        return;
    }

    // Calculate new dates
    const newStart = originalStart.clone().add(daysDiff, 'days');
    const newEnd = originalEnd.clone().add(daysDiff, 'days');

    debugLog('info', `Moving WO ${dragData.wo_num} by ${daysDiff} days: ${originalStart.format('YYYY-MM-DD')} → ${newStart.format('YYYY-MM-DD')}`);

    // Save to database using the async function
    await saveWODates(dragData.wo_num, newStart.format('YYYY-MM-DD'), newEnd.format('YYYY-MM-DD'));
}

async function handleCapacityWODrop(wo, targetDay, targetCategory, currentWeekStart) {
    debugLog('info', `handleCapacityWODrop called for WO ${wo.wo_num}, targetCategory: ${targetCategory ? targetCategory.name + ' (ID: ' + targetCategory.id + ')' : 'null'}`);

    let hasChanges = false;
    const changes = [];
    let newStart, newEnd;

    // Handle date change
    if (targetDay) {
        const originalStart = moment(wo.date_scheduled_start);
        const originalEnd = moment(wo.date_scheduled);
        const daysDiff = targetDay.diff(originalStart.startOf('day'), 'days');

        if (daysDiff !== 0) {
            newStart = originalStart.clone().add(daysDiff, 'days');
            newEnd = originalEnd.clone().add(daysDiff, 'days');

            changes.push(`date: ${originalStart.format('YYYY-MM-DD')} → ${newStart.format('YYYY-MM-DD')}`);
            hasChanges = true;
        }
    }

    // Handle category change
    let categoryChanged = false;
    if (targetCategory && targetCategory.id !== wo.calcategory_id) {
        const oldCategoryName = wo.calendar_category || 'Uncategorized';
        changes.push(`category: ${oldCategoryName} → ${targetCategory.name}`);
        categoryChanged = true;
        hasChanges = true;
        debugLog('info', `Category change detected: ${oldCategoryName} (ID: ${wo.calcategory_id}) → ${targetCategory.name} (ID: ${targetCategory.id})`);
    } else if (targetCategory) {
        debugLog('info', `No category change - target ${targetCategory.id} is same as current ${wo.calcategory_id}`);
    }

    if (hasChanges) {
        debugLog('info', `Moving WO ${wo.wo_num}: ${changes.join(', ')}`);

        // Save date changes first if any
        if (newStart && newEnd) {
            debugLog('info', `Calling saveWODates for WO ${wo.wo_num}`);
            await saveWODates(wo.wo_num, newStart.format('YYYY-MM-DD'), newEnd.format('YYYY-MM-DD'));
        }

        // Then save category change if any
        if (categoryChanged) {
            debugLog('info', `Calling saveWOCategory for WO ${wo.wo_num} with category ID ${targetCategory.id}`);
            await saveWOCategory(wo.wo_num, targetCategory.id);
        }

        // Reload work orders to reflect changes
        debugLog('info', `Reloading work orders after WO ${wo.wo_num} changes`);
        loadWorkOrders();
    } else {
        debugLog('info', `WO ${wo.wo_num} dropped with no changes`);
        renderCurrentView(); // Still refresh to snap back to original position
    }
}

function buildMonthCalendar() {
    const container = document.getElementById('monthCalendar');
    if (!container) return;

    container.innerHTML = '';

    const monthStart = currentCalendarMonth.clone().startOf('month');
    const monthEnd = currentCalendarMonth.clone().endOf('month');

    // Update month display
    const monthDisplay = document.getElementById('calendarMonthDisplay');
    if (monthDisplay) {
        monthDisplay.textContent = monthStart.format('MMMM YYYY');
    }

    // Calculate calendar grid (start from Monday of first week)
    const calendarStart = monthStart.clone().startOf('isoWeek');
    const calendarEnd = monthEnd.clone().endOf('isoWeek');
    const totalDays = calendarEnd.diff(calendarStart, 'days') + 1;
    const numWeeks = Math.ceil(totalDays / 7);

    // Pre-calculate max lanes per week row for dynamic height
    const maxLanesPerWeek = new Array(numWeeks).fill(0);

    // Get all WOs for this month and pack them
    const calendarEndForWOs = calendarStart.clone().add(totalDays, 'days');
    const wosInMonth = [];
    filteredWorkOrders.forEach(wo => {
        const woStart = moment(wo.date_scheduled_start).startOf('day');
        const woEnd = moment(wo.date_scheduled).endOf('day');
        if (woStart.isBefore(calendarEndForWOs) && woEnd.isAfter(calendarStart)) {
            wosInMonth.push(wo);
        }
    });
    packWOsIntoLanes(wosInMonth);

    // Calculate max lanes for each week
    wosInMonth.forEach(wo => {
        const woStart = moment(wo.date_scheduled_start).startOf('day');
        const woEnd = moment(wo.date_scheduled).endOf('day');
        const startDayIndex = Math.max(0, woStart.diff(calendarStart, 'days'));
        const endDayIndex = Math.min(totalDays - 1, woEnd.diff(calendarStart, 'days'));

        if (startDayIndex < totalDays && endDayIndex >= 0) {
            const startRow = Math.floor(startDayIndex / 7);
            const endRow = Math.floor(endDayIndex / 7);

            // Only count single-row WOs for now
            if (startRow === endRow && startRow < numWeeks) {
                const lane = wo._lane || 0;
                maxLanesPerWeek[startRow] = Math.max(maxLanesPerWeek[startRow], lane + 1);
            }
        }
    });

    // Create table structure
    const table = document.createElement('table');
    table.className = 'w-full border-collapse';

    // Header row with day names
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');
    const dayNames = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
    dayNames.forEach(day => {
        const th = document.createElement('th');
        th.className = 'px-2 py-2 text-xs font-bold text-slate-700 border border-slate-300 bg-slate-100';
        th.textContent = day;
        headerRow.appendChild(th);
    });
    thead.appendChild(headerRow);
    table.appendChild(thead);

    // Body with weeks and days
    const tbody = document.createElement('tbody');
    let currentDay = calendarStart.clone();

    for (let week = 0; week < numWeeks; week++) {
        const row = document.createElement('tr');

        // Calculate dynamic height: 24px for header + 24px per lane, minimum 80px
        const numLanes = maxLanesPerWeek[week] || 0;
        const dynamicHeight = Math.max(80, 24 + (numLanes * 24) + 10); // +10px bottom padding

        for (let day = 0; day < 7; day++) {
            const cell = document.createElement('td');
            cell.className = 'border border-slate-300 p-0 align-top relative cursor-pointer hover:bg-slate-100 transition-colors';
            cell.style.height = `${dynamicHeight}px`;
            cell.style.minWidth = '100px';

            const isCurrentMonth = currentDay.month() === monthStart.month();
            const isToday = currentDay.isSame(moment(), 'day');
            const isWeekend = day >= 5;

            // Calculate capacity for this day
            let totalCapacity = 0;
            let totalUsage = 0;
            capacitySettings.categories.forEach(cat => {
                const dayOfWeek = day;
                const capacity = cat.limits[dayOfWeek];
                const { usage } = getUsageForCategoryAndDay(cat.id, currentDay.clone());
                totalCapacity += capacity;
                totalUsage += usage;
            });
            const isOverCapacity = totalUsage > totalCapacity;

            cell.innerHTML = `
                <div class="p-1 ${isCurrentMonth ? '' : 'opacity-40'} ${isWeekend ? 'bg-amber-50' : 'bg-white'} h-full">
                    <div class="flex items-start justify-between gap-1">
                        <div class="flex items-center gap-1">
                            <span class="text-xs font-semibold ${isToday ? 'bg-indigo-500 text-white rounded-full px-2 py-0.5' : 'text-slate-600'}">${currentDay.format('D')}</span>
                            <span class="text-xs text-slate-500">${totalUsage.toFixed(0)}/${totalCapacity}h</span>
                        </div>
                        ${isOverCapacity ? '<span class="text-xs text-red-600 font-bold">!</span>' : ''}
                    </div>
                </div>
            `;

            // Add click handler for day
            const clickDay = currentDay.clone();
            cell.addEventListener('click', () => {
                const weekStart = clickDay.clone().startOf('isoWeek');
                scrollCapacityToWeek(weekStart);
            });

            // Add drop zone handlers for drag and drop
            cell.setAttribute('data-calendar-date', clickDay.format('YYYY-MM-DD'));

            cell.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                cell.style.backgroundColor = '#e0e7ff'; // indigo-100
            });

            cell.addEventListener('dragleave', (e) => {
                if (isWeekend) {
                    cell.style.backgroundColor = '';
                } else {
                    cell.querySelector('div').style.backgroundColor = isCurrentMonth ? '#ffffff' : '';
                }
            });

            cell.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();

                // Reset background
                if (isWeekend) {
                    cell.style.backgroundColor = '';
                } else {
                    cell.querySelector('div').style.backgroundColor = isCurrentMonth ? '#ffffff' : '';
                }

                try {
                    const dragData = JSON.parse(e.dataTransfer.getData('text/plain'));
                    const dropDate = clickDay.format('YYYY-MM-DD');
                    handleCalendarWODrop(dragData, dropDate);
                } catch (error) {
                    debugLog('error', 'Error handling calendar WO drop:', error);
                }
            });

            // Add red border if over capacity
            if (isOverCapacity) {
                cell.style.borderColor = '#ef4444';
                cell.style.borderWidth = '2px';
            }

            row.appendChild(cell);
            currentDay.add(1, 'day');
        }

        tbody.appendChild(row);
    }

    table.appendChild(tbody);
    container.appendChild(table);

    // Now render WO overlays
    renderCalendarWOs(table, calendarStart);
}

function renderCalendarWOs(table, calendarStart) {
    const tbody = table.querySelector('tbody');
    const rows = tbody.querySelectorAll('tr');

    // Get all WOs that overlap with this month
    const totalDays = rows.length * 7;
    const calendarEnd = calendarStart.clone().add(totalDays, 'days');
    const wosInMonth = [];

    filteredWorkOrders.forEach(wo => {
        // Filter out completed WOs if setting is disabled
        if (!showCompletedWOs && wo.wo_status === 40) return;

        const woStart = moment(wo.date_scheduled_start).startOf('day');
        let woEnd = moment(wo.date_scheduled).endOf('day');

        // For completed WOs, use date_finished if available and earlier than date_scheduled
        if (wo.wo_status === 40 && wo.date_finished) {
            const dateFinished = moment(wo.date_finished).endOf('day');
            woEnd = moment.min(woEnd, dateFinished);
        }

        if (woStart.isBefore(calendarEnd) && woEnd.isAfter(calendarStart)) {
            wosInMonth.push(wo);
        }
    });

    // Pack WOs into rows to avoid overlap
    packWOsIntoLanes(wosInMonth);

    // Render each WO as positioned within cells
    wosInMonth.forEach((wo) => {
        const woStart = moment(wo.date_scheduled_start).startOf('day');
        let woEnd = moment(wo.date_scheduled).endOf('day');

        // For completed WOs, use date_finished if available and earlier than date_scheduled
        if (wo.wo_status === 40 && wo.date_finished) {
            const dateFinished = moment(wo.date_finished).endOf('day');
            woEnd = moment.min(woEnd, dateFinished);
        }

        // Calculate which days this WO spans
        const startDayIndex = Math.max(0, woStart.diff(calendarStart, 'days'));
        const endDayIndex = Math.min(totalDays - 1, woEnd.diff(calendarStart, 'days'));

        if (startDayIndex >= totalDays || endDayIndex < 0) return;

        // Find which row and columns
        const startRow = Math.floor(startDayIndex / 7);
        const startCol = startDayIndex % 7;
        const endRow = Math.floor(endDayIndex / 7);
        const endCol = endDayIndex % 7;

        // For now, only render WOs that fit within a single row
        if (startRow !== endRow) return; // Skip multi-row WOs for simplicity

        const row = rows[startRow];
        if (!row) return;

        const cells = row.querySelectorAll('td');
        const startCell = cells[startCol];
        const endCell = cells[endCol];

        if (!startCell || !endCell) return;

        // Create WO bar as absolute positioned element within the row
        const woBar = document.createElement('div');
        woBar.className = 'absolute rounded px-1 py-0.5 text-xs font-medium cursor-move hover:opacity-80 transition-opacity border';
        woBar.draggable = true;
        woBar.setAttribute('data-wo-id', wo.wo_id);
        woBar.setAttribute('data-wo-num', wo.wo_num);
        woBar.setAttribute('data-wo-start', wo.date_scheduled_start);
        woBar.setAttribute('data-wo-end', wo.date_scheduled);

        // Calculate position based on cell positions within the row
        const rowWidth = row.offsetWidth;
        const cellWidth = rowWidth / 7;
        const horizontalPadding = 4;
        const left = (startCol * cellWidth) + horizontalPadding;
        const width = ((endCol - startCol + 1) * cellWidth) - (horizontalPadding * 2);
        const top = 24 + ((wo._lane || 0) * 24);

        woBar.style.left = `${left}px`;
        woBar.style.top = `${top}px`;
        woBar.style.width = `${width}px`;
        woBar.style.height = '20px';
        woBar.style.zIndex = '10';

        // Color by status or category based on setting
        if (calendarColorMode === 'category' && wo.category_color) {
            // Use category color (add # prefix if not present)
            const categoryColor = wo.category_color.startsWith('#') ? wo.category_color : '#' + wo.category_color;
            woBar.style.backgroundColor = categoryColor + '40'; // Add transparency (40 = 25% opacity in hex)
            woBar.style.borderColor = categoryColor;
            woBar.style.color = '#06162d'; // Fishbowl dark text
            woBar.className += ' border-2';
        } else {
            // Use status color (default)
            const colors = WO_STATUS_COLORS[wo.wo_status] || WO_STATUS_COLORS[10];
            woBar.className += ` ${colors.bg} ${colors.border} ${colors.text}`;
        }
        // Use view mode setting to determine label
        const woLabel = getWOLabel(wo, 12); // Truncate to 12 chars for calendar tiles
        woBar.textContent = viewByMode === 'bom_num' ? woLabel : `WO ${woLabel}`;

        // Custom CSS tooltip
        const laborHoursPerUnit = parseFloat(wo.labor_hours_from_bom) || 0;
        const qtyTarget = parseFloat(wo.qty_target) || 1;
        const totalHours = laborHoursPerUnit * qtyTarget;
        const statusName = wo.wo_status === 10 ? 'Entered' : wo.wo_status === 30 ? 'Started' : wo.wo_status === 40 ? 'Fulfilled' : 'Unknown';
        const bomInfo = wo.part_num ? `${wo.part_num} x ${wo.qty_target || '?'}` : 'N/A';
        const calendarTooltipHTML = `
            <div><span class="wo-tooltip-label">WO:</span><span class="wo-tooltip-value">${wo.wo_num}</span></div>
            <div><span class="wo-tooltip-label">MO:</span><span class="wo-tooltip-value">${wo.mo_num}</span></div>
            <div><span class="wo-tooltip-label">Category:</span><span class="wo-tooltip-value">${wo.category_name || 'Uncategorized'}</span></div>
            <div><span class="wo-tooltip-label">BOM:</span><span class="wo-tooltip-value">${bomInfo}</span></div>
            <div><span class="wo-tooltip-label">Status:</span><span class="wo-tooltip-value">${statusName}</span></div>
            <div><span class="wo-tooltip-label">Hours:</span><span class="wo-tooltip-value">${totalHours.toFixed(2)}h</span></div>
            <div><span class="wo-tooltip-label">Start:</span><span class="wo-tooltip-value">${formatDate(woStart)}</span></div>
            <div><span class="wo-tooltip-label">Finish:</span><span class="wo-tooltip-value">${formatDate(woEnd)}</span></div>
        `;

        woBar.addEventListener('mouseover', (e) => {
            showWOTooltip(e, calendarTooltipHTML);
        });
        woBar.addEventListener('mouseout', () => {
            hideWOTooltip();
        });
        woBar.addEventListener('mousemove', (e) => {
            showWOTooltip(e, calendarTooltipHTML);
        });

        // Drag and drop handlers
        woBar.addEventListener('dragstart', (e) => {
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', JSON.stringify({
                wo_id: wo.wo_id,
                wo_num: wo.wo_num,
                originalStart: wo.date_scheduled_start,
                originalEnd: wo.date_scheduled
            }));
            woBar.style.opacity = '0.5';
        });

        woBar.addEventListener('dragend', (e) => {
            woBar.style.opacity = '1';
        });

        // Click handler - scroll to week
        woBar.addEventListener('click', (e) => {
            e.stopPropagation();
            const weekStart = woStart.clone().startOf('isoWeek');
            scrollCapacityToWeek(weekStart);
        });

        // Append to the row (not tbody) with relative positioning
        row.style.position = 'relative';
        row.appendChild(woBar);
    });
}

// ============================================
// INITIALIZATION
// ============================================
window.addEventListener('DOMContentLoaded', () => {
    // Initialize date ranges now that moment.js is loaded
    if (typeof moment === 'undefined') {
        const debugLogEl = document.getElementById('debugLog');
        if (debugLogEl) {
            debugLogEl.innerHTML = '<div class="text-red-400">[ERROR] moment.js not loaded! Check internet connection or CDN access.</div>';
        }
        console.error('moment.js is not loaded!');
        return;
    }

    ganttStartDate = moment().startOf('isoWeek');
    ganttEndDate = moment().startOf('isoWeek').add(14, 'days');

    // Show debug console if DEBUG_MODE is enabled
    if (DEBUG_MODE) {
        const debugConsoleContainer = document.getElementById('debugConsoleContainer');
        if (debugConsoleContainer) {
            debugConsoleContainer.style.display = 'block';
        }
    }

    debugLog('info', 'Application starting...');
    if (DEBUG_MODE) {
        debugLog('info', 'Debug mode enabled via BI_SHOW_DEBUG property');
    }

    // Initialize event listeners for UI controls
    initializeEventListeners();

    // Load work orders (settings will be loaded after categories are initialized)
    loadWorkOrders();
});
</script>
</body>
</html>
