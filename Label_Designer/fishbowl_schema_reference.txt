# FISHBOWL DATABASE SCHEMA & TABLE RELATIONSHIPS
## For SQL Query Generator - Label Printing Module

Generated: 2026-02-22
Source: /home/user/FB_BI_Reports Dashboards and Individual Pages

================================================================================
## CORE TABLE RELATIONSHIPS
================================================================================

### PART/PRODUCT MASTER DATA
Tables:
  - part: Core product data (p.num, p.description, p.id, p.typeid=10 for inventory)
  - partcost: Cost information (partid, avgCost for current valuation)
  - product: Alternative product references (productid)
  - uom: Unit of Measure (part.uomid → uom.id, uom.code)
  - tag: Inventory tags/lots (tag.qty, tag.partid, tag.locationid)
  - location: Physical locations (location.id, location.locationgroupid)
  - locationgroup: Location group master (locationgroup.id, locationgroup.name)

Key Fields for Labels:
  - part.num (Part Number)
  - part.description (Product Description)
  - part.id (Internal ID)
  - partcost.avgCost (Average Cost)
  - tag.qty (Quantity on hand at location)
  - tag.locationid (Physical location)

Typical Query Pattern:
  SELECT p.num, p.description, SUM(tag.qty) as qty_on_hand
  FROM tag
  JOIN location l ON tag.locationid = l.id
  JOIN part p ON tag.partid = p.id
  LEFT JOIN partcost pc ON p.id = pc.partid
  WHERE l.locationgroupid = ${locationGroupId} AND p.typeid = 10

================================================================================
## RECEIVING FLOW (PO → RECEIPT → RECEIPTITEM → PART)
================================================================================

Table Chain:
  PO → POITEM → RECEIPTITEM → RECEIPT ← PART

Tables:
  - po: Purchase Order (po.num, po.vendorid, po.dateissued, po.datefirstship, po.locationgroupid)
  - poitem: PO line items (poitem.poid, poitem.partid, poitem.qty, poitem.totalcost)
  - receipt: Receipt header (receipt.id, receipt.poid, receipt.statusid, receipt.locationgroupid)
  - receiptitem: Receipt line items (receiptitem.receiptid, receiptitem.poitemid, receiptitem.qty,
    receiptitem.dateReceived, receiptitem.dateReconciled, receiptitem.statusid, receiptitem.landedtotalcost)
  - vendor: Vendor info (vendor.id, vendor.name)
  - receiptstatus: Receipt status lookup

Key Fields for Receiving Labels:
  - receiptitem.qty (Received Quantity)
  - receiptitem.landedtotalcost (Total cost with landed charges)
  - poitem.partid (Links to part)
  - receipt.dateReceived / dateReconciled (Receipt date)
  - po.num (PO Number)
  - vendor.name (Vendor Name)

Typical Query Pattern:
  SELECT
      COALESCE(GREATEST(ri.dateReceived, ri.dateReconciled), ri.dateReceived) as date_received,
      p.num AS part_num,
      p.description,
      ri.qty,
      ri.landedtotalcost as total_cost,
      po.num as po_num,
      v.name as vendor_name
  FROM receiptitem ri
  JOIN receipt r ON ri.receiptid = r.id
  JOIN poitem ON ri.poitemid = poitem.id
  JOIN part p ON poitem.partid = p.id
  JOIN po ON poitem.poid = po.id
  LEFT JOIN vendor v ON po.vendorid = v.id
  WHERE ri.statusid >= 20 AND p.typeid = 10

Status IDs in receiptitem: statusid >= 20 = Reconciled/Received/Fulfilled

================================================================================
## SHIPPING FLOW (SO → SOITEM → SHIPITEM → SHIP → PART)
================================================================================

Table Chain:
  SO → SOITEM → SHIPITEM → SHIP ← PART

Tables:
  - so: Sales Order (so.num, so.customerid, so.dateissued, so.datefirstship, so.locationgroupid)
  - soitem: SO line items (soitem.soid, soitem.productid [=partid], soitem.qty, soitem.unitprice)
  - ship: Shipment header (ship.id, ship.soid, ship.statusid, ship.locationgroupid, ship.shiptoname)
  - shipitem: Shipment line items (shipitem.shipid, shipitem.soitemid, shipitem.qtyshipped)
  - shipstatus: Shipment status lookup
  - customer: Customer info (customer.id, customer.name)
  - carrier: Shipping carrier (carrier.id, carrier.name)
  - carrierservice: Carrier service (carrierservice.id, carrierservice.name)

Key Fields for Shipping Labels:
  - shipitem.qtyshipped (NOT qty - must use qtyshipped for actual shipped qty)
  - ship.shiptoname (Ship to address)
  - soitem.unitprice (Sale price)
  - so.num (Sales Order Number)
  - customer.name (Customer Name)
  - carrier.name (Shipping Carrier)
  - carrierservice.name (Service Type)

Typical Query Pattern:
  SELECT
      Ship.Id AS id,
      Ship.Num AS num,
      Ship.ShipToName AS shipTo,
      ShipStatus.Name AS statusName,
      So.Num AS orderNum,
      Customer.Name AS customerName,
      Carrier.Name AS carrier,
      CarrierService.Name AS service
  FROM Ship
  LEFT JOIN ShipStatus ON Ship.StatusId = ShipStatus.Id
  LEFT JOIN Carrier ON Ship.CarrierId = Carrier.Id
  LEFT JOIN CarrierService ON Ship.CarrierServiceId = CarrierService.Id
  LEFT JOIN So ON Ship.SoId = So.Id
  LEFT JOIN Customer ON So.CustomerId = Customer.Id
  WHERE ShipStatus.Name IN ('Entered', 'Packed')

Critical Note: Use ShipItem.QtyShipped (NOT ShipItem.qty) for shipped quantities

================================================================================
## PICKING FLOW (SO/PO/WO → SOITEM/POITEM/WOITEM → PICKITEM → PICK → PART)
================================================================================

Table Chain:
  ORDER (SO/PO/WO) → ORDER ITEM → PICKITEM → PICK ← PART

Tables:
  - pick: Pick ticket header (pick.id, pick.num, pick.datescheduled, pick.statusid,
    pick.locationgroupid, pick.priority)
  - pickitem: Pick line items (pickitem.pickid, pickitem.partid, pickitem.qty, pickitem.statusid,
    pickitem.soitemid, pickitem.poitemid, pickitem.woitemid, pickitem.ordertypeid)
  - soitem: SO items (soitem.id, soitem.soid, soitem.productid)
  - poitem: PO items (poitem.id, poitem.poid, poitem.partid)
  - woitem: WO items (woitem.id, woitem.woid)
  - xoitem: Transfer Order items (xoitem.id, xoitem.xoid)
  - pickstatus: Pick status lookup
  - priority: Priority lookup
  - qtyonhand: Inventory availability view (partid, locationgroupid, qty)
  - qtycommitted: Committed quantities (partid, locationgroupid, qty)
  - qtynotavailabletopick: Reserved/unavailable (partid, locationgroupid, qty)

Key Fields for Pick Labels:
  - pickitem.qty (Qty to pick)
  - pickitem.partid (Item to pick)
  - pick.num (Pick number)
  - pick.datescheduled (Scheduled date)
  - pick.locationgroupid (Pick from location)
  - qtyonhand.qty (Available qty at location)

Availability Status Logic (from Items_To_Be_Picked.htm):
  Available = qtyonhand - qtycommitted - qtynotavailabletopick
  fullItems = items where Available >= PickItem.Qty
  partialItems = items where 0 < Available < PickItem.Qty
  noneItems = items where Available <= 0

Typical Query Pattern:
  SELECT
      Pick.Id, Pick.Num, Pick.DateScheduled,
      PickItem.PartId, PickItem.Qty,
      COALESCE((SELECT qty FROM qtyonhand WHERE partId = PickItem.PartId 
                AND locationGroupId = Pick.LocationGroupId), 0) -
      COALESCE((SELECT qty FROM qtycommitted WHERE partId = PickItem.PartId 
                AND locationGroupId = Pick.LocationGroupId), 0) -
      COALESCE((SELECT qty FROM qtynotavailabletopick WHERE partId = PickItem.PartId 
                AND locationGroupId = Pick.LocationGroupId), 0) as available_qty
  FROM Pick
  JOIN PickItem ON PickItem.PickId = Pick.Id
  WHERE Pick.StatusId < 40

OrderTypeId Values:
  - 10 = Purchase Order (PO)
  - 20 = Sales Order (SO)
  - 30 = Work Order (WO)
  - 40 = Transfer Order (XO/TO)

PickItem.StatusId: < 40 = Active, 30 = Committed (locked)

================================================================================
## WORK ORDER / MANUFACTURING (WO → WOITEM → MOITEM → BOM → PART)
================================================================================

Table Chain:
  WO → MOITEM → MO (Manufacturing Orders)

Tables:
  - wo: Work Order (wo.id, wo.num, wo.datescheduled, wo.statusid, wo.moitemid, wo.locationgroupid)
  - woitem: Work Order items (woitem.id, woitem.woid, woitem.partid, woitem.qty)
  - moitem: Manufacturing Order items (moitem.id, moitemid, moitem.moid, moitem.bomid, moitem.qtytofulfill)
  - mo: Manufacturing Orders (mo.id, mo.num)
  - bom: Bill of Materials (bom.id, bom.num)
  - wostatus: Work order status lookup

Key Fields for WO Labels:
  - wo.num (Work Order Number)
  - woitem.partid (Finished good to produce)
  - moitem.qtytofulfill (Qty required)
  - wo.datescheduled (Scheduled date)
  - bom.num (BOM Number for routing)

Typical Query Pattern:
  SELECT
      Wo.Num, Wo.DateScheduled,
      Mo.Num AS moNum,
      Bom.Num AS bomNum,
      MoItem.QtyToFulfill AS qty
  FROM Wo
  LEFT JOIN MoItem ON Wo.moItemId = MoItem.id
  LEFT JOIN Mo ON MoItem.moId = Mo.id
  LEFT JOIN Bom ON MoItem.bomId = Bom.id
  WHERE Wo.statusId IN (10, 30)  -- 10=Entered, 30=Started

================================================================================
## TRACKING & SERIALIZATION (Advanced)
================================================================================

Tables:
  - parttracking: Part-level tracking settings (partid, trackingtypeid, lotnumber required, serialnumber required)
  - serialnum: Serial number assignments (serialnumber, partid, linkedto [parent serial])
  - tag: Lot/batch level tracking (tag.qty, tag.partid, tag.locationid)

Tracking Type IDs:
  - None: Not tracked
  - Lot: Batch tracking
  - Serial: Individual unit tracking
  - Lot & Serial: Both required

Key Fields for Track/Lot Labels:
  - parttracking.trackingtypeid (Determines label requirements)
  - serialnum.serialnumber (Individual unit identifier)
  - tag.qty (Batch quantity in lot)

Note: Most queries in current dashboards do NOT join parttracking/serialnum tables.
These would be needed for lot/serial label printing.

Query Pattern (if needed):
  SELECT p.num, pt.trackingtypeid, sn.serialnumber, tag.qty
  FROM part p
  LEFT JOIN parttracking pt ON p.id = pt.partid
  LEFT JOIN serialnum sn ON p.id = sn.partid
  LEFT JOIN tag ON p.id = tag.partid
  WHERE p.id = ${partId}

================================================================================
## INVENTORY MANAGEMENT TABLES
================================================================================

### Inventory Quantities (Virtual Views)
Tables:
  - qtyonhand: Current inventory (partid, locationgroupid, qty)
  - qtycommitted: Allocated to orders (partid, locationgroupid, qty)
  - qtyallocated: Allocated to picks (partid, locationgroupid, qty)
  - qtyonorder: On purchase orders (partid, locationgroupid, qty)
  - qtydropship: Drop-ship quantities (partid, locationgroupid, qty)
  - qtynotavailable: Marked unavailable (partid, locationgroupid, qty)
  - qtynotavailabletopick: Reserved quantities (partid, locationgroupid, qty)

Quantity Formula:
  Available = qtyonhand - qtycommitted - qtyallocated - qtynotavailable

### Reorder Management
Tables:
  - partreorder: Reorder points (partid, locationgroupid, reorderpoint, reorderqty, defaultvendorid)

Typical Query:
  SELECT p.num, p.description, COALESCE(qoh.qty, 0) as on_hand, pr.reorderpoint, 
         (pr.reorderpoint - COALESCE(qoh.qty, 0)) as qty_short
  FROM part p
  INNER JOIN partreorder pr ON p.id = pr.partid
  LEFT JOIN qtyonhand qoh ON p.id = qoh.partid AND qoh.locationgroupid = pr.locationgroupid
  WHERE p.activeflag = 1 AND p.typeid = 10 AND COALESCE(qoh.qty, 0) < pr.reorderpoint

### Inventory Transactions
Tables:
  - inventorylog: Transaction log (eventdate, typeid, partid, qty, locationgroupid, recordid, tableid)
  - post: Financial postings (typeid, refitemid, refid, quantity, amount, datecreated)

InventoryLogType IDs:
  - 10: Receive
  - 20: Ship
  - 30: Transfer
  - 40: Production - Build (consume materials)
  - 50: Production - Consume
  - 64: Adjust Increase
  - 65: Adjust Decrease
  - 67: Scrap (adj:scp)
  - 68: Cycle Count (adj:cyc)

POST Table Filtering:
  - POST.TYPEID = 50: Inventory adjustment
  - POST.REFITEMID = 2: Scrap
  - POST.REFITEMID = 3: Cycle Count
  - POST.AMOUNT: Historical cost at time of transaction

Typical Query (for movements):
  SELECT DATE(inventorylog.eventdate) as event_date,
         inventorylogtype.description as event_type,
         SUM(inventorylog.qty) as total_qty
  FROM inventorylog
  JOIN inventorylogtype ON inventorylog.typeid = inventorylogtype.id
  JOIN part ON inventorylog.partid = part.id
  WHERE part.typeid = 10 AND inventorylog.eventdate >= '${startDate}'
  GROUP BY DATE(inventorylog.eventdate), inventorylogtype.description

================================================================================
## POSTINGS & COST TRACKING (POST TABLE)
================================================================================

Table: post
Purpose: Historical cost and financial transaction tracking

Key Fields:
  - post.typeid (50 = Inventory adjustment)
  - post.refitemid (2 = Scrap, 3 = Cycle Count)
  - post.refid (Part ID)
  - post.quantity (Qty adjusted)
  - post.amount (Cost at time of transaction)
  - post.datecreated (Transaction timestamp)

Linked to InventoryLog via:
  inventorylog.recordid = post.id AND inventorylog.tableid = -1407594912

For Cost Tracking:
  - receiptitem.landedtotalcost: Cost when received
  - postsoitem.postedtotalcost: Cost when shipped/invoiced
  - post.amount: Cost for adjustments/scrap (historical)
  - partcost.avgcost: Current average cost (for valuation only)

Typical Scrap Query:
  SELECT SUM(ABS(POST.QUANTITY)) as total_qty,
         SUM(ABS(POST.AMOUNT)) as total_value
  FROM POST
  INNER JOIN PART ON POST.REFID = PART.ID
  WHERE POST.TYPEID = 50
    AND POST.REFITEMID = 2  -- Scrap
    AND PART.typeid = 10
    AND POST.DATECREATED >= '${startDate}'

================================================================================
## VENDOR & PRODUCT RELATIONSHIPS
================================================================================

Tables:
  - vendor: Vendor master (vendor.id, vendor.name, vendor.activeflag)
  - vendorparts: Vendor-to-part mapping (vendorid, partid, defaultflag, vendorpartnum)
  - producttoTree: Category assignments (productid, producttreeid)
  - producttree: Category hierarchy

Default Vendor Query:
  SELECT DISTINCT v.id, v.name
  FROM vendor v
  INNER JOIN vendorparts vp ON v.id = vp.vendorid AND vp.defaultflag = 1
  WHERE v.activeflag = 1
  ORDER BY v.name

================================================================================
## IMPORTANT SQL PATTERNS FOR LABEL PRINTING
================================================================================

### 1. CURRENT INVENTORY AT LOCATION
Pattern:
  SELECT p.num, p.description, SUM(tag.qty) as qty
  FROM tag
  JOIN location l ON tag.locationid = l.id
  JOIN part p ON tag.partid = p.id
  WHERE l.locationgroupid = ${lgId} AND p.typeid = 10
  GROUP BY p.id

### 2. RECEIVING - ITEMS AWAITING PUTAWAY
Pattern:
  SELECT p.num, p.description, ri.qty, ri.landedtotalcost, po.num, v.name
  FROM receiptitem ri
  JOIN receipt r ON ri.receiptid = r.id
  JOIN poitem ON ri.poitemid = poitem.id
  JOIN part p ON poitem.partid = p.id
  JOIN po ON poitem.poid = po.id
  LEFT JOIN vendor v ON po.vendorid = v.id
  WHERE r.statusid = 20 (Reconciled) AND p.typeid = 10
  ORDER BY r.id

### 3. SHIPPING - ITEMS READY TO PICK
Pattern:
  SELECT p.num, p.description, so.num, c.name, si.qty
  FROM soitem si
  JOIN so ON si.soid = so.id
  JOIN part p ON si.productid = p.id
  LEFT JOIN customer c ON so.customerid = c.id
  WHERE so.statusid IN (20, 30) AND p.typeid = 10
  ORDER BY so.num

### 4. PICKING - ITEMS TO PICK
Pattern:
  SELECT p.num, p.description, pi.qty, pick.num, pick.datescheduled,
         COALESCE(qoh.qty, 0) as available
  FROM pickitem pi
  JOIN pick ON pi.pickid = pick.id
  JOIN part p ON pi.partid = p.id
  LEFT JOIN qtyonhand qoh ON p.id = qoh.partid AND qoh.locationgroupid = pick.locationgroupid
  WHERE pick.statusid < 40 AND pi.statusid < 40

### 5. INVENTORY VALUATION
Pattern:
  SELECT p.num, p.description, SUM(tag.qty) as qty, COALESCE(pc.avgcost, 0) as cost,
         SUM(tag.qty) * COALESCE(pc.avgcost, 0) as total_value
  FROM tag
  JOIN part p ON tag.partid = p.id
  LEFT JOIN partcost pc ON p.id = pc.partid
  WHERE tag.qty > 0 AND p.typeid = 10
  GROUP BY p.id

### 6. BELOW REORDER POINT
Pattern:
  SELECT p.num, p.description, COALESCE(qoh.qty, 0) as on_hand, pr.reorderpoint
  FROM part p
  INNER JOIN partreorder pr ON p.id = pr.partid
  LEFT JOIN qtyonhand qoh ON p.id = qoh.partid AND qoh.locationgroupid = pr.locationgroupid
  WHERE p.typeid = 10 AND COALESCE(qoh.qty, 0) < pr.reorderpoint
  ORDER BY (pr.reorderpoint - COALESCE(qoh.qty, 0)) DESC

================================================================================
## LABEL USE CASES & REQUIRED FIELDS
================================================================================

### USE CASE 1: RECEIVING LABEL (PO Receipt)
Tables: receiptitem, receipt, poitem, part, po, vendor, location, locationgroup
Required Fields:
  - PO Number: po.num
  - Part Number: part.num
  - Description: part.description
  - Received Qty: receiptitem.qty
  - Received Date: receiptitem.dateReceived or dateReconciled
  - Vendor: vendor.name
  - Location Group: locationgroup.name
  - Cost: receiptitem.landedtotalcost (total with landed charges)
  - UOM: uom.code (if available)

### USE CASE 2: SHIPPING LABEL (SO Shipment)
Tables: shipitem, ship, soitem, so, part, customer, carrier, carrierservice, location
Required Fields:
  - SO Number: so.num
  - Ship Number: ship.num
  - Part Number: part.num
  - Description: part.description
  - Qty Shipped: shipitem.qtyshipped (NOT qty)
  - Ship To: ship.shiptoname
  - Customer: customer.name
  - Carrier: carrier.name
  - Service: carrierservice.name
  - Weight: part.weight (if available)
  - Dimensions: part.depth, width, height (if available)

### USE CASE 3: PICK LABEL (Warehouse Pick Ticket)
Tables: pickitem, pick, part, soitem, so, poitem, po, qtyonhand, customer
Required Fields:
  - Pick Number: pick.num
  - Part Number: part.num
  - Description: part.description
  - Qty to Pick: pickitem.qty
  - Available Qty: qtyonhand.qty
  - Pick from Location: (need location.aisle, bin from tag or location attributes)
  - Order Type: SO/PO/WO
  - Order Number: so.num / po.num / wo.num
  - Customer/Vendor: customer.name / vendor.name
  - Scheduled Date: pick.datescheduled

### USE CASE 4: INVENTORY LABEL (Location/Bin Label)
Tables: tag, location, part, locationgroup, partcost, uom
Required Fields:
  - Part Number: part.num
  - Description: part.description
  - Qty on Hand: tag.qty (or sum per location)
  - Location: location.name / location.aisle / location.bin
  - Location Group: locationgroup.name
  - Cost: partcost.avgcost
  - UOM: uom.code
  - Reorder Point: partreorder.reorderpoint (if low stock label)
  - Weight: part.weight (if available)

### USE CASE 5: REORDER/LOW STOCK LABEL
Tables: part, partreorder, qtyonhand, partcost, locationgroup
Required Fields:
  - Part Number: part.num
  - Description: part.description
  - Current Qty: qtyonhand.qty
  - Reorder Point: partreorder.reorderpoint
  - Qty Short: (reorderpoint - qtyonhand.qty)
  - Default Vendor: vendorparts.defaultvendorid (via partreorder)
  - Location Group: locationgroup.name
  - Unit Cost: partcost.avgcost

### USE CASE 6: CARTON/PACK LABEL (Multi-unit Container)
Tables: shipitem, shipcarton (if exists), soitem, part, ship
Required Fields:
  - Carton Number: (shipcarton.cartonnum or generated)
  - Ship Number: ship.num
  - Part Number: part.num
  - Description: part.description
  - Qty in Carton: shipitem.qty or shipcarton.qty
  - Destination: ship.shiptoname
  - Weight: shipcarton.weight (if carton table exists)
  - Dimensions: shipcarton.length, width, height
  - Barcode: ship.trackingnumber or generated

================================================================================
## DATABASE NOTES & CAVEATS
================================================================================

1. STATUS ID PATTERNS:
   - Most tables use statusid where lower numbers = earlier states
   - pickitem.statusid < 40 = active items (40+ = finished/cancelled)
   - receiptitem.statusid >= 20 = received/reconciled (20=reconciled, 30=received, 40=fulfilled)
   - shipstatus.Name IN ('Entered', 'Packed') = items awaiting shipment

2. TYPEID PATTERNS:
   - part.typeid = 10 = Inventory parts (filter to this for SKU labels)
   - Other values = Work-in-Process, Lot items, etc.
   - post.typeid = 50 = Inventory adjustment records

3. IMPORTANT GOTCHAS:
   - ShipItem.QtyShipped (not qty) for shipped quantities
   - SoItem.UnitPrice for sale value calculations
   - POST.AMOUNT for historical costs (not current partcost.avgcost)
   - receiptitem.landedtotalcost includes landed charges
   - DATE(received_date) for comparing GREATEST(dateReceived, dateReconciled)
   - LEFT JOINs needed when part may not have cost/reorder records

4. FIELD NAMING:
   - Column names are case-insensitive in queries but table names may be case-sensitive
   - Use aliases to handle typeid filtering and cost calculations
   - JSON parsing converts field names to lowercase in results

5. LOCATION DATA:
   - location.locationgroupid links physical bins to location groups
   - tag records link inventory to specific location + partid
   - No built-in aisle/bin fields visible in current queries
   - Would need location.name or custom location attributes for full location coding

6. COST TRACKING:
   - partcost.avgcost = current valuation (changes over time)
   - receiptitem.landedtotalcost = cost when received
   - postsoitem.postedtotalcost = cost when shipped
   - post.amount = cost at time of adjustment/scrap
   - For point-in-time cost attribution, use received/posted cost, not avgcost

================================================================================
END OF SCHEMA DOCUMENTATION
================================================================================
