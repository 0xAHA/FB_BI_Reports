<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Work Order Capacity Planning - Gantt Chart v2 (vis-timeline)</title>

    <!-- vis-timeline CSS -->
    <link href="https://unpkg.com/vis-timeline@7.7.3/styles/vis-timeline-graph2d.min.css" rel="stylesheet" type="text/css" />

    <!-- Bootstrap 5.3 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Bootstrap Icons -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css" rel="stylesheet">

    <!-- Fishbowl Modern Theme -->
    <link href="fishbowl-theme-modern.css" rel="stylesheet">

    <style>
        {% Style fishbowl-theme-modern %}

        /* ============================================
           General Layout
           ============================================ */

        body {
            background-color: var(--fb-gray-50);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }

        #visualization {
            height: 600px;
            border: 1px solid #ddd;
            background-color: white;
            border-radius: 4px;
            margin-bottom: 1rem;
        }

        /* ============================================
           Status Colors (matching Fishbowl theme)
           ============================================ */

        .vis-item.status-entered {
            background-color: var(--fb-info) !important;
            border-color: var(--fb-info) !important;
            color: white !important;
        }

        .vis-item.status-started {
            background-color: var(--fb-warning) !important;
            border-color: var(--fb-warning) !important;
            color: white !important;
        }

        .vis-item.status-fulfilled {
            background-color: var(--fb-success) !important;
            border-color: var(--fb-success) !important;
            color: white !important;
        }

        .vis-item.conflict {
            background-color: var(--fb-danger) !important;
            border-color: var(--fb-danger) !important;
            color: white !important;
            box-shadow: 0 0 8px rgba(231, 76, 60, 0.5) !important;
        }

        /* Weekend background shading */
        .vis-item.weekend-background {
            background-color: #e8e8e8;
            border: none;
            z-index: -1;
        }

        .vis-item.mo-header {
            background-color: #34495e !important;
            border-color: #2c3e50 !important;
            color: white !important;
            font-weight: bold !important;
            opacity: 0.8;
        }

        /* MO header status colors */
        .vis-item.mo-header.status-entered {
            background-color: var(--fb-info) !important;
            opacity: 0.7;
        }

        .vis-item.mo-header.status-started {
            background-color: var(--fb-warning) !important;
            opacity: 0.7;
        }

        .vis-item.mo-header.status-fulfilled {
            background-color: var(--fb-success) !important;
            opacity: 0.7;
        }

        /* ============================================
           Category Swim Lane Styling
           ============================================ */

        .vis-label.category-label {
            font-weight: 600;
            padding: 8px !important;
            border-radius: 4px;
            color: #333 !important;
        }

        /* ============================================
           Timeline Controls
           ============================================ */

        .vis-custom-time {
            background-color: var(--fb-danger);
            width: 2px;
        }

        .view-toggle-btn {
            padding: 8px 16px;
            border: 2px solid var(--fb-primary);
            background-color: white;
            color: var(--fb-primary);
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s;
        }

        .view-toggle-btn:hover {
            background-color: var(--fb-primary-pale);
        }

        .view-toggle-btn.active {
            background-color: var(--fb-primary);
            color: white;
        }

        .info-card {
            background-color: white;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .legend-item {
            display: inline-flex;
            align-items: center;
            margin-right: 20px;
            margin-bottom: 8px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .legend-item:hover {
            background-color: var(--fb-gray-100);
        }

        .legend-item.active {
            background-color: var(--fb-primary-pale);
            border: 2px solid var(--fb-primary);
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            margin-right: 8px;
            border: 1px solid #ccc;
        }

        /* ============================================
           Debug Console
           ============================================ */

        .debug-section {
            margin-top: 2rem;
        }

        .debug-content {
            max-height: 300px;
            overflow-y: auto;
            background-color: #1e1e1e;
            color: #d4d4d4;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 10px;
        }

        .debug-entry {
            padding: 4px 0;
            border-bottom: 1px solid #333;
        }

        .debug-timestamp {
            color: #858585;
            margin-right: 8px;
        }

        .debug-type {
            font-weight: bold;
            margin-right: 8px;
        }

        .debug-type.info { color: #4fc3f7; }
        .debug-type.success { color: #66bb6a; }
        .debug-type.warning { color: #ffa726; }
        .debug-type.error { color: #ef5350; }

        .debug-data {
            margin-top: 4px;
            margin-left: 20px;
            padding: 8px;
            background-color: #2d2d2d;
            border-left: 3px solid #569cd6;
            font-size: 11px;
            overflow-x: auto;
            white-space: pre-wrap;
        }

        /* Empty state */
        .empty-state {
            text-align: center;
            padding: 3rem;
            color: var(--fb-gray-600);
        }

        .empty-state i {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        /* Loading spinner */
        .loading-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 9999;
            justify-content: center;
            align-items: center;
        }

        .loading-overlay.show {
            display: flex;
        }

        .loading-spinner {
            width: 3rem;
            height: 3rem;
        }

        /* ============================================
           vis-timeline Resize Handle Styling
           ============================================ */

        /* Ensure resize handles are visible and functional */
        .vis-item.vis-range.vis-editable {
            cursor: move;
        }

        .vis-item.vis-range.vis-editable.vis-selected {
            cursor: move;
        }

        /* Make resize handles more prominent */
        .vis-item.vis-range .vis-drag-left,
        .vis-item.vis-range .vis-drag-right {
            cursor: ew-resize !important;
            width: 24px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .vis-item.vis-range:hover .vis-drag-left,
        .vis-item.vis-range:hover .vis-drag-right,
        .vis-item.vis-range.vis-selected .vis-drag-left,
        .vis-item.vis-range.vis-selected .vis-drag-right {
            opacity: 0.3;
        }

        .vis-item.vis-range.vis-selected .vis-drag-left:hover,
        .vis-item.vis-range.vis-selected .vis-drag-right:hover {
            opacity: 0.6;
        }

        /* Make sure MO headers are NOT resizable */
        .vis-item.mo-header {
            cursor: default !important;
        }

        .vis-item.mo-header .vis-drag-left,
        .vis-item.mo-header .vis-drag-right {
            display: none !important;
        }

        /* ============================================
           Calendar Grid Styling
           ============================================ */

        /* Make day borders more visible */
        .vis-time-axis .vis-grid.vis-vertical {
            border-left: 1px solid #ddd !important;
        }

        /* Make major grid lines (week/month) more prominent */
        .vis-time-axis .vis-grid.vis-vertical.vis-major {
            border-left: 2px solid #999 !important;
        }

        /* Alternating background for better day visibility */
        .vis-background .vis-vertical {
            border-left: 1px solid #e8e8e8 !important;
        }

        .vis-background .vis-vertical.vis-major {
            border-left: 2px solid #bbb !important;
        }

        /* Today column highlight */
        .vis-time-axis .vis-grid.vis-today {
            background-color: rgba(231, 76, 60, 0.05) !important;
        }

        /* ============================================
           Dependency Arrow Styling
           ============================================ */

        /* Arrows are feint by default */
        .dependency-arrow {
            opacity: 0.5;
            transition: opacity 0.2s, stroke-width 0.2s;
        }

        /* Darken arrows on hover */
        .dependency-arrow.highlighted {
            opacity: 1;
            stroke-width: 3px !important;
            z-index: 1000;
        }

        /* ============================================
           Off-Canvas Tab Buttons (sticky tabs on sides)
           ============================================ */
        .offcanvas-tab {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            z-index: 1001;
            background-color: var(--fb-primary);
            color: white;
            border: none;
            border-radius: 8px 0 0 8px;
            padding: 40px 8px;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: -2px 2px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            letter-spacing: 2px;
        }

        .offcanvas-tab:hover {
            background-color: var(--fb-primary-dark);
            box-shadow: -4px 4px 12px rgba(0, 0, 0, 0.4);
        }

        .offcanvas-tab.tab-right {
            right: 0;
            border-radius: 8px 0 0 8px;
        }

        .offcanvas-tab.tab-right:hover {
            right: 5px;
        }

        .offcanvas-tab.tab-left {
            left: 0;
            border-radius: 0 8px 8px 0;
            box-shadow: 2px 2px 8px rgba(0, 0, 0, 0.3);
        }

        .offcanvas-tab.tab-left:hover {
            left: 5px;
            box-shadow: 4px 4px 12px rgba(0, 0, 0, 0.4);
        }

        .offcanvas-header {
            background-color: var(--fb-primary);
            color: white;
            border-bottom: 2px solid var(--fb-primary-dark);
        }

        .offcanvas-title {
            color: white;
            font-weight: 600;
        }

        .config-group {
            margin-bottom: 1.5rem;
            padding: 1rem;
            background-color: var(--fb-gray-100);
            border-radius: var(--bs-border-radius);
        }

        .config-group h5 {
            color: var(--fb-primary-dark);
            margin-bottom: 1rem;
            font-size: 1rem;
            font-weight: 600;
        }

        /* Compact view toggle buttons */
        .view-toggle-btn {
            padding: 6px 12px;
            font-size: 0.875rem;
        }

        .view-toggle-btn.btn-sm {
            padding: 4px 8px;
            font-size: 0.8125rem;
            border-width: 1px;
        }

        /* Override Bootstrap btn-sm for even smaller buttons */
        .btn-sm {
            padding: 0.25rem 0.5rem !important;
            font-size: 0.8125rem !important;
            line-height: 1.5 !important;
        }

        /* Icon-only toggle buttons with ON/OFF states */
        .toggle-icon-btn {
            width: 38px;
            height: 38px;
            padding: 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border: 2px solid var(--fb-gray-400);
            background-color: white;
            color: var(--fb-gray-600);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1.1rem;
        }

        .toggle-icon-btn.btn-sm {
            width: 31px;
            height: 31px;
            font-size: 0.875rem;
            border-width: 1px;
        }

        .toggle-icon-btn:hover {
            background-color: var(--fb-gray-100);
            border-color: var(--fb-gray-500);
        }

        .toggle-icon-btn.active {
            background-color: var(--fb-success);
            border-color: var(--fb-success);
            color: white;
        }

        .toggle-icon-btn.active:hover {
            background-color: var(--fb-success-dark, #1e7e34);
            border-color: var(--fb-success-dark, #1e7e34);
        }

        /* Remove red border from vis-timeline elements */
        .vis-labelset .vis-label,
        .vis-panel.vis-left,
        .vis-foreground .vis-group {
            border-color: #ddd !important;
        }

        /* Ensure dependency arrows are behind timeline labels */
        #dependencyArrowsSvg {
            z-index: 0 !important;
        }

        .vis-labelset,
        .vis-panel.vis-left {
            z-index: 5 !important;
        }

        /* Weekend highlighting */
        .vis-time-axis .vis-grid.vis-saturday,
        .vis-time-axis .vis-grid.vis-sunday,
        .vis-time-axis .vis-grid.vis-minor.weekend-column {
            background-color: #f5f5f5 !important;
        }

        .vis-panel.vis-background .vis-vertical.vis-saturday,
        .vis-panel.vis-background .vis-vertical.vis-sunday,
        .vis-panel.vis-background .vis-vertical.weekend-column {
            background-color: #f5f5f5 !important;
        }

        /* Force category colors on labels and backgrounds */
        .vis-labelset .vis-label[data-category-color] {
            background-color: var(--cat-bg-color) !important;
        }

        .vis-panel.vis-background .vis-group[data-category-color] {
            background-color: var(--cat-bg-color) !important;
        }

        /* ============================================
           Capacity View Styling
           ============================================ */

        #capacity-view-container {
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 20px;
            margin-bottom: 1rem;
        }

        .capacity-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .capacity-week-display {
            font-weight: 600;
            font-size: 1.1rem;
            min-width: 200px;
            text-align: center;
        }

        /* Bootstrap table customization for capacity view */
        #capacity-table {
            font-size: 0.875rem;
            margin-bottom: 0;
        }

        #capacity-table thead th {
            background-color: #e9ecef;
            font-weight: 600;
            text-align: center;
            padding: 10px 8px;
            border: 1px solid #dee2e6;
            vertical-align: middle;
        }

        /* Weekend column highlighting */
        #capacity-table thead th.weekend,
        #capacity-table tbody td.weekend {
            background-color: #f5f5f5 !important;
        }

        .category-header {
            background-color: #dee2e6;
            min-width: 150px;
        }

        .day-header {
            min-width: 120px;
        }

        .day-header-date {
            font-size: 0.75rem;
            color: #6c757d;
        }

        /* Category name cell - similar to category view labels */
        .category-name-cell {
            background-color: #f8f9fa;
            vertical-align: middle;
            padding: 12px;
            border: 1px solid #dee2e6;
            font-weight: 600;
        }

        .category-name {
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 0.95rem;
            padding: 4px 8px;
            border-radius: 4px;
            display: inline-block;
        }

        .adjust-capacity-btn {
            width: 100%;
            margin-top: 4px;
        }

        /* Capacity row cells */
        .capacity-cell {
            background-color: #f8f9fa;
            text-align: center;
            padding: 6px;
            border: 1px solid #dee2e6;
            border-bottom: 2px solid #adb5bd;
            vertical-align: middle;
        }

        /* WO cells - dynamic height based on content */
        .wo-cell {
            min-height: 40px;
            padding: 6px;
            background-color: #fff;
            border: 1px solid #dee2e6;
            vertical-align: middle;
            position: relative;
        }

        /* Individual WO bar - using status colors like timeline view */
        .capacity-wo-bar {
            padding: 6px 10px;
            border-radius: 4px;
            color: white;
            font-size: 0.75rem;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: grab;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            transition: transform 0.15s, box-shadow 0.15s;
            position: relative;
            border: 2px solid transparent;
        }

        .capacity-wo-bar:active {
            cursor: grabbing;
        }

        .capacity-wo-bar:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
            z-index: 10;
            border-color: rgba(255, 255, 255, 0.5);
        }

        /* Status-based colors matching timeline view */
        .capacity-wo-bar.status-entered {
            background-color: var(--fb-info) !important;
            border-color: var(--fb-info) !important;
        }

        .capacity-wo-bar.status-started {
            background-color: var(--fb-warning) !important;
            border-color: var(--fb-warning) !important;
        }

        .capacity-wo-bar.status-fulfilled {
            background-color: var(--fb-success) !important;
            border-color: var(--fb-success) !important;
        }

        .wo-bar-label {
            font-weight: 500;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        /* Usage row cells */
        .usage-row {
            font-weight: 600;
        }

        .usage-cell {
            text-align: center;
            padding: 8px 6px;
            border: 1px solid #dee2e6;
            vertical-align: middle;
            transition: background-color 0.3s;
        }

        .usage-cell.bg-danger {
            background-color: #dc3545 !important;
            color: white !important;
        }

        .usage-cell.bg-success {
            background-color: #28a745 !important;
            color: white !important;
        }

        .usage-cell.bg-warning {
            background-color: #ffc107 !important;
            color: #000 !important;
        }

        .usage-display {
            font-size: 0.8rem;
        }

        /* Capacity adjustment modal */
        .capacity-modal .modal-body {
            max-height: 400px;
            overflow-y: auto;
        }

        .capacity-input-group {
            margin-bottom: 12px;
        }

        .capacity-input-group label {
            font-weight: 500;
            margin-bottom: 4px;
            font-size: 0.875rem;
        }

        .capacity-input-group input {
            font-size: 0.875rem;
        }

        /* Session warning alert */
        .session-warning {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1050;
            max-width: 350px;
        }
    </style>
</head>
<body>
    <!-- Folder Tab Buttons -->
    <button class="offcanvas-tab tab-left" type="button" data-bs-toggle="offcanvas" data-bs-target="#settingsOffcanvas" aria-controls="settingsOffcanvas">
        SETTINGS
    </button>
    <button class="offcanvas-tab tab-right" type="button" data-bs-toggle="offcanvas" data-bs-target="#instructionsOffcanvas" aria-controls="instructionsOffcanvas">
        INSTRUCTIONS
    </button>
    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay">
        <div class="spinner-border loading-spinner text-light" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container position-fixed top-0 end-0 p-3" style="z-index: 11000;">
        <!-- Toasts will be dynamically added here -->
    </div>

    <!-- Settings Offcanvas -->
    <div class="offcanvas offcanvas-start" tabindex="-1" id="settingsOffcanvas" aria-labelledby="settingsOffcanvasLabel" style="width: 400px;">
        <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="settingsOffcanvasLabel">
                <i class="bi bi-gear-fill"></i> Settings & Filters
            </h5>
            <button type="button" class="btn-close btn-close-white" data-bs-dismiss="offcanvas" aria-label="Close"></button>
        </div>
        <div class="offcanvas-body">
            <div class="config-group">
                <h5><i class="bi bi-funnel"></i> Filters</h5>

                <div class="mb-3">
                    <label for="moFilterOffcanvas" class="form-label">
                        <i class="bi bi-diagram-3"></i> Filter by MO
                    </label>
                    <select id="moFilterOffcanvas" class="form-select form-select-sm">
                        <option value="all">All MOs</option>
                    </select>
                </div>
            </div>

            <div class="config-group">
                <h5><i class="bi bi-toggles"></i> Options</h5>

                <div class="mb-3">
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" role="switch" id="allowSameDayStartOffcanvas" checked>
                        <label class="form-check-label" for="allowSameDayStartOffcanvas" style="cursor: pointer; font-size: 0.875rem;">
                            Allow same-day starts
                        </label>
                    </div>
                    <small class="text-muted">When enabled, a WO can start on the same day its dependency finishes (no conflict).</small>
                </div>

                <div class="mb-3">
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" role="switch" id="shiftDependentWOsOffcanvas">
                        <label class="form-check-label" for="shiftDependentWOsOffcanvas" style="cursor: pointer; font-size: 0.875rem;">
                            Shift dependent WOs when dragging
                        </label>
                    </div>
                    <small class="text-muted">When enabled, dragging a WO will shift all dependent WOs by the same amount.</small>
                </div>

                <div class="mb-3">
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" role="switch" id="skipWeekendsOffcanvas" checked>
                        <label class="form-check-label" for="skipWeekendsOffcanvas" style="cursor: pointer; font-size: 0.875rem;">
                            Skip weekends when scheduling
                        </label>
                    </div>
                    <small class="text-muted">When enabled, WOs cannot be scheduled on weekends (Sat/Sun). Dragging will snap to weekdays.</small>
                </div>
            </div>

            <div class="d-grid gap-2">
                <button id="refreshBtn" class="btn btn-primary btn-sm">
                    <i class="bi bi-arrow-clockwise"></i> Apply & Refresh
                </button>
            </div>
        </div>
    </div>

    <!-- Instructions Offcanvas -->
    <div class="offcanvas offcanvas-end" tabindex="-1" id="instructionsOffcanvas" aria-labelledby="instructionsOffcanvasLabel" style="width: 500px;">
        <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="instructionsOffcanvasLabel">
                <i class="bi bi-book-fill"></i> Instructions
            </h5>
            <button type="button" class="btn-close btn-close-white" data-bs-dismiss="offcanvas" aria-label="Close"></button>
        </div>
        <div class="offcanvas-body">
            <div class="config-group">
                <h5><i class="bi bi-info-circle"></i> About This Report</h5>
                <p>This interactive Gantt chart visualizes Work Orders using the vis-timeline library. Toggle between MO Gantt View (grouped by Manufacturing Order) and Category Swim Lane View (grouped by manufacturing category for capacity planning).</p>
            </div>

            <div class="config-group">
                <h5><i class="bi bi-palette"></i> Status Colors</h5>
                <div class="mb-2">
                    <span class="badge" style="background-color: var(--fb-info);">Entered</span>
                    - WO has been entered but not started
                </div>
                <div class="mb-2">
                    <span class="badge" style="background-color: var(--fb-warning);">Started</span>
                    - WO is currently in progress
                </div>
                <div class="mb-2">
                    <span class="badge" style="background-color: var(--fb-success);">Fulfilled</span>
                    - WO has been completed
                </div>
                <div class="mb-2">
                    <span class="badge" style="background-color: var(--fb-danger);">CONFLICT!</span>
                    - Scheduling conflict detected (dependency not met)
                </div>
            </div>

            <div class="config-group">
                <h5><i class="bi bi-mouse"></i> Interactions</h5>
                <ul class="small">
                    <li><strong>Drag WO:</strong> Click and drag a WO bar to reschedule it</li>
                    <li><strong>Resize WO:</strong> Drag the left or right edge to adjust start/finish dates</li>
                    <li><strong>Double-click WO:</strong> Opens the Manufacturing Order in Fishbowl</li>
                    <li><strong>Hover over WO:</strong> See dependency arrows highlighted</li>
                    <li><strong>Drag timeline:</strong> Hold Ctrl/Cmd and drag, or use scroll wheel</li>
                    <li><strong>Zoom:</strong> Pinch gesture or Ctrl+scroll, or use zoom buttons</li>
                </ul>
            </div>

            <div class="config-group">
                <h5><i class="bi bi-diagram-3"></i> Dependencies & Conflicts</h5>
                <p><strong>Dependency Arrows:</strong> Gray arrows show which WOs provide parts/materials to other WOs (within the same MO only). Red arrows indicate conflicts.</p>
                <p><strong>Conflict Detection:</strong> A WO turns <span style="color: var(--fb-danger); font-weight: bold;">RED</span> when a dependent WO's scheduled finish date is AFTER (or same day if "Allow same-day starts" is disabled) the current WO's start date.</p>
                <p class="small"><em>Example: If WO-002 needs parts from WO-001, but WO-001 finishes on Dec 15 and WO-002 starts on Dec 10, WO-002 will be RED.</em></p>
            </div>

            <div class="config-group">
                <h5><i class="bi bi-layout-three-columns"></i> View Modes</h5>
                <p><strong>MO Gantt View:</strong> Groups WOs by Manufacturing Order. Best for tracking individual order progress and dependencies.</p>
                <p><strong>Category Swim Lane View:</strong> Groups WOs by manufacturing category (Fabrication, Powdercoating, etc.). Best for capacity planning and resource utilization across categories.</p>
            </div>

            <div class="config-group">
                <h5><i class="bi bi-calendar3"></i> Category Colors</h5>
                <p>In Category Swim Lane View, each category swim lane is colored according to the Calendar Category defined in Fishbowl. This helps quickly identify different manufacturing processes.</p>
            </div>
        </div>
    </div>

    <div class="container-fluid p-4">
        <!-- Header -->
        <div class="row mb-3">
            <div class="col">
                <h2>
                    <i class="bi bi-diagram-3"></i>
                    Work Order Capacity Planning - Gantt Chart
                </h2>
                <p class="text-muted">Toggle between MO Gantt, Category, and Capacity Planning views</p>
            </div>
        </div>

        <!-- Compact Controls -->
        <div class="info-card">
            <div class="row align-items-center g-2">
                <div class="col-auto">
                    <div class="btn-group btn-group-sm" role="group">
                        <button id="moViewBtn" class="view-toggle-btn btn-sm active">
                            <i class="bi bi-list-nested"></i> MO Gantt
                        </button>
                        <button id="categoryViewBtn" class="view-toggle-btn btn-sm">
                            <i class="bi bi-layout-three-columns"></i> Category
                        </button>
                        <button id="capacityViewBtn" class="view-toggle-btn btn-sm">
                            <i class="bi bi-calendar3-week"></i> Capacity
                        </button>
                    </div>
                </div>
                <div class="col-auto">
                    <select class="form-select form-select-sm" id="moFilter" style="min-width: 200px;">
                        <option value="all">All MOs</option>
                    </select>
                </div>
                <div class="col-auto">
                    <select class="form-select form-select-sm" id="statusFilter" style="min-width: 120px;">
                        <option value="all">All Statuses</option>
                        <option value="10">Entered</option>
                        <option value="30">Started</option>
                        <option value="40">Fulfilled</option>
                        <option value="conflict">Conflicts</option>
                    </select>
                </div>
                <div class="col-auto ms-auto">
                    <div class="d-flex gap-2 align-items-center">
                        <div class="btn-group btn-group-sm" role="group">
                            <button id="undoBtn" class="btn btn-outline-secondary btn-sm" title="Undo" disabled>
                                <i class="bi bi-arrow-counterclockwise"></i>
                            </button>
                            <button id="redoBtn" class="btn btn-outline-secondary btn-sm" title="Redo" disabled>
                                <i class="bi bi-arrow-clockwise"></i>
                            </button>
                        </div>
                        <button id="refreshDataBtn" class="btn btn-outline-secondary btn-sm" title="Refresh Data">
                            <i class="bi bi-arrow-repeat"></i>
                        </button>
                        <div class="btn-group btn-group-sm" role="group">
                            <button id="zoomInBtn" class="btn btn-outline-secondary btn-sm" title="Zoom In">
                                <i class="bi bi-zoom-in"></i>
                            </button>
                            <button id="zoomOutBtn" class="btn btn-outline-secondary btn-sm" title="Zoom Out">
                                <i class="bi bi-zoom-out"></i>
                            </button>
                        </div>
                        <div class="btn-group btn-group-sm" role="group">
                            <button id="prevWeekBtn" class="btn btn-outline-secondary btn-sm" title="Previous Week">
                                <i class="bi bi-chevron-left"></i>
                            </button>
                            <button id="nextWeekBtn" class="btn btn-outline-secondary btn-sm" title="Next Week">
                                <i class="bi bi-chevron-right"></i>
                            </button>
                        </div>
                        <div class="btn-group btn-group-sm" role="group">
                            <button id="zoomWeekBtn" class="btn btn-outline-secondary btn-sm" title="Show 1 Week">1W</button>
                            <button id="zoom2WeeksBtn" class="btn btn-outline-secondary btn-sm" title="Show 2 Weeks">2W</button>
                            <button id="zoomMonthBtn" class="btn btn-outline-secondary btn-sm" title="Show 1 Month">1M</button>
                            <button id="zoom3MonthsBtn" class="btn btn-outline-secondary btn-sm" title="Show 3 Months">3M</button>
                        </div>
                        <div class="btn-group btn-group-sm" role="group">
                            <button id="todayBtn" class="btn btn-outline-primary btn-sm">
                                <i class="bi bi-calendar-day"></i> Today
                            </button>
                        </div>
                        <button id="shiftDependentWOs" class="toggle-icon-btn btn-sm" title="Shift dependent WOs when dragging">
                            <i class="bi bi-arrow-left-right"></i>
                        </button>
                        <button id="allowSameDayStart" class="toggle-icon-btn btn-sm active" title="Allow same-day starts (dependencies can finish on the same day WO starts)">
                            <i class="bi bi-calendar-check"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Timeline Container -->
        <div id="timeline-container">
            <div id="visualization"></div>
            <div id="emptyState" class="empty-state" style="display: none;">
                <i class="bi bi-inbox"></i>
                <h3>No Work Orders Found</h3>
                <p>Try adjusting your filters or date range</p>
            </div>
        </div>

        <!-- Capacity View Container -->
        <div id="capacity-view-container" style="display: none;">
            <div class="capacity-controls">
                <button id="capacity-prev-week" class="btn btn-sm btn-outline-secondary" title="Previous Week">
                    <i class="bi bi-chevron-double-left"></i> Week
                </button>
                <button id="capacity-prev-day" class="btn btn-sm btn-outline-secondary" title="Previous Day">
                    <i class="bi bi-chevron-left"></i>
                </button>
                <span id="capacity-week-display" class="capacity-week-display"></span>
                <button id="capacity-next-day" class="btn btn-sm btn-outline-secondary" title="Next Day">
                    <i class="bi bi-chevron-right"></i>
                </button>
                <button id="capacity-next-week" class="btn btn-sm btn-outline-secondary" title="Next Week">
                    Week <i class="bi bi-chevron-double-right"></i>
                </button>
            </div>

            <div class="table-responsive">
                <table id="capacity-table" class="table table-sm table-bordered">
                    <!-- Will be populated dynamically -->
                </table>
            </div>
        </div>

        <!-- Info Panel -->
        <div class="info-card">
            <div class="row">
                <div class="col-md-6">
                    <h6>Interaction Guide</h6>
                    <ul class="small mb-0">
                        <li><strong>Drag WO:</strong> Click and drag to reschedule</li>
                        <li><strong>Resize WO:</strong> Drag left/right edge to adjust start/finish dates</li>
                        <li><strong>Drag Timeline:</strong> Hold Ctrl/Cmd and drag, or use scroll wheel</li>
                        <li><strong>Zoom:</strong> Pinch or Ctrl+scroll, or use zoom buttons</li>
                    </ul>
                </div>
                <div class="col-md-6" id="statsPanel">
                    <h6>Statistics</h6>
                    <p class="small mb-1"><strong>Total WOs:</strong> <span id="totalWOs">0</span></p>
                    <p class="small mb-1"><strong>Total MOs:</strong> <span id="totalMOs">0</span></p>
                    <p class="small mb-1"><strong>Dependencies:</strong> <span id="totalDeps">0</span></p>
                    <p class="small mb-0"><strong>Conflicts:</strong> <span id="totalConflicts">0</span></p>
                </div>
            </div>
        </div>

        <!-- Debug Console -->
        <div class="debug-section">
            <div class="accordion" id="debugAccordion">
                <div class="accordion-item">
                    <h2 class="accordion-header">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#debugContent">
                            <i class="bi bi-bug-fill me-2"></i> Debug Console
                        </button>
                    </h2>
                    <div id="debugContent" class="accordion-collapse collapse">
                        <div class="accordion-body p-0">
                            <div class="p-2 bg-dark text-white d-flex justify-content-between align-items-center">
                                <small>Debug log - Auto-scrolls to latest entry</small>
                                <button class="btn btn-sm btn-outline-light" onclick="clearDebugLog()">
                                    <i class="bi bi-trash"></i> Clear
                                </button>
                            </div>
                            <div class="debug-content" id="debugLog">
                                <div class="debug-entry">
                                    <span class="debug-timestamp">[00:00:00]</span>
                                    <span class="debug-type info">[INFO]</span>
                                    <span class="debug-message">Debug console initialized</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Moment.js for date handling -->
    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.4/moment.min.js"></script>

    <!-- vis-timeline JS -->
    <script src="https://unpkg.com/vis-timeline@7.7.3/standalone/umd/vis-timeline-graph2d.min.js"></script>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

<script>
{% Script Util %}

// ============================================
// Global Variables
// ============================================
let timeline = null;
let viewMode = 'mo'; // 'mo', 'category', or 'capacity'
let allWorkOrders = [];
let filteredWorkOrders = [];
let stagingDependencies = [];
let manufacturingOrders = [];
let workOrderCategories = [];
let activeStatusFilter = null;
let groups = [];
let items = [];

// Undo/Redo stacks
let undoStack = [];
let redoStack = [];

// Capacity Planning Variables
let capacitySettings = {
    categories: []
};
let currentCapacityWeek = null;
const MAX_UNDO_STACK = 50; // Limit stack size to prevent memory issues

// ============================================
// Debug Logging Functions
// ============================================
function debugLog(type, message, data = null) {
    const timestamp = new Date().toLocaleTimeString();
    const logEntry = document.createElement('div');
    logEntry.className = 'debug-entry';

    let html = `
        <span class="debug-timestamp">[${timestamp}]</span>
        <span class="debug-type ${type}">[${type.toUpperCase()}]</span>
        <span class="debug-message">${message}</span>
    `;

    if (data) {
        const dataStr = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
        html += `<div class="debug-data">${dataStr}</div>`;
    }

    logEntry.innerHTML = html;

    const debugLogEl = document.getElementById('debugLog');
    if (debugLogEl) {
        debugLogEl.appendChild(logEntry);
        debugLogEl.scrollTop = debugLogEl.scrollHeight;
    }

    console.log(`[${type.toUpperCase()}] ${message}`, data);
}

function clearDebugLog() {
    const debugLogEl = document.getElementById('debugLog');
    if (debugLogEl) {
        debugLogEl.innerHTML = `
            <div class="debug-entry">
                <span class="debug-timestamp">[${new Date().toLocaleTimeString()}]</span>
                <span class="debug-type info">[INFO]</span>
                <span class="debug-message">Debug log cleared</span>
            </div>
        `;
    }
}

// ============================================
// Loading Indicator
// ============================================
function showLoading(show) {
    const overlay = document.getElementById('loadingOverlay');
    if (show) {
        overlay.classList.add('show');
    } else {
        overlay.classList.remove('show');
    }
}

function showEmptyState(show) {
    document.getElementById('emptyState').style.display = show ? 'block' : 'none';
    document.getElementById('visualization').style.display = show ? 'none' : 'block';
}

// ============================================
// Toast Notifications
// ============================================
function showToast(message, type = 'info', sticky = false) {
    debugLog(type, message);

    const toastContainer = document.querySelector('.toast-container');
    if (!toastContainer) {
        console.error('Toast container not found');
        return;
    }

    // Create unique ID for this toast
    const toastId = 'toast_' + Date.now();

    // Determine icon and colors based on type
    let icon, bgClass, headerText;
    switch (type) {
        case 'success':
            icon = 'bi-check-circle-fill';
            bgClass = 'bg-success';
            headerText = 'Success';
            break;
        case 'error':
            icon = 'bi-exclamation-triangle-fill';
            bgClass = 'bg-danger';
            headerText = 'Error';
            break;
        case 'warning':
            icon = 'bi-exclamation-circle-fill';
            bgClass = 'bg-warning';
            headerText = 'Warning';
            break;
        default:
            icon = 'bi-info-circle-fill';
            bgClass = 'bg-info';
            headerText = 'Info';
    }

    // Create toast element
    const toastEl = document.createElement('div');
    toastEl.id = toastId;
    toastEl.className = 'toast';
    toastEl.setAttribute('role', 'alert');
    toastEl.setAttribute('aria-live', 'assertive');
    toastEl.setAttribute('aria-atomic', 'true');

    // Set autohide based on sticky parameter (errors are persistent)
    if (sticky || type === 'error') {
        toastEl.setAttribute('data-bs-autohide', 'false');
    } else {
        toastEl.setAttribute('data-bs-autohide', 'true');
        toastEl.setAttribute('data-bs-delay', '5000');
    }

    toastEl.innerHTML = `
        <div class="toast-header ${bgClass} text-white">
            <i class="bi ${icon} me-2"></i>
            <strong class="me-auto">${headerText}</strong>
            <small>just now</small>
            <button type="button" class="btn-close btn-close-white" data-bs-dismiss="toast" aria-label="Close"></button>
        </div>
        <div class="toast-body">
            ${message}
        </div>
    `;

    // Add to container
    toastContainer.appendChild(toastEl);

    // Initialize and show toast
    const toast = new bootstrap.Toast(toastEl);
    toast.show();

    // Remove from DOM after hidden (if not sticky)
    if (!sticky && type !== 'error') {
        toastEl.addEventListener('hidden.bs.toast', function() {
            toastEl.remove();
        });
    }
}

// ============================================
// Load Work Orders from Database
// ============================================
function loadWorkOrders() {
    showLoading(true);

    const woQuery = `
        SELECT
            mo.num AS mo_num,
            mo.id AS mo_id,
            wo.id AS wo_id,
            wo.num AS wo_num,
            wo.statusid AS wo_status,
            CASE wo.statusid
                WHEN 10 THEN 'Entered'
                WHEN 30 THEN 'Started'
                WHEN 40 THEN 'Fulfilled'
                ELSE 'Unknown'
            END AS wo_status_name,
            moitem.description AS description,
            COALESCE(bom.estimatedDuration, 0) * COALESCE(wo.qtyTarget, 0) AS estimated_duration,
            COALESCE(wo.datescheduled, moitem.datescheduled) AS date_scheduled,
            COALESCE(wo.datescheduledtostart, moitem.datescheduledtostart) AS date_scheduled_start,
            wo.datefinished AS date_finished,
            COALESCE(calcat.name, '') AS calendar_category,
            COALESCE(calcat.color, 'CCCCCC') AS category_color,
            COALESCE(calcat.id, 0) AS calcategory_id,
            wo.qtyTarget AS qty_target,
            COALESCE(bom.estimatedDuration, 0) AS bom_duration_minutes,
            (SELECT part.num FROM woitem
             LEFT JOIN part ON woitem.partid = part.id
             WHERE woitem.woid = wo.id AND woitem.typeid = 10
             LIMIT 1) AS part_num,
            (SELECT SUM(
                CASE
                    WHEN bomitem.uomid = (SELECT id FROM uom WHERE name = 'Hour' LIMIT 1) THEN
                        COALESCE(bomitem.quantity, 0)
                    WHEN EXISTS (
                        SELECT 1 FROM uomconversion
                        WHERE fromuomid = bomitem.uomid
                        AND touomid = (SELECT id FROM uom WHERE name = 'Hour' LIMIT 1)
                    ) THEN
                        COALESCE(bomitem.quantity, 0) * (
                            SELECT (multiply / factor)
                            FROM uomconversion
                            WHERE fromuomid = bomitem.uomid
                            AND touomid = (SELECT id FROM uom WHERE name = 'Hour' LIMIT 1)
                            LIMIT 1
                        )
                    WHEN EXISTS (
                        SELECT 1 FROM uomconversion
                        WHERE fromuomid = (SELECT id FROM uom WHERE name = 'Hour' LIMIT 1)
                        AND touomid = bomitem.uomid
                    ) THEN
                        COALESCE(bomitem.quantity, 0) / (
                            SELECT (multiply / factor)
                            FROM uomconversion
                            WHERE fromuomid = (SELECT id FROM uom WHERE name = 'Hour' LIMIT 1)
                            AND touomid = bomitem.uomid
                            LIMIT 1
                        )
                    ELSE 0
                END
            )
            FROM bomitem
            INNER JOIN part ON bomitem.partid = part.id
            WHERE bomitem.bomid = bom.id
            AND part.typeid = 21) AS labor_hours_from_bom
        FROM wo
        LEFT JOIN moitem ON wo.moitemid = moitem.id
        LEFT JOIN mo ON moitem.moid = mo.id
        LEFT JOIN bom ON moitem.bomid = bom.id
        LEFT JOIN calcategory AS calcat ON wo.calcategoryid = calcat.id
        WHERE wo.num IS NOT NULL
            AND wo.statusid IN (10, 30, 40)
            AND moitem.typeid = 50
        ORDER BY mo.num, wo.num
    `;

    const depQuery = `
        SELECT DISTINCT
            wo.id AS wo_id,
            wo.num AS wo_num,
            staging_wo.id AS staging_wo_id,
            staging_wo.num AS staging_wo_num,
            COALESCE(staging_wo.datescheduled, staging_moitem.datescheduled) AS staging_wo_finish,
            COALESCE(wo.datescheduledtostart, current_moitem.datescheduledtostart) AS wo_start,
            part.num AS part_num
        FROM wo
        LEFT JOIN moitem AS current_moitem ON wo.moitemid = current_moitem.id
        LEFT JOIN mo AS current_mo ON current_moitem.moid = current_mo.id
        LEFT JOIN woitem ON woitem.woid = wo.id AND woitem.typeid = 20
        LEFT JOIN part ON woitem.partid = part.id
        LEFT JOIN woitem AS staging_woitem ON staging_woitem.partid = part.id AND staging_woitem.typeid = 10
        LEFT JOIN wo AS staging_wo ON staging_woitem.woid = staging_wo.id
        LEFT JOIN moitem AS staging_moitem ON staging_wo.moitemid = staging_moitem.id
        LEFT JOIN mo AS staging_mo ON staging_moitem.moid = staging_mo.id
        WHERE wo.num IS NOT NULL
            AND wo.statusid IN (10, 30, 40)
            AND staging_wo.num IS NOT NULL
            AND staging_wo.id != wo.id
            AND current_mo.id = staging_mo.id
    `;

    const moQuery = `
        SELECT DISTINCT
            mo.num AS mo_num,
            mo.id AS mo_id,
            mo.statusid AS mo_status,
            mo.datescheduled AS mo_date_scheduled,
            part.num AS part_num,
            moitem.description AS description,
            moitem.qtytofulfill AS qty,
            bom.num AS bom_num
        FROM mo
        LEFT JOIN moitem ON moitem.moid = mo.id
        LEFT JOIN part ON moitem.partid = part.id
        LEFT JOIN bom ON moitem.bomid = bom.id
        WHERE moitem.typeid = 50
            AND moitem.parentid IS NULL
            AND mo.id IN (
                SELECT DISTINCT mo.id
                FROM wo
                LEFT JOIN moitem ON wo.moitemid = moitem.id
                LEFT JOIN mo ON moitem.moid = mo.id
                WHERE wo.num IS NOT NULL AND wo.statusid IN (10, 30, 40)
            )
        ORDER BY mo.num
    `;

    try {
        debugLog('info', 'Starting to load work orders...');

        // Load WOs
        const woResults = JSON.parse(runQuery(woQuery));
        // Process work orders to add hour calculations
        allWorkOrders = processWorkOrdersWithHours(woResults);
        debugLog('success', `Loaded ${allWorkOrders.length} work orders`);

        // Load staging dependencies
        const depResults = JSON.parse(runQuery(depQuery));
        stagingDependencies = depResults;
        debugLog('success', `Loaded ${stagingDependencies.length} staging dependencies`);

        // Load MO finished goods
        const moResults = JSON.parse(runQuery(moQuery));
        manufacturingOrders = moResults;
        debugLog('success', `Loaded ${manufacturingOrders.length} MO finished goods`);

        // Filter old fulfilled MOs
        filterOldFulfilledMOs();

        // Populate MO filter
        populateMOFilter();

        // Initialize capacity settings with loaded categories
        initializeCapacitySettings();

        // Initialize timeline
        initTimeline();

        showLoading(false);
    } catch (error) {
        debugLog('error', 'Error loading work orders', error.toString());
        showToast('Error loading work orders: ' + error.toString(), 'error', true);
        showLoading(false);
        showEmptyState(true);
    }
}

// ============================================
// WO Hours Calculation Functions
// ============================================
function calculateWOHours(wo) {
    let totalHours = 0;

    // Priority 1: BOM estimated duration (convert minutes to hours)
    if (wo.bom_duration_minutes && wo.bom_duration_minutes > 0) {
        totalHours = (wo.bom_duration_minutes / 60) * wo.qty_target;
        debugLog('info', `WO ${wo.wo_num}: Using BOM duration ${wo.bom_duration_minutes}min * ${wo.qty_target}qty = ${totalHours.toFixed(2)}hrs`);
    }
    // Priority 2: Labor hours from BOM parts (already in hours)
    else if (wo.labor_hours_from_bom && wo.labor_hours_from_bom > 0) {
        totalHours = wo.labor_hours_from_bom * wo.qty_target;
        debugLog('info', `WO ${wo.wo_num}: Using labor parts ${wo.labor_hours_from_bom}hrs * ${wo.qty_target}qty = ${totalHours.toFixed(2)}hrs`);
    }
    // Priority 3: Default fallback (1 hour per day)
    else {
        const dateRange = moment(wo.date_scheduled).diff(
            moment(wo.date_scheduled_start),
            'days'
        ) + 1;
        totalHours = Math.max(1, dateRange) * 1; // 1 hour per day, minimum 1 hour
        debugLog('warn', `WO ${wo.wo_num}: No BOM data found, using fallback ${totalHours}hrs (1hr/day * ${dateRange}days)`);
    }

    return Math.max(0, totalHours); // Ensure non-negative
}

function calculateDailyHours(wo, totalHours) {
    const dateRange = moment(wo.date_scheduled).diff(
        moment(wo.date_scheduled_start),
        'days'
    ) + 1;

    if (dateRange <= 0) {
        debugLog('warn', `WO ${wo.wo_num}: Invalid date range, defaulting to total hours`);
        return totalHours;
    }

    const dailyHours = totalHours / dateRange;
    debugLog('info', `WO ${wo.wo_num}: ${totalHours.toFixed(2)}hrs / ${dateRange}days = ${dailyHours.toFixed(2)}hrs/day`);

    return dailyHours;
}

function processWorkOrdersWithHours(workOrders) {
    return workOrders.map(wo => {
        const totalHours = calculateWOHours(wo);
        const dailyHours = calculateDailyHours(wo, totalHours);

        return {
            ...wo,
            total_hours: totalHours,
            daily_hours: dailyHours,
            date_range_days: moment(wo.date_scheduled).diff(
                moment(wo.date_scheduled_start),
                'days'
            ) + 1
        };
    });
}

// ============================================
// Capacity Planning Functions
// ============================================
function initializeCapacitySettings() {
    // Extract unique categories from work orders
    const uniqueCategories = new Map();

    allWorkOrders.forEach(wo => {
        if (wo.calcategory_id && !uniqueCategories.has(wo.calcategory_id)) {
            uniqueCategories.set(wo.calcategory_id, {
                id: wo.calcategory_id,
                name: wo.calendar_category || 'Uncategorized',
                color: '#' + wo.category_color,
                limits: [8, 8, 8, 8, 8, 0, 0] // Default: 8hrs Mon-Fri, 0hrs weekends
            });
        }
    });

    // Add uncategorized if needed
    if (!uniqueCategories.has(0)) {
        uniqueCategories.set(0, {
            id: 0,
            name: 'Uncategorized',
            color: '#CCCCCC',
            limits: [8, 8, 8, 8, 8, 0, 0]
        });
    }

    capacitySettings.categories = Array.from(uniqueCategories.values())
        .sort((a, b) => b.id - a.id); // Sort descending by ID

    workOrderCategories = capacitySettings.categories;

    debugLog('info', `Initialized ${capacitySettings.categories.length} capacity categories`);
}

function getCapacity(categoryId, dayOfWeek) {
    const cat = capacitySettings.categories.find(c => c.id === categoryId);
    return cat ? cat.limits[dayOfWeek] : 0;
}

function setCapacity(categoryId, dayOfWeek, hours) {
    const cat = capacitySettings.categories.find(c => c.id === categoryId);
    if (cat) {
        cat.limits[dayOfWeek] = hours;
    }
}

function distributeWOHoursToWeek(wo, weekStart, totalHours, dailyHours) {
    const weekEnd = weekStart.clone().add(6, 'days').endOf('day');
    const woStart = moment(wo.date_scheduled_start).startOf('day');
    const woEnd = moment(wo.date_scheduled).startOf('day');

    // Find overlap between WO date range and current week
    const visibleStart = moment.max(woStart, weekStart);
    const visibleEnd = moment.min(woEnd, weekEnd);

    // If no overlap, return empty
    if (visibleEnd.isBefore(visibleStart)) {
        return [];
    }

    // Build array of days with hours
    const distribution = [];
    let currentDay = visibleStart.clone();

    while (currentDay.isSameOrBefore(visibleEnd)) {
        distribution.push({
            date: currentDay.clone(),
            dayOfWeek: currentDay.isoWeekday() - 1, // 0=Mon, 6=Sun
            hours: dailyHours,
            isPartialWeek: woStart.isBefore(weekStart) || woEnd.isAfter(weekEnd)
        });
        currentDay.add(1, 'day');
    }

    return distribution;
}

function getWOsForCategoryAndDay(categoryId, weekStart, dayOfWeek) {
    const dayDate = weekStart.clone().add(dayOfWeek, 'days');

    // Filter WOs for this category that include this day
    const wosOnDay = allWorkOrders
        .filter(wo => {
            if (wo.calcategory_id !== categoryId) return false;
            if (wo.wo_status === 40) return false; // Skip fulfilled

            const woStart = moment(wo.date_scheduled_start).startOf('day');
            const woEnd = moment(wo.date_scheduled).startOf('day');

            return dayDate.isSameOrAfter(woStart) && dayDate.isSameOrBefore(woEnd);
        })
        // Sort by scheduled date (earliest first)
        .sort((a, b) => {
            return moment(a.date_scheduled).diff(moment(b.date_scheduled));
        })
        .map(wo => {
            const distribution = distributeWOHoursToWeek(
                wo,
                weekStart,
                wo.total_hours,
                wo.daily_hours
            );

            const dayData = distribution.find(d => d.dayOfWeek === dayOfWeek);

            return {
                wo: wo,
                hours: dayData ? dayData.hours : 0,
                isPartialWeek: dayData ? dayData.isPartialWeek : false
            };
        })
        .filter(woData => woData.hours > 0);

    return wosOnDay;
}

function getWOsForCategoryInWeek(categoryId, weekStart) {
    const weekEnd = weekStart.clone().add(6, 'days').endOf('day');

    // Filter WOs for this category that overlap this week
    const wosInWeek = allWorkOrders
        .filter(wo => {
            if (wo.calcategory_id !== categoryId) return false;
            if (wo.wo_status === 40) return false; // Skip fulfilled

            const woStart = moment(wo.date_scheduled_start).startOf('day');
            const woEnd = moment(wo.date_scheduled).startOf('day');

            // Check if WO overlaps with this week
            return woStart.isSameOrBefore(weekEnd) && woEnd.isSameOrAfter(weekStart);
        })
        // Sort by start date (earliest first), then by end date
        .sort((a, b) => {
            const startDiff = moment(a.date_scheduled_start).diff(moment(b.date_scheduled_start));
            if (startDiff !== 0) return startDiff;
            return moment(a.date_scheduled).diff(moment(b.date_scheduled));
        });

    return wosInWeek;
}

function buildCapacityTable(weekStart) {
    const table = document.getElementById('capacity-table');
    table.innerHTML = '';

    // Update week display
    const weekEnd = weekStart.clone().add(6, 'days');
    document.getElementById('capacity-week-display').textContent =
        `Week of ${weekStart.format('MMM D')} - ${weekEnd.format('MMM D, YYYY')}`;

    // Build header
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');
    headerRow.innerHTML = '<th class="category-header">Category</th>';

    for (let day = 0; day < 7; day++) {
        const dayDate = weekStart.clone().add(day, 'days');
        const th = document.createElement('th');
        const isWeekend = day === 5 || day === 6; // Saturday or Sunday
        th.className = isWeekend ? 'day-header weekend' : 'day-header';
        th.dataset.day = day;
        th.innerHTML = `
            <div>${dayDate.format('ddd')}</div>
            <div class="day-header-date">${dayDate.format('MMM D')}</div>
        `;
        headerRow.appendChild(th);
    }
    thead.appendChild(headerRow);
    table.appendChild(thead);

    // Build category rows
    const tbody = document.createElement('tbody');

    capacitySettings.categories.forEach(category => {
        const categoryFragment = buildCategoryRows(category, weekStart);
        tbody.appendChild(categoryFragment);
    });

    table.appendChild(tbody);

    // Calculate usage after rendering
    calculateCapacityUsage();
}

function buildCategoryRows(category, weekStart) {
    const fragment = document.createDocumentFragment();

    // Get all WOs for this category that overlap this week
    const wosInWeek = getWOsForCategoryInWeek(category.id, weekStart);

    // Calculate rowspan for category name cell (1 row per WO + 1 usage row)
    const totalRows = wosInWeek.length + 1;
    const lightColor = lightenColor(category.color.replace('#', ''), 70);

    // Create one row per WO
    wosInWeek.forEach((wo, index) => {
        const woRow = document.createElement('tr');
        woRow.className = 'wo-row';
        woRow.dataset.categoryId = category.id;
        woRow.dataset.woNum = wo.wo_num;

        // Category name cell only on first WO row
        if (index === 0) {
            const nameCell = document.createElement('td');
            nameCell.className = 'category-name-cell';
            nameCell.rowSpan = totalRows;
            nameCell.style.backgroundColor = lightColor;
            nameCell.innerHTML = `
                <div class="category-name" style="color: ${category.color}">
                    ${category.name}
                </div>
                <button class="btn btn-sm btn-outline-primary adjust-capacity-btn"
                        onclick="showCapacityAdjustModal(${category.id})">
                    <i class="bi bi-gear"></i> Adjust
                </button>
            `;
            woRow.appendChild(nameCell);
        }

        // Calculate WO start and end within this week
        const woStart = moment(wo.date_scheduled_start).startOf('day');
        const woEnd = moment(wo.date_scheduled).startOf('day');
        const weekEnd = weekStart.clone().add(6, 'days').endOf('day');

        // Clip to week boundaries
        const visibleStart = moment.max(woStart, weekStart);
        const visibleEnd = moment.min(woEnd, weekEnd);

        // Calculate day indices (0 = Monday, 6 = Sunday)
        const startDay = visibleStart.diff(weekStart, 'days');
        const endDay = visibleEnd.diff(weekStart, 'days');
        const colspan = endDay - startDay + 1;

        // Add empty cells before WO start
        for (let day = 0; day < startDay; day++) {
            const emptyCell = document.createElement('td');
            const isWeekend = day === 5 || day === 6;
            emptyCell.className = isWeekend ? 'wo-cell weekend' : 'wo-cell';
            emptyCell.dataset.categoryId = category.id;
            emptyCell.dataset.day = day;
            emptyCell.ondrop = dropWOInCapacity;
            emptyCell.ondragover = allowDrop;
            woRow.appendChild(emptyCell);
        }

        // Add WO cell with colspan
        const woCell = document.createElement('td');
        woCell.colSpan = colspan;
        const startsOnWeekend = startDay === 5 || startDay === 6;
        woCell.className = startsOnWeekend ? 'wo-cell weekend' : 'wo-cell';
        woCell.dataset.categoryId = category.id;
        woCell.dataset.startDay = startDay;
        woCell.dataset.endDay = endDay;
        woCell.ondrop = dropWOInCapacity;
        woCell.ondragover = allowDrop;

        // Create WO bar content
        const woBar = createWOBarForCell(wo, weekStart, woStart, woEnd);
        woCell.appendChild(woBar);
        woRow.appendChild(woCell);

        // Add empty cells after WO end
        for (let day = endDay + 1; day < 7; day++) {
            const emptyCell = document.createElement('td');
            const isWeekend = day === 5 || day === 6;
            emptyCell.className = isWeekend ? 'wo-cell weekend' : 'wo-cell';
            emptyCell.dataset.categoryId = category.id;
            emptyCell.dataset.day = day;
            emptyCell.ondrop = dropWOInCapacity;
            emptyCell.ondragover = allowDrop;
            woRow.appendChild(emptyCell);
        }

        fragment.appendChild(woRow);
    });

    // Usage row - always 7 cells
    const usageRow = document.createElement('tr');
    usageRow.className = 'usage-row';
    usageRow.dataset.categoryId = category.id;

    // If no WOs, add category name cell here
    if (wosInWeek.length === 0) {
        const nameCell = document.createElement('td');
        nameCell.className = 'category-name-cell';
        nameCell.rowSpan = 1;
        nameCell.style.backgroundColor = lightColor;
        nameCell.innerHTML = `
            <div class="category-name" style="color: ${category.color}">
                ${category.name}
            </div>
            <button class="btn btn-sm btn-outline-primary adjust-capacity-btn"
                    onclick="showCapacityAdjustModal(${category.id})">
                <i class="bi bi-gear"></i> Adjust
            </button>
        `;
        usageRow.appendChild(nameCell);
    }

    for (let day = 0; day < 7; day++) {
        const isWeekend = day === 5 || day === 6;
        const usageCell = document.createElement('td');
        usageCell.className = isWeekend ? 'usage-cell text-center weekend' : 'usage-cell text-center';
        usageCell.dataset.categoryId = category.id;
        usageCell.dataset.day = day;
        usageCell.innerHTML = `<span class="usage-display">0 / ${category.limits[day]}hrs</span>`;
        usageRow.appendChild(usageCell);
    }
    fragment.appendChild(usageRow);

    return fragment;
}

function createWOBarForCell(wo, weekStart, woStart, woEnd) {
    const bar = document.createElement('div');
    const weekEnd = weekStart.clone().add(6, 'days').endOf('day');

    // Calculate start and end day indices within the week
    const visibleStart = moment.max(woStart, weekStart);
    const visibleEnd = moment.min(woEnd, weekEnd);
    const startDay = visibleStart.diff(weekStart, 'days');
    const endDay = visibleEnd.diff(weekStart, 'days');

    // Apply status classes matching timeline view
    let statusClass = '';
    if (wo.wo_status === 10) statusClass = 'status-entered';
    else if (wo.wo_status === 30) statusClass = 'status-started';
    else if (wo.wo_status === 40) statusClass = 'status-fulfilled';

    bar.className = `capacity-wo-bar ${statusClass}`;
    bar.dataset.woId = wo.wo_id;
    bar.dataset.woNum = wo.wo_num;
    bar.dataset.categoryId = wo.calcategory_id;
    bar.dataset.startDay = startDay;
    bar.dataset.endDay = endDay;
    bar.draggable = true;
    bar.ondragstart = dragWOInCapacity;

    // Add double-click handler to open WO
    bar.ondblclick = function() {
        openModule('Work Order', wo.wo_num);
    };

    // Partial week indicators
    let prefix = '';
    let suffix = '';
    if (woStart.isBefore(weekStart)) {
        prefix = ' ';
    }
    if (woEnd.isAfter(weekEnd)) {
        suffix = ' ';
    }

    // Label - show daily hours if available
    const dailyHours = wo.daily_hours || (wo.total_hours / Math.max(1, wo.date_range_days)) || 0;
    bar.innerHTML = `
        <span class="wo-bar-label">
            ${prefix}WO#${wo.wo_num} - ${dailyHours.toFixed(1)}hrs/day${suffix}
        </span>
    `;

    // Tooltip
    const totalHours = wo.total_hours || 0;
    bar.title = `WO#${wo.wo_num}\n${wo.wo_status_name}\nTotal: ${totalHours.toFixed(1)}hrs\nDaily: ${dailyHours.toFixed(1)}hrs\n${woStart.format('MMM D')} - ${woEnd.format('MMM D')}\nDouble-click to open`;

    return bar;
}

function calculateCapacityUsage() {
    if (!currentCapacityWeek) return;

    // For each category, for each day
    capacitySettings.categories.forEach(category => {
        for (let day = 0; day < 7; day++) {
            const capacity = category.limits[day];
            let usage = 0;

            // Sum all WO hours for this category on this day
            const wosOnDay = getWOsForCategoryAndDay(category.id, currentCapacityWeek, day);
            wosOnDay.forEach(woData => {
                usage += woData.hours;
            });

            // Update UI
            const usageCell = document.querySelector(
                `.usage-cell[data-category-id="${category.id}"][data-day="${day}"]`
            );

            if (usageCell) {
                const usageDisplay = usageCell.querySelector('.usage-display');
                if (usageDisplay) {
                    usageDisplay.textContent = `${usage.toFixed(1)} / ${capacity}hrs`;
                }

                // Visual feedback
                usageCell.classList.remove('bg-danger', 'bg-success', 'bg-warning');

                if (usage > capacity) {
                    usageCell.classList.add('bg-danger');
                } else if (usage > 0) {
                    usageCell.classList.add('bg-success');
                }
            }
        }
    });
}

function dragWOInCapacity(event) {
    const woBar = event.target.closest('.capacity-wo-bar');
    if (!woBar) return;

    const dragData = {
        woId: woBar.dataset.woId,
        woNum: woBar.dataset.woNum,
        categoryId: woBar.dataset.categoryId,
        startDay: parseInt(woBar.dataset.startDay),
        endDay: parseInt(woBar.dataset.endDay)
    };

    event.dataTransfer.setData('application/json', JSON.stringify(dragData));
    event.dataTransfer.effectAllowed = 'move';
}

function allowDrop(event) {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
}

function dropWOInCapacity(event) {
    event.preventDefault();
    event.stopPropagation();

    try {
        const dragData = JSON.parse(event.dataTransfer.getData('application/json'));
        const targetCell = event.target.closest('.wo-cell');

        if (!targetCell) return;

        const newDay = parseInt(targetCell.dataset.day);
        const newCategoryId = parseInt(targetCell.dataset.categoryId);

        // Calculate new dates
        const duration = dragData.endDay - dragData.startDay;
        const newStartDate = currentCapacityWeek.clone().add(newDay, 'days');
        const newEndDate = newStartDate.clone().add(duration, 'days');

        debugLog('info', `Dropping WO ${dragData.woNum} to day ${newDay}, category ${newCategoryId}`);

        // Update WO via API
        updateWODatesAndCategory(
            dragData.woNum,
            newStartDate,
            newEndDate,
            newCategoryId
        );
    } catch (error) {
        debugLog('error', 'Error dropping WO in capacity view', error.toString());
        showToast('Error moving work order: ' + error.toString(), 'error');
    }
}

function updateWODatesAndCategory(woNum, newStartDate, newEndDate, newCategoryId) {
    const woRequest = {
        GetWorkOrderRq: {
            WorkOrderNumber: woNum
        }
    };

    try {
        const woResponse = JSON.parse(runApiRequest('GetWorkOrderRq', JSON.stringify(woRequest)));

        if (woResponse.GetWorkOrderRs && woResponse.GetWorkOrderRs.statusCode === 1000 && woResponse.GetWorkOrderRs.WO) {
            const wo = woResponse.GetWorkOrderRs.WO;

            // Update dates
            wo.DateScheduledToStart = newStartDate.format('YYYY-MM-DD[T]HH:mm:ss');
            wo.DateScheduled = newEndDate.format('YYYY-MM-DD[T]HH:mm:ss');
            wo.CalCategoryID = newCategoryId;

            // Update WO items
            if (wo.WOItems && wo.WOItems.WOItem) {
                const items = Array.isArray(wo.WOItems.WOItem) ? wo.WOItems.WOItem : [wo.WOItems.WOItem];
                items.forEach(item => {
                    item.DateScheduled = newStartDate.format('YYYY-MM-DD[T]HH:mm:ss');
                });
            }

            const saveRequest = {
                SaveWorkOrderRq: {
                    WO: wo
                }
            };

            const saveResponse = JSON.parse(runApiRequest('SaveWorkOrderRq', JSON.stringify(saveRequest)));

            if (saveResponse.SaveWorkOrderRs && saveResponse.SaveWorkOrderRs.statusCode === 1000) {
                debugLog('success', `WO ${woNum} updated successfully`);
                showToast(`WO ${woNum} moved successfully`, 'success');

                // Reload data and rebuild capacity view
                loadWorkOrders();
            } else {
                throw new Error('Failed to save work order: ' + JSON.stringify(saveResponse));
            }
        } else {
            throw new Error('Failed to load work order: ' + JSON.stringify(woResponse));
        }
    } catch (error) {
        debugLog('error', 'Error updating WO', error.toString());
        showToast('Error updating work order: ' + error.toString(), 'error', true);
    }
}

function showCapacityAdjustModal(categoryId) {
    const category = capacitySettings.categories.find(c => c.id === categoryId);
    if (!category) return;

    // Create modal HTML
    const modalId = `capacity-modal-${categoryId}`;
    let modal = document.getElementById(modalId);

    if (!modal) {
        const modalHtml = `
            <div class="modal fade capacity-modal" id="${modalId}" tabindex="-1" aria-labelledby="${modalId}-label" aria-hidden="true">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title" id="${modalId}-label">
                                <i class="bi bi-gear"></i> Adjust Capacity: ${category.name}
                            </h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                            <div class="row g-3">
                                ${['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
                                    .map((day, idx) => `
                                        <div class="col-12 capacity-input-group">
                                            <label class="form-label">${day}</label>
                                            <input type="number"
                                                   class="form-control form-control-sm capacity-input"
                                                   data-day="${idx}"
                                                   value="${category.limits[idx]}"
                                                   min="0"
                                                   step="0.5">
                                        </div>
                                    `).join('')}
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-sm btn-secondary" data-bs-dismiss="modal">Cancel</button>
                            <button type="button" class="btn btn-sm btn-primary" onclick="saveCapacitySettings(${categoryId})">
                                <i class="bi bi-check-lg"></i> Save Changes
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        `;

        document.body.insertAdjacentHTML('beforeend', modalHtml);
        modal = document.getElementById(modalId);
    }

    // Show modal
    const bsModal = new bootstrap.Modal(modal);
    bsModal.show();
}

function saveCapacitySettings(categoryId) {
    const modal = document.getElementById(`capacity-modal-${categoryId}`);
    const inputs = modal.querySelectorAll('.capacity-input');

    inputs.forEach(input => {
        const day = parseInt(input.dataset.day);
        const hours = parseFloat(input.value);
        setCapacity(categoryId, day, hours);
    });

    // Close modal
    const bsModal = bootstrap.Modal.getInstance(modal);
    if (bsModal) {
        bsModal.hide();
    }

    // Refresh capacity view
    buildCapacityTable(currentCapacityWeek);

    // Show warning about session-only storage
    showToast('Capacity settings updated (session only - will reset on refresh)', 'warning');

    debugLog('info', `Saved capacity settings for category ${categoryId}`);
}

function changeCapacityWeek(direction) {
    if (!currentCapacityWeek) {
        currentCapacityWeek = moment().startOf('isoWeek');
    }

    if (direction === 'prev') {
        currentCapacityWeek = currentCapacityWeek.clone().subtract(1, 'week');
    } else {
        currentCapacityWeek = currentCapacityWeek.clone().add(1, 'week');
    }

    buildCapacityTable(currentCapacityWeek);
}

function changeCapacityDay(direction) {
    if (!currentCapacityWeek) {
        currentCapacityWeek = moment().startOf('isoWeek');
    }

    if (direction === 'prev') {
        currentCapacityWeek = currentCapacityWeek.clone().subtract(1, 'day');
    } else {
        currentCapacityWeek = currentCapacityWeek.clone().add(1, 'day');
    }

    buildCapacityTable(currentCapacityWeek);
}

// ============================================
// Filter Completed/Closed MOs
// ============================================
function filterOldFulfilledMOs() {
    const filteredOutMOs = new Set();

    // Group WOs by MO
    const wosByMO = {};
    allWorkOrders.forEach(wo => {
        if (!wosByMO[wo.mo_num]) {
            wosByMO[wo.mo_num] = [];
        }
        wosByMO[wo.mo_num].push(wo);
    });

    // Check each MO
    Object.keys(wosByMO).forEach(moNum => {
        const moInfo = manufacturingOrders.find(mo => mo.mo_num === moNum);

        if (moInfo && moInfo.mo_status) {
            // Filter out Fulfilled (60), Closed Short (70), and Void (80)
            if (moInfo.mo_status === 60 || moInfo.mo_status === 70 || moInfo.mo_status === 80) {
                filteredOutMOs.add(moNum);
                const statusName = moInfo.mo_status === 60 ? 'Fulfilled' :
                                   moInfo.mo_status === 70 ? 'Closed Short' : 'Void';
                debugLog('info', `Filtering out MO ${moNum} - status ${statusName} (${moInfo.mo_status})`);
            }
        }
    });

    // Remove filtered MOs from allWorkOrders
    allWorkOrders = allWorkOrders.filter(wo => !filteredOutMOs.has(wo.mo_num));

    debugLog('success', `Filtered out ${filteredOutMOs.size} MOs (Fulfilled/Closed Short/Void)`);
}

// ============================================
// Populate MO Filter
// ============================================
function populateMOFilter() {
    const moFilter = document.getElementById('moFilter');
    const moFilterOffcanvas = document.getElementById('moFilterOffcanvas');
    const uniqueMOs = [...new Set(allWorkOrders.map(wo => wo.mo_num))].sort();

    const allOption = '<option value="all">All MOs</option>';
    moFilter.innerHTML = allOption;
    moFilterOffcanvas.innerHTML = allOption;

    uniqueMOs.forEach(moNum => {
        const moInfo = manufacturingOrders.find(mo => mo.mo_num === moNum);
        const partNum = moInfo ? moInfo.part_num : '';
        const bomNum = moInfo ? moInfo.bom_num : '';
        const qty = moInfo ? moInfo.qty : '';

        let optionText = `MO ${moNum}`;
        if (partNum) {
            optionText += ` - ${partNum}`;
        }
        if (bomNum) {
            optionText += ` (BOM: ${bomNum})`;
        }
        if (qty) {
            optionText += ` [Qty: ${qty}]`;
        }

        const option = document.createElement('option');
        option.value = moNum;
        option.textContent = optionText;
        moFilter.appendChild(option);

        const optionOffcanvas = document.createElement('option');
        optionOffcanvas.value = moNum;
        optionOffcanvas.textContent = optionText;
        moFilterOffcanvas.appendChild(optionOffcanvas);
    });

    // Sync main filter with offcanvas
    moFilter.addEventListener('change', function() {
        moFilterOffcanvas.value = this.value;
        rebuildTimeline();
    });

    moFilterOffcanvas.addEventListener('change', function() {
        moFilter.value = this.value;
        rebuildTimeline();
    });
}

// ============================================
// Undo/Redo Functions
// ============================================

function saveStateForUndo() {
    // Create a deep copy of current state
    const state = {
        allWorkOrders: JSON.parse(JSON.stringify(allWorkOrders)),
        filteredWorkOrders: JSON.parse(JSON.stringify(filteredWorkOrders)),
        stagingDependencies: JSON.parse(JSON.stringify(stagingDependencies)),
        timestamp: Date.now()
    };

    // Add to undo stack
    undoStack.push(state);

    // Limit stack size
    if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift(); // Remove oldest
    }

    // Clear redo stack when new action is performed
    redoStack = [];

    // Update button states
    updateUndoRedoButtons();

    debugLog('info', `State saved for undo (stack size: ${undoStack.length})`);
}

function restoreState(state) {
    // Restore data arrays
    allWorkOrders = JSON.parse(JSON.stringify(state.allWorkOrders));
    filteredWorkOrders = JSON.parse(JSON.stringify(state.filteredWorkOrders));
    stagingDependencies = JSON.parse(JSON.stringify(state.stagingDependencies));

    // Rebuild timeline items with restored data
    items = buildItems();
    timeline.setItems(items);

    // Update conflicts and arrows
    updateConflictHighlighting();

    debugLog('success', 'State restored');
}

function undo() {
    if (undoStack.length === 0) {
        debugLog('warning', 'Nothing to undo');
        return;
    }

    // Save current state to redo stack first
    const currentState = {
        allWorkOrders: JSON.parse(JSON.stringify(allWorkOrders)),
        filteredWorkOrders: JSON.parse(JSON.stringify(filteredWorkOrders)),
        stagingDependencies: JSON.parse(JSON.stringify(stagingDependencies)),
        timestamp: Date.now()
    };
    redoStack.push(currentState);

    // Pop from undo stack and restore
    const previousState = undoStack.pop();
    restoreState(previousState);

    // Update button states
    updateUndoRedoButtons();

    debugLog('success', `Undo performed (undo stack: ${undoStack.length}, redo stack: ${redoStack.length})`);
}

function redo() {
    if (redoStack.length === 0) {
        debugLog('warning', 'Nothing to redo');
        return;
    }

    // Save current state to undo stack first
    const currentState = {
        allWorkOrders: JSON.parse(JSON.stringify(allWorkOrders)),
        filteredWorkOrders: JSON.parse(JSON.stringify(filteredWorkOrders)),
        stagingDependencies: JSON.parse(JSON.stringify(stagingDependencies)),
        timestamp: Date.now()
    };
    undoStack.push(currentState);

    // Pop from redo stack and restore
    const nextState = redoStack.pop();
    restoreState(nextState);

    // Update button states
    updateUndoRedoButtons();

    debugLog('success', `Redo performed (undo stack: ${undoStack.length}, redo stack: ${redoStack.length})`);
}

function updateUndoRedoButtons() {
    const undoBtn = document.getElementById('undoBtn');
    const redoBtn = document.getElementById('redoBtn');

    if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.title = undoStack.length > 0 ? `Undo (${undoStack.length} actions)` : 'Nothing to undo';
    }

    if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.title = redoStack.length > 0 ? `Redo (${redoStack.length} actions)` : 'Nothing to redo';
    }
}

// ============================================
// Helper Functions
// ============================================

function getStatusClass(wo) {
    if (wo.wo_status === 10) return 'status-entered';
    if (wo.wo_status === 30) return 'status-started';
    if (wo.wo_status === 40) return 'status-fulfilled';
    return '';
}

function getMOStatusClass(moNum) {
    const wos = allWorkOrders.filter(wo => wo.mo_num === moNum);
    const statuses = wos.map(wo => wo.wo_status);

    if (statuses.includes(30)) return 'status-started';
    if (statuses.every(s => s === 40)) return 'status-fulfilled';
    if (statuses.every(s => s === 10)) return 'status-entered';
    return '';
}

function lightenColor(hex, percent) {
    // Remove # if present
    hex = hex.replace('#', '');

    // Convert to RGB
    let r = parseInt(hex.substring(0, 2), 16);
    let g = parseInt(hex.substring(2, 4), 16);
    let b = parseInt(hex.substring(4, 6), 16);

    // Lighten
    r = Math.min(255, Math.floor(r + (255 - r) * percent));
    g = Math.min(255, Math.floor(g + (255 - g) * percent));
    b = Math.min(255, Math.floor(b + (255 - b) * percent));

    // Convert back to hex
    return '#' + [r, g, b].map(x => {
        const hex = x.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
    }).join('');
}

function skipWeekends(date) {
    const checkbox = document.getElementById('skipWeekendsOffcanvas');
    const skipWeekendsEnabled = checkbox ? checkbox.checked : false;

    if (!skipWeekendsEnabled) {
        return date;
    }

    const m = moment(date);
    const dayOfWeek = m.day();
    const originalDate = m.format('YYYY-MM-DD');

    // If Saturday (6), move to Monday (+2 days)
    if (dayOfWeek === 6) {
        const newDate = m.add(2, 'days').toDate();
        debugLog('info', `Skip weekends: ${originalDate} (Sat)  ${moment(newDate).format('YYYY-MM-DD')} (Mon)`);
        return newDate;
    }
    // If Sunday (0), move to Monday (+1 day)
    if (dayOfWeek === 0) {
        const newDate = m.add(1, 'day').toDate();
        debugLog('info', `Skip weekends: ${originalDate} (Sun)  ${moment(newDate).format('YYYY-MM-DD')} (Mon)`);
        return newDate;
    }

    return date;
}

// ============================================
// Build Groups Based on View Mode
// ============================================

function buildMOGroups() {
    const moGroups = [];
    const moNums = [...new Set(filteredWorkOrders.map(wo => wo.mo_num))].sort();

    moNums.forEach(moNum => {
        const moInfo = manufacturingOrders.find(mo => mo.mo_num === moNum);

        // Build MO label with part number, BOM number, and quantity
        const partNum = moInfo ? moInfo.part_num : '';
        const bomNum = moInfo ? moInfo.bom_num : '';
        const qty = moInfo ? moInfo.qty : '';

        let moLabel = `<strong>MO ${moNum}</strong>`;
        if (partNum) {
            moLabel += ` - ${partNum}`;
        }
        if (bomNum) {
            moLabel += ` (BOM: ${bomNum})`;
        }
        if (qty) {
            moLabel += ` [Qty: ${qty}]`;
        }

        // MO header group
        moGroups.push({
            id: `mo_${moNum}`,
            content: moLabel,
            nestedGroups: [`mo_${moNum}_wos`]
        });

        // Nested group for WOs
        moGroups.push({
            id: `mo_${moNum}_wos`,
            content: `   Work Orders`
        });
    });

    return moGroups;
}

function buildCategoryGroups() {
    // Get unique categories and count WOs in each
    const categoryMap = {};
    filteredWorkOrders.forEach(wo => {
        const category = wo.calendar_category || 'Unassigned';
        const color = wo.category_color || 'CCCCCC';

        if (!categoryMap[category]) {
            categoryMap[category] = {
                count: 0,
                color: color,
                wos: []
            };
        }
        categoryMap[category].count++;
        categoryMap[category].wos.push(wo);
    });

    // Build groups with color backgrounds
    const catGroups = [];
    Object.keys(categoryMap).sort().forEach(category => {
        const info = categoryMap[category];
        const bgColor = '#' + info.color;
        const lightBgColor = lightenColor(bgColor, 0.5); // Reduced from 0.85 - more visible colors

        catGroups.push({
            id: `cat_${category}`,
            content: `${category} (${info.count})`,
            className: 'category-label',
            // Store color in a data attribute for later application
            treeLevel: 1,
            // Store the color info so we can apply it after render
            categoryColor: lightBgColor
        });
    });

    return catGroups;
}

// ============================================
// Detect Conflicts
// ============================================

function detectConflicts() {
    const conflicts = new Set();
    const allowSameDay = document.getElementById('allowSameDayStart').classList.contains('active');

    debugLog('info', `Detecting conflicts (allowSameDay: ${allowSameDay})...`);

    filteredWorkOrders.forEach(wo => {
        // Check 1: Dependencies - WO depends on staging WO that finishes too late
        const deps = stagingDependencies.filter(d => d.wo_id === wo.wo_id);

        deps.forEach(dep => {
            // Find the staging WO to check its status
            const stagingWO = allWorkOrders.find(w => w.wo_id === dep.staging_wo_id);

            // If staging WO is Fulfilled (status 40), it's already finished - no conflict
            if (stagingWO && stagingWO.wo_status === 40) {
                debugLog('info', `No conflict: WO ${dep.staging_wo_num} is Fulfilled (actual work complete)`);
                return;
            }

            // Strip time component - compare only dates
            const stagingFinish = moment(dep.staging_wo_finish).startOf('day');
            const currentStart = moment(wo.date_scheduled_start).startOf('day');

            let isConflict = false;
            if (allowSameDay) {
                // If same-day starts allowed, only conflict if staging finishes AFTER (not on same day)
                isConflict = stagingFinish.isAfter(currentStart);
            } else {
                // If same-day starts NOT allowed, conflict if staging finishes on or after start day
                isConflict = stagingFinish.isSameOrAfter(currentStart);
            }

            if (isConflict) {
                conflicts.add(wo.wo_id);
                debugLog('warning', `CONFLICT: WO ${wo.wo_num} starts ${wo.date_scheduled_start} but depends on WO ${dep.staging_wo_num} which finishes ${dep.staging_wo_finish} (allowSameDay: ${allowSameDay})`);
            }
        });

        // Check 2: MO deadline - WO finishes after MO scheduled date
        const moInfo = manufacturingOrders.find(mo => mo.mo_num === wo.mo_num);
        if (moInfo && moInfo.mo_date_scheduled) {
            // Strip time component - compare only dates
            const woFinish = moment(wo.date_scheduled).startOf('day');
            const moScheduled = moment(moInfo.mo_date_scheduled).startOf('day');

            if (woFinish.isAfter(moScheduled)) {
                conflicts.add(wo.wo_id);
                debugLog('warning', `CONFLICT: WO ${wo.wo_num} finishes ${wo.date_scheduled} after MO ${wo.mo_num} scheduled date ${moInfo.mo_date_scheduled}`);
            }
        }
    });

    debugLog('info', `Detected ${conflicts.size} conflicts`);
    return conflicts;
}

// ============================================
// Build Items Based on View Mode
// ============================================

function buildItems() {
    const timelineItems = [];
    const conflicts = detectConflicts();

    if (viewMode === 'mo') {
        // Add MO headers
        const moNums = [...new Set(filteredWorkOrders.map(wo => wo.mo_num))].sort();

        moNums.forEach(moNum => {
            const wos = filteredWorkOrders.filter(wo => wo.mo_num === moNum);
            if (wos.length === 0) return;

            // MO start = earliest WO start date
            const starts = wos.map(wo => new Date(wo.date_scheduled_start));
            const moStart = new Date(Math.min(...starts));

            // MO end = MO scheduled date (not latest WO end date)
            // This makes it visually obvious when a WO exceeds the MO deadline
            const moInfo = manufacturingOrders.find(mo => mo.mo_num === moNum);
            const moEnd = moInfo && moInfo.mo_date_scheduled
                ? moment(moInfo.mo_date_scheduled).hour(12).minute(0).second(0).toDate()
                : new Date(Math.max(...wos.map(wo => new Date(wo.date_scheduled))));

            timelineItems.push({
                id: `mo_header_${moNum}`,
                group: `mo_${moNum}`,
                content: `MO ${moNum}`,
                start: moStart,
                end: moEnd,
                type: 'range',
                className: `mo-header ${getMOStatusClass(moNum)}`,
                title: `Manufacturing Order ${moNum}`,
                editable: false  // MO headers should NOT be draggable
            });
        });

        // Add WOs
        filteredWorkOrders.forEach(wo => {
            const hasConflict = conflicts.has(wo.wo_id);
            const className = hasConflict ? 'conflict' : getStatusClass(wo);

            // Always render at noon (12:00:00) for consistent alignment
            // Special case: same-day WOs render as 6am-6pm for draggability
            // Use explicit date parsing to avoid timezone issues
            const startMoment = moment(wo.date_scheduled_start, 'YYYY-MM-DD');
            const endMoment = moment(wo.date_scheduled, 'YYYY-MM-DD');
            const isSameDay = startMoment.isSame(endMoment, 'day');

            const startDate = isSameDay
                ? startMoment.hour(6).minute(0).second(0).toDate()
                : startMoment.hour(12).minute(0).second(0).toDate();
            const endDate = isSameDay
                ? endMoment.hour(18).minute(0).second(0).toDate()
                : endMoment.hour(12).minute(0).second(0).toDate();

            // For Fulfilled WOs with actual finish date, calculate gradient for dual shading
            let itemStyle = '';
            let statusDisplay = wo.wo_status_name;
            if (wo.wo_status === 40 && wo.date_finished) {
                const finishedMoment = moment(wo.date_finished, 'YYYY-MM-DD');
                // Format as "Fulfilled - 18 Dec"
                statusDisplay = `Fulfilled - ${finishedMoment.format('DD MMM')}`;

                // Only apply gradient if finished before scheduled end
                if (finishedMoment.isBefore(endMoment, 'day')) {
                    // Calculate percentage of completion
                    const totalDays = endMoment.diff(startMoment, 'days') + 1;
                    const actualDays = finishedMoment.diff(startMoment, 'days') + 1;
                    const percentComplete = Math.min(100, Math.max(0, (actualDays / totalDays) * 100));

                    // Create gradient: solid green up to completion point, then light green
                    // Use background-image instead of background to avoid being overridden
                    itemStyle = `background-color: #2e7d32; background-image: linear-gradient(to right, #2e7d32 0%, #2e7d32 ${percentComplete}%, rgba(46, 125, 50, 0.3) ${percentComplete}%, rgba(46, 125, 50, 0.3) 100%);`;
                }
            }

            timelineItems.push({
                id: `wo_${wo.wo_id}`,
                group: `mo_${wo.mo_num}_wos`,
                content: `WO ${wo.wo_num}`,
                start: startDate,
                end: endDate,
                type: 'range',
                className: `${className} wo-item-${wo.wo_id}`,
                style: itemStyle,
                title: `WO ${wo.wo_num}\nMO ${wo.mo_num}\nCategory: ${wo.calendar_category}\nPart: ${wo.part_num} (${wo.qty_target})\nStatus: ${statusDisplay}`,
                editable: {
                    updateTime: true,
                    updateGroup: false,
                    remove: false
                },
                woData: wo
            });
        });

    } else {
        // Category view - all WOs grouped by category
        filteredWorkOrders.forEach(wo => {
            const category = wo.calendar_category || 'Unassigned';
            const hasConflict = conflicts.has(wo.wo_id);
            const className = hasConflict ? 'conflict' : getStatusClass(wo);

            // Always render at noon (12:00:00) for consistent alignment
            // Special case: same-day WOs render as 6am-6pm for draggability
            // Use explicit date parsing to avoid timezone issues
            const startMoment = moment(wo.date_scheduled_start, 'YYYY-MM-DD');
            const endMoment = moment(wo.date_scheduled, 'YYYY-MM-DD');
            const isSameDay = startMoment.isSame(endMoment, 'day');

            const startDate = isSameDay
                ? startMoment.hour(6).minute(0).second(0).toDate()
                : startMoment.hour(12).minute(0).second(0).toDate();
            const endDate = isSameDay
                ? endMoment.hour(18).minute(0).second(0).toDate()
                : endMoment.hour(12).minute(0).second(0).toDate();

            // For Fulfilled WOs with actual finish date, calculate gradient for dual shading
            let itemStyle = '';
            let statusDisplay = wo.wo_status_name;
            if (wo.wo_status === 40 && wo.date_finished) {
                const finishedMoment = moment(wo.date_finished, 'YYYY-MM-DD');
                // Format as "Fulfilled - 18 Dec"
                statusDisplay = `Fulfilled - ${finishedMoment.format('DD MMM')}`;

                // Only apply gradient if finished before scheduled end
                if (finishedMoment.isBefore(endMoment, 'day')) {
                    // Calculate percentage of completion
                    const totalDays = endMoment.diff(startMoment, 'days') + 1;
                    const actualDays = finishedMoment.diff(startMoment, 'days') + 1;
                    const percentComplete = Math.min(100, Math.max(0, (actualDays / totalDays) * 100));

                    // Create gradient: solid green up to completion point, then light green
                    // Use background-image instead of background to avoid being overridden
                    itemStyle = `background-color: #2e7d32; background-image: linear-gradient(to right, #2e7d32 0%, #2e7d32 ${percentComplete}%, rgba(46, 125, 50, 0.3) ${percentComplete}%, rgba(46, 125, 50, 0.3) 100%);`;
                }
            }

            timelineItems.push({
                id: `wo_${wo.wo_id}`,
                group: `cat_${category}`,
                content: `WO ${wo.wo_num} (MO ${wo.mo_num})`,
                start: startDate,
                end: endDate,
                type: 'range',
                className: `${className} wo-item-${wo.wo_id}`,
                style: itemStyle,
                title: `WO ${wo.wo_num}\nMO ${wo.mo_num}\nCategory: ${category}\nPart: ${wo.part_num} (${wo.qty_target})\nStatus: ${statusDisplay}`,
                editable: {
                    updateTime: true,
                    updateGroup: false,
                    remove: false
                },
                woData: wo
            });
        });
    }

    // Add weekend background items for better visibility
    // Calculate range to cover (current view +/- some buffer)
    const today = moment();
    const rangeStart = today.clone().subtract(6, 'months').startOf('week');
    const rangeEnd = today.clone().add(6, 'months').endOf('week');

    // Iterate through each day and add background items for weekends
    let currentDay = rangeStart.clone();
    while (currentDay.isSameOrBefore(rangeEnd)) {
        const dayOfWeek = currentDay.day();

        // Saturday (6) or Sunday (0)
        if (dayOfWeek === 0 || dayOfWeek === 6) {
            timelineItems.push({
                id: `weekend_${currentDay.format('YYYY-MM-DD')}`,
                start: currentDay.clone().startOf('day').toDate(),
                end: currentDay.clone().endOf('day').toDate(),
                type: 'background',
                className: 'weekend-background',
                editable: false
            });
        }

        currentDay.add(1, 'day');
    }

    return timelineItems;
}

// ============================================
// Apply Filters
// ============================================

function applyFilters() {
    const moFilter = document.getElementById('moFilter').value;

    filteredWorkOrders = allWorkOrders.filter(wo => {
        // MO filter
        if (moFilter !== 'all' && wo.mo_num !== moFilter) {
            return false;
        }

        // Status filter
        if (activeStatusFilter !== null) {
            if (activeStatusFilter === 'conflict') {
                const conflicts = detectConflicts();
                if (!conflicts.has(wo.wo_id)) {
                    return false;
                }
            } else if (wo.wo_status !== parseInt(activeStatusFilter)) {
                return false;
            }
        }

        return true;
    });

    // Update statistics
    updateStatistics();
}

// ============================================
// Update Statistics
// ============================================

function updateStatistics() {
    const uniqueMOs = new Set(filteredWorkOrders.map(wo => wo.mo_num));
    const conflicts = detectConflicts();

    document.getElementById('totalWOs').textContent = filteredWorkOrders.length;
    document.getElementById('totalMOs').textContent = uniqueMOs.size;
    document.getElementById('totalDeps').textContent = stagingDependencies.length;
    document.getElementById('totalConflicts').textContent = conflicts.size;
}

// ============================================
// Initialize Timeline
// ============================================

function initTimeline() {
    const container = document.getElementById('visualization');

    // Apply filters
    applyFilters();

    if (filteredWorkOrders.length === 0) {
        showEmptyState(true);
        return;
    }

    showEmptyState(false);

    // Build groups and items
    groups = buildMOGroups();
    items = buildItems();

    // Timeline options
    const options = {
        // Row stacking configuration
        stack: true,
        stackSubgroups: true,

        // Editable configuration - ENABLE DRAG/RESIZE
        editable: {
            add: false,         // Don't allow adding new items
            updateTime: true,   // Allow dragging to change time (enables both move AND resize)
            updateGroup: false, // Don't allow dragging between groups (WO can't change category/MO)
            remove: false,      // Don't allow deleting
            overrideItems: true // Allow individual items to override editable settings
        },

        // Selection configuration
        selectable: true,
        multiselect: false,

        // Snap to noon (12:00:00) on day boundaries, skip weekends if enabled
        snap: function(date, scale, step) {
            const m = moment(date);
            // Round to nearest day, then set to noon
            m.startOf('day').hour(12).minute(0).second(0);
            return skipWeekends(m.toDate());
        },

        // Orientation
        orientation: 'top',

        // Zoom and move
        zoomable: true,
        moveable: true,
        zoomMin: 1000 * 60 * 60 * 24 * 7,  // 1 week minimum zoom
        zoomMax: 1000 * 60 * 60 * 24 * 180, // 6 months maximum zoom

        // Time axis format (static format - custom functions cause TypeError in vis-timeline 7.7.3)
        format: {
            minorLabels: {
                day: 'ddd D',
                weekday: 'ddd D',
                week: 'w'
            },
            majorLabels: {
                day: 'MMMM YYYY',
                week: 'MMMM YYYY',
                month: 'YYYY'
            }
        },

        // Force timeline to show individual days
        timeAxis: {
            scale: 'day',
            step: 1
        },

        // Margins
        margin: {
            item: {
                horizontal: 10,
                vertical: 5
            }
        },

        // Set initial view to show current week (with some buffer)
        start: moment().startOf('week').subtract(1, 'week').toDate(),
        end: moment().endOf('week').add(3, 'weeks').toDate(),

        // Callbacks for edits
        onMove: handleWOMove,
        onMoving: handleWOMoving,
        onUpdate: handleWOUpdate
    };

    // Destroy existing timeline if it exists (prevents duplicates on refresh)
    if (timeline) {
        timeline.destroy();
        timeline = null;
    }

    // Create timeline
    timeline = new vis.Timeline(container, items, groups, options);

    // Add today marker
    timeline.addCustomTime(new Date(), 'today');
    timeline.setCustomTimeMarker('Today', 'today', false);

    // Set initial view to start at Monday of current week, showing 4 weeks
    const monday = moment().startOf('isoWeek');
    timeline.setWindow(monday.toDate(), monday.clone().add(4, 'weeks').toDate());

    // Add double-click event to open MO screen
    timeline.on('doubleClick', function(properties) {
        if (properties.item) {
            const itemId = properties.item;

            // Check if it's a WO (not MO header)
            if (itemId.startsWith('wo_')) {
                const woId = parseInt(itemId.replace('wo_', ''));
                const wo = filteredWorkOrders.find(w => w.wo_id === woId);

                if (wo) {
                    debugLog('info', `Double-clicked WO ${wo.wo_num} - opening MO ${wo.mo_num}`);

                    try {
                        // Use the Fishbowl openModule function (same as v1)
                        openModule("Manufacture Order", wo.mo_num);
                    } catch (error) {
                        debugLog('error', 'Error opening MO', error.toString());
                        showToast('Error opening MO ' + wo.mo_num + ': ' + error.toString(), 'error', true);
                    }
                }
            } else if (itemId.startsWith('mo_header_')) {
                // Double-clicked MO header directly
                const moNum = itemId.replace('mo_header_', '');

                debugLog('info', `Double-clicked MO header ${moNum}`);

                try {
                    // Use the Fishbowl openModule function
                    openModule("Manufacture Order", moNum);
                } catch (error) {
                    debugLog('error', 'Error opening MO', error.toString());
                    showToast('Error opening MO ' + moNum + ': ' + error.toString(), 'error', true);
                }
            }
        }
    });

    // Render dependency arrows and apply colors
    setTimeout(() => {
        renderDependencyArrows();
    }, 300);

    // Apply category colors after render with longer timeout to ensure DOM is ready
    if (viewMode === 'category') {
        setTimeout(() => {
            applyCategoryColors();
        }, 800);
    }

    // Re-render arrows and colors on timeline events
    timeline.on('changed', () => {
        renderDependencyArrows();
        if (viewMode === 'category') {
            applyCategoryColors();
        }
        highlightWeekends();
    });

    // Reapply category colors after any redraw (critical for vis-timeline)
    if (viewMode === 'category') {
        timeline.on('rangechanged', applyCategoryColors);
        timeline.on('changed', applyCategoryColors);
    }

    debugLog('success', `Timeline initialized in ${viewMode} view with ${filteredWorkOrders.length} WOs`);
}

// ============================================
// Apply Category Colors to Labels and Background Rows
// ============================================
function applyCategoryColors() {
    if (viewMode !== 'category') {
        debugLog('info', 'Skipping colors - not in category view');
        return;
    }

    debugLog('info', `Applying category colors (${groups.length} groups)...`);

    setTimeout(() => {
        // vis-timeline 7.7.3 doesn't add data-groupid, so use index-based matching
        // Our category-label class helps us find the right elements
        const labels = document.querySelectorAll('.vis-label.category-label');
        const bgGroups = document.querySelectorAll('.vis-panel.vis-background .vis-group');

        debugLog('info', `Found ${labels.length} category labels, ${bgGroups.length} background groups (${groups.length} groups in data)`);

        groups.forEach((group, index) => {
            if (!group.categoryColor) return;

            const color = group.categoryColor;
            debugLog('info', `Applying ${color} to group ${index} (${group.id})`);

            // Apply to label by index (with !important to override vis styles)
            if (labels[index]) {
                labels[index].style.setProperty('background-color', color, 'important');
                const computed = window.getComputedStyle(labels[index]).backgroundColor;
                debugLog('success', `   Label: set ${color}, computed ${computed}`);
            } else {
                debugLog('warning', `   Label ${index} not found`);
            }

            // Apply to background group by index
            if (bgGroups[index]) {
                bgGroups[index].style.setProperty('background-color', color, 'important');
                const computed = window.getComputedStyle(bgGroups[index]).backgroundColor;
                debugLog('success', `   Background: set ${color}, computed ${computed}`);
            } else {
                debugLog('warning', `   Background ${index} not found`);
            }
        });

        debugLog('success', `Category colors applied to ${labels.length} labels`);
    }, 100);
}

// ============================================
// Render Dependency Arrows
// ============================================
function renderDependencyArrows() {
    debugLog('info', 'Rendering dependency arrows...');

    // Remove existing arrow SVG if it exists
    const existingSvg = document.getElementById('dependencyArrowsSvg');
    if (existingSvg) {
        existingSvg.remove();
    }

    const container = document.getElementById('visualization');
    if (!container) {
        debugLog('error', 'Container not found for dependency arrows');
        return;
    }

    // Create SVG overlay
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.id = 'dependencyArrowsSvg';
    svg.style.position = 'absolute';
    svg.style.top = '0';
    svg.style.left = '0';
    svg.style.width = '100%';
    svg.style.height = '100%';
    svg.style.pointerEvents = 'none';
    svg.style.zIndex = '1';

    container.style.position = 'relative';
    container.appendChild(svg);

    // Get timeline dimensions
    const timelineContent = container.querySelector('.vis-content');
    if (!timelineContent) return;

    const allowSameDay = document.getElementById('allowSameDayStart').classList.contains('active');

    let arrowsRendered = 0;
    let conflictArrows = 0;

    // Draw arrows for each dependency
    stagingDependencies.forEach(dep => {
        // Find the source (staging) and target (consuming) WO elements by class name
        const sourceItem = container.querySelector(`.vis-item.wo-item-${dep.staging_wo_id}`);
        const targetItem = container.querySelector(`.vis-item.wo-item-${dep.wo_id}`);

        if (!sourceItem || !targetItem) return;

        // Get positions
        const sourceRect = sourceItem.getBoundingClientRect();
        const targetRect = targetItem.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();

        // Calculate arrow start/end points (relative to container)
        const startX = sourceRect.right - containerRect.left;
        const startY = sourceRect.top + sourceRect.height / 2 - containerRect.top;
        const endX = targetRect.left - containerRect.left;
        const endY = targetRect.top + targetRect.height / 2 - containerRect.top;

        // Check if this dependency is in conflict
        // Find the staging WO to check its status
        const stagingWO = allWorkOrders.find(w => w.wo_id === dep.staging_wo_id);

        let isConflict = false;

        // If staging WO is Fulfilled (status 40), it's already finished - no conflict
        if (!(stagingWO && stagingWO.wo_status === 40)) {
            // Strip time component - compare only dates
            const stagingFinish = moment(dep.staging_wo_finish).startOf('day');
            const currentStart = moment(dep.wo_start).startOf('day');

            if (allowSameDay) {
                isConflict = stagingFinish.isAfter(currentStart);
            } else {
                isConflict = stagingFinish.isSameOrAfter(currentStart);
            }
        }

        // Draw arrow with right angles
        const color = isConflict ? '#e74c3c' : '#95a5a6';
        const strokeWidth = isConflict ? 2 : 1.5;

        // Create path with right-angle turns
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

        // Calculate right-angle path
        const horizontalOffset = 10; // Small offset from the bar
        const midX = (startX + endX) / 2;

        // Path: start  right  down/up  right  end
        let pathData;
        if (Math.abs(endY - startY) < 5) {
            // Same row or very close - simple straight line
            pathData = `M ${startX} ${startY} L ${endX} ${endY}`;
        } else {
            // Different rows - right angle path
            pathData = `M ${startX} ${startY}
                        L ${startX + horizontalOffset} ${startY}
                        L ${startX + horizontalOffset} ${endY}
                        L ${endX} ${endY}`;
        }

        path.setAttribute('d', pathData);
        path.setAttribute('stroke', color);
        path.setAttribute('stroke-width', strokeWidth);
        path.setAttribute('fill', 'none');
        path.setAttribute('class', 'dependency-arrow');
        path.setAttribute('data-source-id', dep.staging_wo_id);
        path.setAttribute('data-target-id', dep.wo_id);
        path.setAttribute('marker-end', `url(#arrowhead-${isConflict ? 'conflict' : 'normal'})`);

        svg.appendChild(path);
        arrowsRendered++;
        if (isConflict) conflictArrows++;
    });

    debugLog('info', `Rendered ${arrowsRendered} dependency arrows (${conflictArrows} conflicts)`);

    // Add arrowhead markers
    addArrowheadMarkers(svg);

    // Add hover event listeners to WO items
    addArrowHoverListeners(container);
}

function addArrowHoverListeners(container) {
    // Find all WO items
    const woItems = container.querySelectorAll('.vis-item.vis-range');

    woItems.forEach(woItem => {
        // Extract WO ID from class name (wo-item-123)
        const classMatch = woItem.className.match(/wo-item-(\d+)/);
        if (!classMatch) return;

        const woId = classMatch[1];

        // Add mouseenter event
        woItem.addEventListener('mouseenter', function() {
            // Find all arrows connected to this WO
            const arrows = container.querySelectorAll(
                `.dependency-arrow[data-source-id="${woId}"], .dependency-arrow[data-target-id="${woId}"]`
            );

            arrows.forEach(arrow => {
                arrow.classList.add('highlighted');
            });
        });

        // Add mouseleave event
        woItem.addEventListener('mouseleave', function() {
            // Remove highlight from all arrows
            const arrows = container.querySelectorAll('.dependency-arrow.highlighted');
            arrows.forEach(arrow => {
                arrow.classList.remove('highlighted');
            });
        });
    });
}

function addArrowheadMarkers(svg) {
    // Create defs element for markers
    let defs = svg.querySelector('defs');
    if (!defs) {
        defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        svg.appendChild(defs);
    }

    // Normal arrowhead (smaller)
    const markerNormal = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
    markerNormal.setAttribute('id', 'arrowhead-normal');
    markerNormal.setAttribute('markerWidth', '6');
    markerNormal.setAttribute('markerHeight', '6');
    markerNormal.setAttribute('refX', '5');
    markerNormal.setAttribute('refY', '2');
    markerNormal.setAttribute('orient', 'auto');

    const pathNormal = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    pathNormal.setAttribute('d', 'M0,0 L0,4 L5,2 z');
    pathNormal.setAttribute('fill', '#95a5a6');
    markerNormal.appendChild(pathNormal);
    defs.appendChild(markerNormal);

    // Conflict arrowhead (smaller)
    const markerConflict = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
    markerConflict.setAttribute('id', 'arrowhead-conflict');
    markerConflict.setAttribute('markerWidth', '6');
    markerConflict.setAttribute('markerHeight', '6');
    markerConflict.setAttribute('refX', '5');
    markerConflict.setAttribute('refY', '2');
    markerConflict.setAttribute('orient', 'auto');

    const pathConflict = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    pathConflict.setAttribute('d', 'M0,0 L0,4 L5,2 z');
    pathConflict.setAttribute('fill', '#e74c3c');
    markerConflict.appendChild(pathConflict);
    defs.appendChild(markerConflict);
}

// ============================================
// Handle WO Move/Resize Events
// ============================================

function handleWOMoving(item, callback) {
    // Called while dragging - allow the move
    callback(item);
}

function handleWOMove(item, callback) {
    // Prevent MO headers from being moved
    if (item.id.startsWith('mo_header_')) {
        debugLog('warning', 'Cannot move MO header - canceling move');
        callback(null); // Cancel the move
        return;
    }

    // Extract WO ID from item id (format: "wo_123")
    const woId = parseInt(item.id.replace('wo_', ''));

    debugLog('info', `WO moved: ${item.content}`, {
        woId: woId,
        newStart: moment(item.start).format('YYYY-MM-DD'),
        newEnd: moment(item.end).format('YYYY-MM-DD')
    });

    let newStartDate = moment(item.start).toDate();
    let newEndDate = moment(item.end).toDate();

    // Apply skip weekends if enabled
    newStartDate = skipWeekends(newStartDate);
    newEndDate = skipWeekends(newEndDate);

    // Format with time component for Fishbowl API (ISO 8601)
    const newStart = moment(newStartDate).format('YYYY-MM-DD[T]HH:mm:ss');
    const newEnd = moment(newEndDate).format('YYYY-MM-DD[T]HH:mm:ss');

    debugLog('info', `After skip weekends - Start: ${newStart}, End: ${newEnd}`);

    // Save state for undo BEFORE making changes
    saveStateForUndo();

    // Save old dates BEFORE updating (needed for shift calculation)
    const movedWO = filteredWorkOrders.find(wo => wo.wo_id === woId);
    const oldStart = movedWO ? movedWO.date_scheduled_start : null;
    const oldEnd = movedWO ? movedWO.date_scheduled : null;

    // Update the underlying data arrays FIRST
    const updateWODates = (wo) => {
        if (wo.wo_id === woId) {
            wo.date_scheduled_start = newStart;
            wo.date_scheduled = newEnd;
            debugLog('success', `Updated WO ${wo.wo_num} in data array`);
        }
        return wo;
    };

    allWorkOrders = allWorkOrders.map(updateWODates);
    filteredWorkOrders = filteredWorkOrders.map(updateWODates);

    // CRITICAL: Also update stagingDependencies array with new dates
    stagingDependencies = stagingDependencies.map(dep => {
        // If this WO is a staging WO (provides parts to others), update its finish date
        if (dep.staging_wo_id === woId) {
            dep.staging_wo_finish = newEnd;
            debugLog('info', `Updated staging dependency: WO ${dep.staging_wo_num} new finish: ${newEnd}`);
        }
        // If this WO consumes parts (depends on others), update its start date
        if (dep.wo_id === woId) {
            dep.wo_start = newStart;
            debugLog('info', `Updated consuming dependency: WO ${dep.wo_num} new start: ${newStart}`);
        }
        return dep;
    });

    // Update database using Fishbowl API (GetWorkOrderRq -> modify -> SaveWorkOrderRq)
    debugLog('info', `Fetching WO ${movedWO.wo_num} from API to update dates...`);

    const woRequest = {
        GetWorkOrderRq: {
            WorkOrderNumber: movedWO.wo_num
        }
    };

    try {
        const woResponse = JSON.parse(runApiRequest('GetWorkOrderRq', JSON.stringify(woRequest)));

        debugLog('info', `API Response for GetWorkOrderRq`, {
            statusCode: woResponse.GetWorkOrderRs ? woResponse.GetWorkOrderRs.statusCode : 'N/A',
            statusMessage: woResponse.GetWorkOrderRs ? woResponse.GetWorkOrderRs.statusMessage : 'N/A',
            hasWO: !!(woResponse.GetWorkOrderRs && woResponse.GetWorkOrderRs.WO)
        });

        if (woResponse.GetWorkOrderRs && woResponse.GetWorkOrderRs.statusCode === 1000 && woResponse.GetWorkOrderRs.WO) {
            const wo = woResponse.GetWorkOrderRs.WO;
            debugLog('success', `Successfully retrieved WO ${movedWO.wo_num}`);

            // Update the main WO dates
            wo.DateScheduledToStart = newStart;
            wo.DateScheduled = newEnd;

            // Also update WO items if they exist
            if (wo.WOItems && wo.WOItems.WOItem) {
                const items = Array.isArray(wo.WOItems.WOItem) ? wo.WOItems.WOItem : [wo.WOItems.WOItem];
                debugLog('info', `Updating ${items.length} WO items with new scheduled date`);
                items.forEach(item => {
                    item.DateScheduled = newStart;
                });
            }

            // Save the updated WO
            debugLog('info', `Saving updated WO ${movedWO.wo_num}...`);
            const saveRequest = {
                SaveWorkOrderRq: {
                    WO: wo
                }
            };

            const saveResponse = JSON.parse(runApiRequest('SaveWorkOrderRq', JSON.stringify(saveRequest)));

            debugLog('info', `API Response for SaveWorkOrderRq`, {
                statusCode: saveResponse.SaveWorkOrderRs ? saveResponse.SaveWorkOrderRs.statusCode : 'N/A',
                statusMessage: saveResponse.SaveWorkOrderRs ? saveResponse.SaveWorkOrderRs.statusMessage : 'N/A'
            });

            if (saveResponse.SaveWorkOrderRs && saveResponse.SaveWorkOrderRs.statusCode === 1000) {
                debugLog('success', ` Successfully updated WO ${movedWO.wo_num} via API`);
                showToast(`WO ${movedWO.wo_num} dates updated successfully`, 'success');
            } else {
                const errorMsg = saveResponse.SaveWorkOrderRs ? saveResponse.SaveWorkOrderRs.statusMessage : 'Unknown error';
                debugLog('error', ` SaveWorkOrderRq failed for WO ${movedWO.wo_num}:`, errorMsg);
                showToast(`Save failed: ${errorMsg}`, 'error', true);
            }
        } else {
            const errorMsg = woResponse.GetWorkOrderRs ? woResponse.GetWorkOrderRs.statusMessage : 'Failed to retrieve WO';
            debugLog('error', ` GetWorkOrderRq failed for WO ${movedWO.wo_num}:`, errorMsg);
            showToast(`Failed to retrieve WO: ${errorMsg}`, 'error', true);
        }
    } catch (error) {
        const errorMsg = error ? error.toString() : 'Unknown error';
        debugLog('error', ` API error updating WO ${movedWO.wo_num}:`, errorMsg);
        showToast(`API error: ${errorMsg}`, 'error', true);
    }

    // Confirm the move
    callback(item);

    // If shift deps enabled, shift dependent WOs
    if (document.getElementById('shiftDependentWOs').classList.contains('active')) {
        shiftDependentWOs(item, woId, oldStart, oldEnd);
    }

    // Just update conflicts without full rebuild
    updateConflictHighlighting();
}

function handleWOUpdate(item, callback) {
    // Handle resize/update the same way
    handleWOMove(item, callback);
}

function shiftDependentWOs(movedItem, movedWoId, oldStartDate = null, oldEndDate = null) {
    debugLog('info', `Shifting dependent WOs for WO ID ${movedWoId}...`);

    // Calculate the time delta (how much the WO was moved)
    // Use passed old dates if available, otherwise use current data
    const oldStart = oldStartDate ? moment(oldStartDate) : moment(movedItem.start);
    const newStart = moment(movedItem.start);
    const oldEnd = oldEndDate ? moment(oldEndDate) : moment(movedItem.end);
    const newEnd = moment(movedItem.end);

    const startDelta = newStart.diff(oldStart, 'days');
    const endDelta = newEnd.diff(oldEnd, 'days');

    debugLog('info', `WO moved by ${startDelta} days (start) and ${endDelta} days (end)`);

    // Find all WOs that depend on this WO (WOs where this WO is the staging WO)
    const dependentWOs = stagingDependencies
        .filter(dep => dep.staging_wo_id === movedWoId)
        .map(dep => dep.wo_id);

    if (dependentWOs.length === 0) {
        debugLog('info', 'No dependent WOs to shift');
        return;
    }

    debugLog('info', `Found ${dependentWOs.length} dependent WOs to shift`);

    // Shift each dependent WO (only if it would cause a conflict)
    const itemsToUpdate = [];
    const allowSameDay = document.getElementById('allowSameDayStart').classList.contains('active');

    dependentWOs.forEach(depWoId => {
        const depWO = filteredWorkOrders.find(wo => wo.wo_id === depWoId);
        if (!depWO) return;

        // Check if this WO would have a conflict with the moved WO
        // Strip time component - compare only dates
        const stagingFinish = moment(newEnd).startOf('day');
        const currentStart = moment(depWO.date_scheduled_start).startOf('day');

        let wouldConflict = false;
        if (allowSameDay) {
            // If same-day starts allowed, only conflict if staging finishes AFTER (not on same day)
            wouldConflict = stagingFinish.isAfter(currentStart);
        } else {
            // If same-day starts NOT allowed, conflict if staging finishes on or after start day
            wouldConflict = stagingFinish.isSameOrAfter(currentStart);
        }

        // Only shift if it would cause a conflict
        if (!wouldConflict) {
            debugLog('info', `Skipping WO ${depWO.wo_num} - no conflict (staging finishes ${stagingFinish.format('YYYY-MM-DD')}, WO starts ${currentStart.format('YYYY-MM-DD')})`);
            return;
        }

        // Save old dates for this dependent WO before shifting
        const depOldStart = depWO.date_scheduled_start;
        const depOldEnd = depWO.date_scheduled;

        // Calculate new dates and skip weekends
        let newDepStart = moment(depWO.date_scheduled_start).add(startDelta, 'days').toDate();
        newDepStart = skipWeekends(newDepStart);
        const newDepStartStr = moment(newDepStart).format('YYYY-MM-DD[T]HH:mm:ss');

        let newDepEnd = moment(depWO.date_scheduled).add(endDelta, 'days').toDate();
        newDepEnd = skipWeekends(newDepEnd);
        const newDepEndStr = moment(newDepEnd).format('YYYY-MM-DD[T]HH:mm:ss');

        debugLog('info', `Shifting WO ${depWO.wo_num}: ${depOldStart}  ${newDepStartStr} (conflict detected)`);

        // Update the data arrays
        const updateWODates = (wo) => {
            if (wo.wo_id === depWoId) {
                wo.date_scheduled_start = newDepStartStr;
                wo.date_scheduled = newDepEndStr;
            }
            return wo;
        };

        allWorkOrders = allWorkOrders.map(updateWODates);
        filteredWorkOrders = filteredWorkOrders.map(updateWODates);

        // Update staging dependencies
        stagingDependencies = stagingDependencies.map(dep => {
            if (dep.staging_wo_id === depWoId) {
                dep.staging_wo_finish = newDepEndStr;
            }
            if (dep.wo_id === depWoId) {
                dep.wo_start = newDepStartStr;
            }
            return dep;
        });

        // Find the timeline item and update it
        const timelineItem = timeline.itemsData.get(`wo_${depWoId}`);
        if (timelineItem) {
            timelineItem.start = newDepStartStr;
            timelineItem.end = newDepEndStr;
            itemsToUpdate.push(timelineItem);
        }

        // Save to database via API
        debugLog('info', `Saving shifted WO ${depWO.wo_num} to database...`);
        const woRequest = {
            GetWorkOrderRq: {
                WorkOrderNumber: depWO.wo_num
            }
        };

        try {
            const woResponse = JSON.parse(runApiRequest('GetWorkOrderRq', JSON.stringify(woRequest)));

            if (woResponse.GetWorkOrderRs && woResponse.GetWorkOrderRs.statusCode === 1000 && woResponse.GetWorkOrderRs.WO) {
                const wo = woResponse.GetWorkOrderRs.WO;

                // Update the dates
                wo.DateScheduledToStart = newDepStartStr;
                wo.DateScheduled = newDepEndStr;

                // Also update WO items if they exist
                if (wo.WOItems && wo.WOItems.WOItem) {
                    const items = Array.isArray(wo.WOItems.WOItem) ? wo.WOItems.WOItem : [wo.WOItems.WOItem];
                    items.forEach(item => {
                        item.DateScheduled = newDepStartStr;
                    });
                }

                // Save the updated WO
                const saveRequest = {
                    SaveWorkOrderRq: {
                        WO: wo
                    }
                };

                const saveResponse = JSON.parse(runApiRequest('SaveWorkOrderRq', JSON.stringify(saveRequest)));

                if (saveResponse.SaveWorkOrderRs && saveResponse.SaveWorkOrderRs.statusCode === 1000) {
                    debugLog('success', ` Shifted WO ${depWO.wo_num} saved to database`);
                } else {
                    const errorMsg = saveResponse.SaveWorkOrderRs ? saveResponse.SaveWorkOrderRs.statusMessage : 'Unknown error';
                    debugLog('error', ` Failed to save shifted WO ${depWO.wo_num}:`, errorMsg);
                }
            }
        } catch (error) {
            const errorMsg = error ? error.toString() : 'Unknown error';
            debugLog('error', ` API error saving shifted WO ${depWO.wo_num}:`, errorMsg);
        }

        // Recursively shift dependents of this WO
        shiftDependentWOs({ start: newDepStartStr, end: newDepEndStr }, depWoId, depOldStart, depOldEnd);
    });

    // Update all shifted items in the timeline at once
    if (itemsToUpdate.length > 0) {
        timeline.itemsData.update(itemsToUpdate);
        debugLog('success', `Shifted ${itemsToUpdate.length} dependent WOs in timeline`);
    }
}

function updateConflictHighlighting() {
    // Re-detect conflicts and update item classes
    const conflicts = detectConflicts();

    // Get current items
    const currentItems = timeline.itemsData.get();

    currentItems.forEach(item => {
        if (item.id.startsWith('wo_')) {
            const woId = parseInt(item.id.replace('wo_', ''));
            const hasConflict = conflicts.has(woId);

            // Update class - PRESERVE the wo-item-{wo_id} class for arrow rendering!
            if (hasConflict) {
                item.className = `conflict wo-item-${woId}`;
            } else {
                const wo = filteredWorkOrders.find(w => w.wo_id === woId);
                if (wo) {
                    item.className = `${getStatusClass(wo)} wo-item-${woId}`;
                }
            }
        }
    });

    // Update items in timeline
    timeline.itemsData.update(currentItems);

    // Update statistics
    updateStatistics();

    // Re-render dependency arrows with longer timeout to ensure DOM updates complete
    setTimeout(() => renderDependencyArrows(), 300);

    debugLog('info', `Updated conflict highlighting - ${conflicts.size} conflicts found`);
}

// ============================================
// Switch View Mode
// ============================================

function switchView(newMode) {
    if (newMode === viewMode) return;

    viewMode = newMode;

    // Update button states
    document.getElementById('moViewBtn').classList.toggle('active', viewMode === 'mo');
    document.getElementById('categoryViewBtn').classList.toggle('active', viewMode === 'category');
    document.getElementById('capacityViewBtn').classList.toggle('active', viewMode === 'capacity');

    debugLog('info', `Switched to ${viewMode} view`);

    // Show/hide appropriate containers
    if (viewMode === 'capacity') {
        // Hide timeline, show capacity view
        document.getElementById('timeline-container').style.display = 'none';
        document.getElementById('capacity-view-container').style.display = 'block';

        // Initialize capacity week if needed
        if (!currentCapacityWeek) {
            currentCapacityWeek = moment().startOf('isoWeek');
        }

        // Initialize capacity settings if needed
        if (capacitySettings.categories.length === 0) {
            initializeCapacitySettings();
        }

        // Build capacity table
        buildCapacityTable(currentCapacityWeek);
    } else {
        // Show timeline, hide capacity view
        document.getElementById('timeline-container').style.display = 'block';
        document.getElementById('capacity-view-container').style.display = 'none';

        // Rebuild timeline
        rebuildTimeline();
    }
}

// ============================================
// Rebuild Timeline (after filter/toggle)
// ============================================

function rebuildTimeline() {
    if (!timeline) return;

    // Apply filters
    applyFilters();

    if (filteredWorkOrders.length === 0) {
        showEmptyState(true);
        return;
    }

    showEmptyState(false);

    // Rebuild groups and items
    groups = viewMode === 'mo' ? buildMOGroups() : buildCategoryGroups();
    items = buildItems();

    // Update timeline
    timeline.setGroups(groups);
    timeline.setItems(items);

    // Re-render dependency arrows
    setTimeout(() => {
        renderDependencyArrows();
    }, 300);

    // Apply category colors with longer timeout
    if (viewMode === 'category') {
        setTimeout(() => {
            applyCategoryColors();
        }, 800);
    }

    // Highlight weekends
    setTimeout(() => {
        highlightWeekends();
    }, 500);

    debugLog('info', `Timeline rebuilt with ${filteredWorkOrders.length} WOs in ${viewMode} view`);
}

// ============================================
// Status Filter Toggle
// ============================================

function toggleStatusFilter(status) {
    if (activeStatusFilter === status) {
        activeStatusFilter = null;
    } else {
        activeStatusFilter = status;
    }

    // Update visual state
    document.querySelectorAll('.legend-item.clickable').forEach(item => {
        if (item.getAttribute('data-status') === activeStatusFilter) {
            item.classList.add('active');
        } else {
            item.classList.remove('active');
        }
    });

    debugLog('info', `Status filter: ${activeStatusFilter || 'none'}`);

    rebuildTimeline();
}

// ============================================
// Event Listeners
// ============================================

document.addEventListener('DOMContentLoaded', function() {
    // View toggle buttons
    document.getElementById('moViewBtn').addEventListener('click', () => switchView('mo'));
    document.getElementById('categoryViewBtn').addEventListener('click', () => switchView('category'));
    document.getElementById('capacityViewBtn').addEventListener('click', () => switchView('capacity'));

    // Capacity view navigation
    document.getElementById('capacity-prev-week').addEventListener('click', () => changeCapacityWeek('prev'));
    document.getElementById('capacity-next-week').addEventListener('click', () => changeCapacityWeek('next'));
    document.getElementById('capacity-prev-day').addEventListener('click', () => changeCapacityDay('prev'));
    document.getElementById('capacity-next-day').addEventListener('click', () => changeCapacityDay('next'));

    // Timeline controls
    document.getElementById('zoomInBtn').addEventListener('click', () => {
        if (timeline) timeline.zoomIn(0.2);
    });

    document.getElementById('zoomOutBtn').addEventListener('click', () => {
        if (timeline) timeline.zoomOut(0.2);
    });

    // Preset zoom buttons (start from current week's Monday)
    document.getElementById('zoomWeekBtn').addEventListener('click', () => {
        if (timeline) {
            const monday = moment().startOf('isoWeek');
            timeline.setWindow(monday.toDate(), monday.clone().add(1, 'week').toDate());
        }
    });

    document.getElementById('zoom2WeeksBtn').addEventListener('click', () => {
        if (timeline) {
            const monday = moment().startOf('isoWeek');
            timeline.setWindow(monday.toDate(), monday.clone().add(2, 'weeks').toDate());
        }
    });

    document.getElementById('zoomMonthBtn').addEventListener('click', () => {
        if (timeline) {
            const monday = moment().startOf('isoWeek');
            timeline.setWindow(monday.toDate(), monday.clone().add(4, 'weeks').toDate());
        }
    });

    document.getElementById('zoom3MonthsBtn').addEventListener('click', () => {
        if (timeline) {
            const monday = moment().startOf('isoWeek');
            timeline.setWindow(monday.toDate(), monday.clone().add(12, 'weeks').toDate());
        }
    });

    // Week navigation buttons (shift by 1 week, starting on Monday)
    document.getElementById('prevWeekBtn').addEventListener('click', () => {
        if (timeline) {
            const currentWindow = timeline.getWindow();
            const currentStart = moment(currentWindow.start);
            const currentEnd = moment(currentWindow.end);
            const duration = currentEnd.diff(currentStart);

            // Shift back 1 week, align to Monday
            const newStart = currentStart.subtract(1, 'week').startOf('isoWeek');
            const newEnd = newStart.clone().add(duration, 'milliseconds');

            timeline.setWindow(newStart.toDate(), newEnd.toDate());
        }
    });

    document.getElementById('nextWeekBtn').addEventListener('click', () => {
        if (timeline) {
            const currentWindow = timeline.getWindow();
            const currentStart = moment(currentWindow.start);
            const currentEnd = moment(currentWindow.end);
            const duration = currentEnd.diff(currentStart);

            // Shift forward 1 week, align to Monday
            const newStart = currentStart.add(1, 'week').startOf('isoWeek');
            const newEnd = newStart.clone().add(duration, 'milliseconds');

            timeline.setWindow(newStart.toDate(), newEnd.toDate());
        }
    });

    document.getElementById('todayBtn').addEventListener('click', () => {
        if (timeline) timeline.moveTo(new Date());
    });

    // Status filter dropdown
    document.getElementById('statusFilter').addEventListener('change', function() {
        const status = this.value;
        if (status === 'all') {
            activeStatusFilter = null;
        } else {
            activeStatusFilter = status;
        }
        debugLog('info', `Status filter: ${activeStatusFilter || 'all'}`);
        rebuildTimeline();
    });

    // Icon toggle buttons (converted from checkboxes)
    document.getElementById('shiftDependentWOs').addEventListener('click', function() {
        this.classList.toggle('active');
        const isActive = this.classList.contains('active');
        document.getElementById('shiftDependentWOsOffcanvas').checked = isActive;
        debugLog('info', `Shift dependent WOs: ${isActive}`);
    });

    document.getElementById('allowSameDayStart').addEventListener('click', function() {
        this.classList.toggle('active');
        const isActive = this.classList.contains('active');
        document.getElementById('allowSameDayStartOffcanvas').checked = isActive;
        debugLog('info', `Allow same-day start: ${isActive}`);
        rebuildTimeline();
    });

    // Sync offcanvas toggles with main toggles
    document.getElementById('shiftDependentWOsOffcanvas').addEventListener('change', function() {
        const shiftBtn = document.getElementById('shiftDependentWOs');
        if (this.checked) {
            shiftBtn.classList.add('active');
        } else {
            shiftBtn.classList.remove('active');
        }
        debugLog('info', `Shift dependent WOs: ${this.checked}`);
    });

    document.getElementById('allowSameDayStartOffcanvas').addEventListener('change', function() {
        const allowBtn = document.getElementById('allowSameDayStart');
        if (this.checked) {
            allowBtn.classList.add('active');
        } else {
            allowBtn.classList.remove('active');
        }
        debugLog('info', `Allow same-day start: ${this.checked}`);
        rebuildTimeline();
    });

    // Refresh button in offcanvas
    document.getElementById('refreshBtn').addEventListener('click', function() {
        rebuildTimeline();
        // Close offcanvas
        const offcanvas = bootstrap.Offcanvas.getInstance(document.getElementById('settingsOffcanvas'));
        if (offcanvas) offcanvas.hide();
    });

    // Undo/Redo buttons
    document.getElementById('undoBtn').addEventListener('click', undo);
    document.getElementById('redoBtn').addEventListener('click', redo);

    // Refresh data button (reloads data from database)
    document.getElementById('refreshDataBtn').addEventListener('click', function() {
        debugLog('info', 'Refreshing data from database...');
        loadWorkOrders();
    });

    // Keyboard shortcuts for undo/redo
    document.addEventListener('keydown', function(e) {
        // Ctrl+Z or Cmd+Z for undo
        if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
            e.preventDefault();
            undo();
        }
        // Ctrl+Y or Cmd+Y or Ctrl+Shift+Z for redo
        if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
            e.preventDefault();
            redo();
        }
    });

    // Load data
    debugLog('info', 'Initialization complete - loading work orders...');
    loadWorkOrders();
});

</script>
</body>
</html>
