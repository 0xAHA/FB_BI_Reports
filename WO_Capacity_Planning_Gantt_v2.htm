<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Work Order Capacity Planning - Gantt Chart v2 (vis-timeline)</title>

    <!-- vis-timeline CSS -->
    <link href="https://unpkg.com/vis-timeline@7.7.3/styles/vis-timeline-graph2d.min.css" rel="stylesheet" type="text/css" />

    <!-- Bootstrap 5.3 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Bootstrap Icons -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css" rel="stylesheet">

    <!-- Fishbowl Modern Theme -->
    <link href="fishbowl-theme-modern.css" rel="stylesheet">

    <style>
        {% Style fishbowl-theme-modern %}

        /* ============================================
           General Layout
           ============================================ */

        body {
            background-color: var(--fb-gray-50);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }

        #visualization {
            height: 600px;
            border: 1px solid #ddd;
            background-color: white;
            border-radius: 4px;
            margin-bottom: 1rem;
        }

        /* ============================================
           Status Colors (matching Fishbowl theme)
           ============================================ */

        .vis-item.status-entered {
            background-color: var(--fb-info) !important;
            border-color: var(--fb-info) !important;
            color: white !important;
        }

        .vis-item.status-started {
            background-color: var(--fb-warning) !important;
            border-color: var(--fb-warning) !important;
            color: white !important;
        }

        .vis-item.status-fulfilled {
            background-color: var(--fb-success) !important;
            border-color: var(--fb-success) !important;
            color: white !important;
        }

        .vis-item.conflict {
            background-color: var(--fb-danger) !important;
            border-color: var(--fb-danger) !important;
            color: white !important;
            box-shadow: 0 0 8px rgba(231, 76, 60, 0.5) !important;
        }

        .vis-item.mo-header {
            background-color: #34495e !important;
            border-color: #2c3e50 !important;
            color: white !important;
            font-weight: bold !important;
            opacity: 0.8;
        }

        /* MO header status colors */
        .vis-item.mo-header.status-entered {
            background-color: var(--fb-info) !important;
            opacity: 0.7;
        }

        .vis-item.mo-header.status-started {
            background-color: var(--fb-warning) !important;
            opacity: 0.7;
        }

        .vis-item.mo-header.status-fulfilled {
            background-color: var(--fb-success) !important;
            opacity: 0.7;
        }

        /* ============================================
           Category Swim Lane Styling
           ============================================ */

        .vis-label.category-label {
            font-weight: 600;
            padding: 8px !important;
            border-radius: 4px;
            color: #333 !important;
        }

        /* ============================================
           Timeline Controls
           ============================================ */

        .vis-custom-time {
            background-color: var(--fb-danger);
            width: 2px;
        }

        .view-toggle-btn {
            padding: 8px 16px;
            border: 2px solid var(--fb-primary);
            background-color: white;
            color: var(--fb-primary);
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s;
        }

        .view-toggle-btn:hover {
            background-color: var(--fb-primary-pale);
        }

        .view-toggle-btn.active {
            background-color: var(--fb-primary);
            color: white;
        }

        .info-card {
            background-color: white;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .legend-item {
            display: inline-flex;
            align-items: center;
            margin-right: 20px;
            margin-bottom: 8px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .legend-item:hover {
            background-color: var(--fb-gray-100);
        }

        .legend-item.active {
            background-color: var(--fb-primary-pale);
            border: 2px solid var(--fb-primary);
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            margin-right: 8px;
            border: 1px solid #ccc;
        }

        /* ============================================
           Debug Console
           ============================================ */

        .debug-section {
            margin-top: 2rem;
        }

        .debug-content {
            max-height: 300px;
            overflow-y: auto;
            background-color: #1e1e1e;
            color: #d4d4d4;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 10px;
        }

        .debug-entry {
            padding: 4px 0;
            border-bottom: 1px solid #333;
        }

        .debug-timestamp {
            color: #858585;
            margin-right: 8px;
        }

        .debug-type {
            font-weight: bold;
            margin-right: 8px;
        }

        .debug-type.info { color: #4fc3f7; }
        .debug-type.success { color: #66bb6a; }
        .debug-type.warning { color: #ffa726; }
        .debug-type.error { color: #ef5350; }

        .debug-data {
            margin-top: 4px;
            margin-left: 20px;
            padding: 8px;
            background-color: #2d2d2d;
            border-left: 3px solid #569cd6;
            font-size: 11px;
            overflow-x: auto;
            white-space: pre-wrap;
        }

        /* Empty state */
        .empty-state {
            text-align: center;
            padding: 3rem;
            color: var(--fb-gray-600);
        }

        .empty-state i {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        /* Loading spinner */
        .loading-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 9999;
            justify-content: center;
            align-items: center;
        }

        .loading-overlay.show {
            display: flex;
        }

        .loading-spinner {
            width: 3rem;
            height: 3rem;
        }

        /* ============================================
           vis-timeline Resize Handle Styling
           ============================================ */

        /* Ensure resize handles are visible and functional */
        .vis-item.vis-range.vis-editable {
            cursor: move;
        }

        .vis-item.vis-range.vis-editable.vis-selected {
            cursor: move;
        }

        /* Make resize handles more prominent */
        .vis-item.vis-range .vis-drag-left,
        .vis-item.vis-range .vis-drag-right {
            cursor: ew-resize !important;
            width: 24px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .vis-item.vis-range:hover .vis-drag-left,
        .vis-item.vis-range:hover .vis-drag-right,
        .vis-item.vis-range.vis-selected .vis-drag-left,
        .vis-item.vis-range.vis-selected .vis-drag-right {
            opacity: 0.3;
        }

        .vis-item.vis-range.vis-selected .vis-drag-left:hover,
        .vis-item.vis-range.vis-selected .vis-drag-right:hover {
            opacity: 0.6;
        }

        /* Make sure MO headers are NOT resizable */
        .vis-item.mo-header {
            cursor: default !important;
        }

        .vis-item.mo-header .vis-drag-left,
        .vis-item.mo-header .vis-drag-right {
            display: none !important;
        }

        /* ============================================
           Calendar Grid Styling
           ============================================ */

        /* Make day borders more visible */
        .vis-time-axis .vis-grid.vis-vertical {
            border-left: 1px solid #ddd !important;
        }

        /* Make major grid lines (week/month) more prominent */
        .vis-time-axis .vis-grid.vis-vertical.vis-major {
            border-left: 2px solid #999 !important;
        }

        /* Alternating background for better day visibility */
        .vis-background .vis-vertical {
            border-left: 1px solid #e8e8e8 !important;
        }

        .vis-background .vis-vertical.vis-major {
            border-left: 2px solid #bbb !important;
        }

        /* Today column highlight */
        .vis-time-axis .vis-grid.vis-today {
            background-color: rgba(231, 76, 60, 0.05) !important;
        }

        /* ============================================
           Dependency Arrow Styling
           ============================================ */

        /* Arrows are feint by default */
        .dependency-arrow {
            opacity: 0.5;
            transition: opacity 0.2s, stroke-width 0.2s;
        }

        /* Darken arrows on hover */
        .dependency-arrow.highlighted {
            opacity: 1;
            stroke-width: 3px !important;
            z-index: 1000;
        }

        /* ============================================
           Off-Canvas Tab Buttons (sticky tabs on sides)
           ============================================ */
        .offcanvas-tab {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            z-index: 1001;
            background-color: var(--fb-primary);
            color: white;
            border: none;
            border-radius: 8px 0 0 8px;
            padding: 40px 8px;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: -2px 2px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            letter-spacing: 2px;
        }

        .offcanvas-tab:hover {
            background-color: var(--fb-primary-dark);
            box-shadow: -4px 4px 12px rgba(0, 0, 0, 0.4);
        }

        .offcanvas-tab.tab-right {
            right: 0;
            border-radius: 8px 0 0 8px;
        }

        .offcanvas-tab.tab-right:hover {
            right: 5px;
        }

        .offcanvas-tab.tab-left {
            left: 0;
            border-radius: 0 8px 8px 0;
            box-shadow: 2px 2px 8px rgba(0, 0, 0, 0.3);
        }

        .offcanvas-tab.tab-left:hover {
            left: 5px;
            box-shadow: 4px 4px 12px rgba(0, 0, 0, 0.4);
        }

        .offcanvas-header {
            background-color: var(--fb-primary);
            color: white;
            border-bottom: 2px solid var(--fb-primary-dark);
        }

        .offcanvas-title {
            color: white;
            font-weight: 600;
        }

        .config-group {
            margin-bottom: 1.5rem;
            padding: 1rem;
            background-color: var(--fb-gray-100);
            border-radius: var(--bs-border-radius);
        }

        .config-group h5 {
            color: var(--fb-primary-dark);
            margin-bottom: 1rem;
            font-size: 1rem;
            font-weight: 600;
        }

        /* Compact view toggle buttons */
        .view-toggle-btn {
            padding: 6px 12px;
            font-size: 0.875rem;
        }

        /* Icon-only toggle buttons with ON/OFF states */
        .toggle-icon-btn {
            width: 38px;
            height: 38px;
            padding: 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border: 2px solid var(--fb-gray-400);
            background-color: white;
            color: var(--fb-gray-600);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1.1rem;
        }

        .toggle-icon-btn:hover {
            background-color: var(--fb-gray-100);
            border-color: var(--fb-gray-500);
        }

        .toggle-icon-btn.active {
            background-color: var(--fb-success);
            border-color: var(--fb-success);
            color: white;
        }

        .toggle-icon-btn.active:hover {
            background-color: var(--fb-success-dark, #1e7e34);
            border-color: var(--fb-success-dark, #1e7e34);
        }

        /* Remove red border from vis-timeline elements */
        .vis-labelset .vis-label,
        .vis-panel.vis-left,
        .vis-foreground .vis-group {
            border-color: #ddd !important;
        }

        /* Ensure dependency arrows are behind timeline labels */
        #dependencyArrowsSvg {
            z-index: 0 !important;
        }

        .vis-labelset,
        .vis-panel.vis-left {
            z-index: 5 !important;
        }

        /* Weekend highlighting */
        .vis-time-axis .vis-grid.vis-saturday,
        .vis-time-axis .vis-grid.vis-sunday,
        .vis-time-axis .vis-grid.vis-minor.weekend-column {
            background-color: #f5f5f5 !important;
        }

        .vis-panel.vis-background .vis-vertical.vis-saturday,
        .vis-panel.vis-background .vis-vertical.vis-sunday,
        .vis-panel.vis-background .vis-vertical.weekend-column {
            background-color: #f5f5f5 !important;
        }

        /* Force category colors on labels and backgrounds */
        .vis-labelset .vis-label[data-category-color] {
            background-color: var(--cat-bg-color) !important;
        }

        .vis-panel.vis-background .vis-group[data-category-color] {
            background-color: var(--cat-bg-color) !important;
        }
    </style>
</head>
<body>
    <!-- Folder Tab Buttons -->
    <button class="offcanvas-tab tab-left" type="button" data-bs-toggle="offcanvas" data-bs-target="#settingsOffcanvas" aria-controls="settingsOffcanvas">
        SETTINGS
    </button>
    <button class="offcanvas-tab tab-right" type="button" data-bs-toggle="offcanvas" data-bs-target="#instructionsOffcanvas" aria-controls="instructionsOffcanvas">
        INSTRUCTIONS
    </button>
    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay">
        <div class="spinner-border loading-spinner text-light" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container position-fixed top-0 end-0 p-3" style="z-index: 11000;">
        <!-- Toasts will be dynamically added here -->
    </div>

    <!-- Settings Offcanvas -->
    <div class="offcanvas offcanvas-start" tabindex="-1" id="settingsOffcanvas" aria-labelledby="settingsOffcanvasLabel" style="width: 400px;">
        <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="settingsOffcanvasLabel">
                <i class="bi bi-gear-fill"></i> Settings & Filters
            </h5>
            <button type="button" class="btn-close btn-close-white" data-bs-dismiss="offcanvas" aria-label="Close"></button>
        </div>
        <div class="offcanvas-body">
            <div class="config-group">
                <h5><i class="bi bi-funnel"></i> Filters</h5>

                <div class="mb-3">
                    <label for="moFilterOffcanvas" class="form-label">
                        <i class="bi bi-diagram-3"></i> Filter by MO
                    </label>
                    <select id="moFilterOffcanvas" class="form-select form-select-sm">
                        <option value="all">All MOs</option>
                    </select>
                </div>
            </div>

            <div class="config-group">
                <h5><i class="bi bi-toggles"></i> Options</h5>

                <div class="mb-3">
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" role="switch" id="allowSameDayStartOffcanvas" checked>
                        <label class="form-check-label" for="allowSameDayStartOffcanvas" style="cursor: pointer; font-size: 0.875rem;">
                            Allow same-day starts
                        </label>
                    </div>
                    <small class="text-muted">When enabled, a WO can start on the same day its dependency finishes (no conflict).</small>
                </div>

                <div class="mb-3">
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" role="switch" id="shiftDependentWOsOffcanvas">
                        <label class="form-check-label" for="shiftDependentWOsOffcanvas" style="cursor: pointer; font-size: 0.875rem;">
                            Shift dependent WOs when dragging
                        </label>
                    </div>
                    <small class="text-muted">When enabled, dragging a WO will shift all dependent WOs by the same amount.</small>
                </div>

                <div class="mb-3">
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" role="switch" id="skipWeekendsOffcanvas" checked>
                        <label class="form-check-label" for="skipWeekendsOffcanvas" style="cursor: pointer; font-size: 0.875rem;">
                            Skip weekends when scheduling
                        </label>
                    </div>
                    <small class="text-muted">When enabled, WOs cannot be scheduled on weekends (Sat/Sun). Dragging will snap to weekdays.</small>
                </div>
            </div>

            <div class="d-grid gap-2">
                <button id="refreshBtn" class="btn btn-primary btn-sm">
                    <i class="bi bi-arrow-clockwise"></i> Apply & Refresh
                </button>
            </div>
        </div>
    </div>

    <!-- Instructions Offcanvas -->
    <div class="offcanvas offcanvas-end" tabindex="-1" id="instructionsOffcanvas" aria-labelledby="instructionsOffcanvasLabel" style="width: 500px;">
        <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="instructionsOffcanvasLabel">
                <i class="bi bi-book-fill"></i> Instructions
            </h5>
            <button type="button" class="btn-close btn-close-white" data-bs-dismiss="offcanvas" aria-label="Close"></button>
        </div>
        <div class="offcanvas-body">
            <div class="config-group">
                <h5><i class="bi bi-info-circle"></i> About This Report</h5>
                <p>This interactive Gantt chart visualizes Work Orders using the vis-timeline library. Toggle between MO Gantt View (grouped by Manufacturing Order) and Category Swim Lane View (grouped by manufacturing category for capacity planning).</p>
            </div>

            <div class="config-group">
                <h5><i class="bi bi-palette"></i> Status Colors</h5>
                <div class="mb-2">
                    <span class="badge" style="background-color: var(--fb-info);">Entered</span>
                    - WO has been entered but not started
                </div>
                <div class="mb-2">
                    <span class="badge" style="background-color: var(--fb-warning);">Started</span>
                    - WO is currently in progress
                </div>
                <div class="mb-2">
                    <span class="badge" style="background-color: var(--fb-success);">Fulfilled</span>
                    - WO has been completed
                </div>
                <div class="mb-2">
                    <span class="badge" style="background-color: var(--fb-danger);">CONFLICT!</span>
                    - Scheduling conflict detected (dependency not met)
                </div>
            </div>

            <div class="config-group">
                <h5><i class="bi bi-mouse"></i> Interactions</h5>
                <ul class="small">
                    <li><strong>Drag WO:</strong> Click and drag a WO bar to reschedule it</li>
                    <li><strong>Resize WO:</strong> Drag the left or right edge to adjust start/finish dates</li>
                    <li><strong>Double-click WO:</strong> Opens the Manufacturing Order in Fishbowl</li>
                    <li><strong>Hover over WO:</strong> See dependency arrows highlighted</li>
                    <li><strong>Drag timeline:</strong> Hold Ctrl/Cmd and drag, or use scroll wheel</li>
                    <li><strong>Zoom:</strong> Pinch gesture or Ctrl+scroll, or use zoom buttons</li>
                </ul>
            </div>

            <div class="config-group">
                <h5><i class="bi bi-diagram-3"></i> Dependencies & Conflicts</h5>
                <p><strong>Dependency Arrows:</strong> Gray arrows show which WOs provide parts/materials to other WOs (within the same MO only). Red arrows indicate conflicts.</p>
                <p><strong>Conflict Detection:</strong> A WO turns <span style="color: var(--fb-danger); font-weight: bold;">RED</span> when a dependent WO's scheduled finish date is AFTER (or same day if "Allow same-day starts" is disabled) the current WO's start date.</p>
                <p class="small"><em>Example: If WO-002 needs parts from WO-001, but WO-001 finishes on Dec 15 and WO-002 starts on Dec 10, WO-002 will be RED.</em></p>
            </div>

            <div class="config-group">
                <h5><i class="bi bi-layout-three-columns"></i> View Modes</h5>
                <p><strong>MO Gantt View:</strong> Groups WOs by Manufacturing Order. Best for tracking individual order progress and dependencies.</p>
                <p><strong>Category Swim Lane View:</strong> Groups WOs by manufacturing category (Fabrication, Powdercoating, etc.). Best for capacity planning and resource utilization across categories.</p>
            </div>

            <div class="config-group">
                <h5><i class="bi bi-calendar3"></i> Category Colors</h5>
                <p>In Category Swim Lane View, each category swim lane is colored according to the Calendar Category defined in Fishbowl. This helps quickly identify different manufacturing processes.</p>
            </div>
        </div>
    </div>

    <div class="container-fluid p-4">
        <!-- Header -->
        <div class="row mb-3">
            <div class="col">
                <h2>
                    <i class="bi bi-diagram-3"></i>
                    Work Order Capacity Planning - Gantt Chart
                </h2>
                <p class="text-muted">Toggle between MO Gantt View and Category Swim Lane View</p>
            </div>
        </div>

        <!-- Compact Controls -->
        <div class="info-card">
            <div class="row align-items-center g-2">
                <div class="col-auto">
                    <div class="btn-group btn-group-sm" role="group">
                        <button id="moViewBtn" class="view-toggle-btn active">
                            <i class="bi bi-list-nested"></i> MO Gantt
                        </button>
                        <button id="categoryViewBtn" class="view-toggle-btn">
                            <i class="bi bi-layout-three-columns"></i> Category
                        </button>
                    </div>
                </div>
                <div class="col-auto">
                    <label class="form-label small mb-1">Filter by MO</label>
                    <select class="form-select form-select-sm" id="moFilter" style="min-width: 200px;">
                        <option value="all">All MOs</option>
                    </select>
                </div>
                <div class="col-auto">
                    <label class="form-label small mb-1">Filter by Status</label>
                    <div class="d-flex gap-2">
                        <div class="legend-item clickable" data-status="10" title="Filter by Entered">
                            <div class="legend-color" style="background-color: var(--fb-info);"></div>
                        </div>
                        <div class="legend-item clickable" data-status="30" title="Filter by Started">
                            <div class="legend-color" style="background-color: var(--fb-warning);"></div>
                        </div>
                        <div class="legend-item clickable" data-status="40" title="Filter by Fulfilled">
                            <div class="legend-color" style="background-color: var(--fb-success);"></div>
                        </div>
                        <div class="legend-item clickable" data-status="conflict" title="Filter by Conflicts">
                            <div class="legend-color" style="background-color: var(--fb-danger);"></div>
                        </div>
                    </div>
                </div>
                <div class="col-auto ms-auto">
                    <label class="form-label small mb-1">Timeline</label>
                    <div class="d-flex gap-2 align-items-center">
                        <div class="btn-group btn-group-sm" role="group">
                            <button id="undoBtn" class="btn btn-outline-secondary" title="Undo" disabled>
                                <i class="bi bi-arrow-counterclockwise"></i>
                            </button>
                            <button id="redoBtn" class="btn btn-outline-secondary" title="Redo" disabled>
                                <i class="bi bi-arrow-clockwise"></i>
                            </button>
                        </div>
                        <div class="btn-group btn-group-sm" role="group">
                            <button id="zoomInBtn" class="btn btn-outline-secondary" title="Zoom In">
                                <i class="bi bi-zoom-in"></i>
                            </button>
                            <button id="zoomOutBtn" class="btn btn-outline-secondary" title="Zoom Out">
                                <i class="bi bi-zoom-out"></i>
                            </button>
                            <button id="fitBtn" class="btn btn-outline-secondary" title="Fit All">
                                <i class="bi bi-arrows-angle-contract"></i>
                            </button>
                            <button id="todayBtn" class="btn btn-outline-primary">
                                <i class="bi bi-calendar-day"></i> Today
                            </button>
                        </div>
                        <button id="shiftDependentWOs" class="toggle-icon-btn" title="Shift dependent WOs when dragging">
                            <i class="bi bi-arrow-repeat"></i>
                        </button>
                        <button id="allowSameDayStart" class="toggle-icon-btn active" title="Allow same-day starts (dependencies can finish on the same day WO starts)">
                            <i class="bi bi-calendar-check"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Timeline Container -->
        <div id="visualization"></div>
        <div id="emptyState" class="empty-state" style="display: none;">
            <i class="bi bi-inbox"></i>
            <h3>No Work Orders Found</h3>
            <p>Try adjusting your filters or date range</p>
        </div>

        <!-- Info Panel -->
        <div class="info-card">
            <div class="row">
                <div class="col-md-6">
                    <h6>Interaction Guide</h6>
                    <ul class="small mb-0">
                        <li><strong>Drag WO:</strong> Click and drag to reschedule</li>
                        <li><strong>Resize WO:</strong> Drag left/right edge to adjust start/finish dates</li>
                        <li><strong>Drag Timeline:</strong> Hold Ctrl/Cmd and drag, or use scroll wheel</li>
                        <li><strong>Zoom:</strong> Pinch or Ctrl+scroll, or use zoom buttons</li>
                    </ul>
                </div>
                <div class="col-md-6" id="statsPanel">
                    <h6>Statistics</h6>
                    <p class="small mb-1"><strong>Total WOs:</strong> <span id="totalWOs">0</span></p>
                    <p class="small mb-1"><strong>Total MOs:</strong> <span id="totalMOs">0</span></p>
                    <p class="small mb-1"><strong>Dependencies:</strong> <span id="totalDeps">0</span></p>
                    <p class="small mb-0"><strong>Conflicts:</strong> <span id="totalConflicts">0</span></p>
                </div>
            </div>
        </div>

        <!-- Debug Console -->
        <div class="debug-section">
            <div class="accordion" id="debugAccordion">
                <div class="accordion-item">
                    <h2 class="accordion-header">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#debugContent">
                            <i class="bi bi-bug-fill me-2"></i> Debug Console
                        </button>
                    </h2>
                    <div id="debugContent" class="accordion-collapse collapse">
                        <div class="accordion-body p-0">
                            <div class="p-2 bg-dark text-white d-flex justify-content-between align-items-center">
                                <small>Debug log - Auto-scrolls to latest entry</small>
                                <button class="btn btn-sm btn-outline-light" onclick="clearDebugLog()">
                                    <i class="bi bi-trash"></i> Clear
                                </button>
                            </div>
                            <div class="debug-content" id="debugLog">
                                <div class="debug-entry">
                                    <span class="debug-timestamp">[00:00:00]</span>
                                    <span class="debug-type info">[INFO]</span>
                                    <span class="debug-message">Debug console initialized</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Moment.js for date handling -->
    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.4/moment.min.js"></script>

    <!-- vis-timeline JS -->
    <script src="https://unpkg.com/vis-timeline@7.7.3/standalone/umd/vis-timeline-graph2d.min.js"></script>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

<script>
{% Script Util %}

// ============================================
// Global Variables
// ============================================
let timeline = null;
let viewMode = 'mo'; // 'mo' or 'category'
let allWorkOrders = [];
let filteredWorkOrders = [];
let stagingDependencies = [];
let manufacturingOrders = [];
let activeStatusFilter = null;
let groups = [];
let items = [];

// Undo/Redo stacks
let undoStack = [];
let redoStack = [];
const MAX_UNDO_STACK = 50; // Limit stack size to prevent memory issues

// ============================================
// Debug Logging Functions
// ============================================
function debugLog(type, message, data = null) {
    const timestamp = new Date().toLocaleTimeString();
    const logEntry = document.createElement('div');
    logEntry.className = 'debug-entry';

    let html = `
        <span class="debug-timestamp">[${timestamp}]</span>
        <span class="debug-type ${type}">[${type.toUpperCase()}]</span>
        <span class="debug-message">${message}</span>
    `;

    if (data) {
        const dataStr = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
        html += `<div class="debug-data">${dataStr}</div>`;
    }

    logEntry.innerHTML = html;

    const debugLogEl = document.getElementById('debugLog');
    if (debugLogEl) {
        debugLogEl.appendChild(logEntry);
        debugLogEl.scrollTop = debugLogEl.scrollHeight;
    }

    console.log(`[${type.toUpperCase()}] ${message}`, data);
}

function clearDebugLog() {
    const debugLogEl = document.getElementById('debugLog');
    if (debugLogEl) {
        debugLogEl.innerHTML = `
            <div class="debug-entry">
                <span class="debug-timestamp">[${new Date().toLocaleTimeString()}]</span>
                <span class="debug-type info">[INFO]</span>
                <span class="debug-message">Debug log cleared</span>
            </div>
        `;
    }
}

// ============================================
// Loading Indicator
// ============================================
function showLoading(show) {
    const overlay = document.getElementById('loadingOverlay');
    if (show) {
        overlay.classList.add('show');
    } else {
        overlay.classList.remove('show');
    }
}

function showEmptyState(show) {
    document.getElementById('emptyState').style.display = show ? 'block' : 'none';
    document.getElementById('visualization').style.display = show ? 'none' : 'block';
}

// ============================================
// Toast Notifications
// ============================================
function showToast(message, type = 'info', sticky = false) {
    debugLog(type, message);

    const toastContainer = document.querySelector('.toast-container');
    if (!toastContainer) {
        console.error('Toast container not found');
        return;
    }

    // Create unique ID for this toast
    const toastId = 'toast_' + Date.now();

    // Determine icon and colors based on type
    let icon, bgClass, headerText;
    switch (type) {
        case 'success':
            icon = 'bi-check-circle-fill';
            bgClass = 'bg-success';
            headerText = 'Success';
            break;
        case 'error':
            icon = 'bi-exclamation-triangle-fill';
            bgClass = 'bg-danger';
            headerText = 'Error';
            break;
        case 'warning':
            icon = 'bi-exclamation-circle-fill';
            bgClass = 'bg-warning';
            headerText = 'Warning';
            break;
        default:
            icon = 'bi-info-circle-fill';
            bgClass = 'bg-info';
            headerText = 'Info';
    }

    // Create toast element
    const toastEl = document.createElement('div');
    toastEl.id = toastId;
    toastEl.className = 'toast';
    toastEl.setAttribute('role', 'alert');
    toastEl.setAttribute('aria-live', 'assertive');
    toastEl.setAttribute('aria-atomic', 'true');

    // Set autohide based on sticky parameter (errors are persistent)
    if (sticky || type === 'error') {
        toastEl.setAttribute('data-bs-autohide', 'false');
    } else {
        toastEl.setAttribute('data-bs-autohide', 'true');
        toastEl.setAttribute('data-bs-delay', '5000');
    }

    toastEl.innerHTML = `
        <div class="toast-header ${bgClass} text-white">
            <i class="bi ${icon} me-2"></i>
            <strong class="me-auto">${headerText}</strong>
            <small>just now</small>
            <button type="button" class="btn-close btn-close-white" data-bs-dismiss="toast" aria-label="Close"></button>
        </div>
        <div class="toast-body">
            ${message}
        </div>
    `;

    // Add to container
    toastContainer.appendChild(toastEl);

    // Initialize and show toast
    const toast = new bootstrap.Toast(toastEl);
    toast.show();

    // Remove from DOM after hidden (if not sticky)
    if (!sticky && type !== 'error') {
        toastEl.addEventListener('hidden.bs.toast', function() {
            toastEl.remove();
        });
    }
}

// ============================================
// Load Work Orders from Database
// ============================================
function loadWorkOrders() {
    showLoading(true);

    const woQuery = `
        SELECT
            mo.num AS mo_num,
            mo.id AS mo_id,
            wo.id AS wo_id,
            wo.num AS wo_num,
            wo.statusid AS wo_status,
            CASE wo.statusid
                WHEN 10 THEN 'Entered'
                WHEN 30 THEN 'Started'
                WHEN 40 THEN 'Fulfilled'
                ELSE 'Unknown'
            END AS wo_status_name,
            moitem.description AS description,
            COALESCE(bom.estimatedDuration, 0) * COALESCE(wo.qtyTarget, 0) AS estimated_duration,
            COALESCE(wo.datescheduled, moitem.datescheduled) AS date_scheduled,
            COALESCE(wo.datescheduledtostart, moitem.datescheduledtostart) AS date_scheduled_start,
            COALESCE(calcat.name, '') AS calendar_category,
            COALESCE(calcat.color, 'CCCCCC') AS category_color,
            wo.qtyTarget AS qty_target,
            (SELECT part.num FROM woitem
             LEFT JOIN part ON woitem.partid = part.id
             WHERE woitem.woid = wo.id AND woitem.typeid = 10
             LIMIT 1) AS part_num
        FROM wo
        LEFT JOIN moitem ON wo.moitemid = moitem.id
        LEFT JOIN mo ON moitem.moid = mo.id
        LEFT JOIN bom ON moitem.bomid = bom.id
        LEFT JOIN calcategory AS calcat ON wo.calcategoryid = calcat.id
        WHERE wo.num IS NOT NULL
            AND wo.statusid IN (10, 30, 40)
            AND moitem.typeid = 50
        ORDER BY mo.num, wo.num
    `;

    const depQuery = `
        SELECT DISTINCT
            wo.id AS wo_id,
            wo.num AS wo_num,
            staging_wo.id AS staging_wo_id,
            staging_wo.num AS staging_wo_num,
            COALESCE(staging_wo.datescheduled, staging_moitem.datescheduled) AS staging_wo_finish,
            COALESCE(wo.datescheduledtostart, current_moitem.datescheduledtostart) AS wo_start,
            part.num AS part_num
        FROM wo
        LEFT JOIN moitem AS current_moitem ON wo.moitemid = current_moitem.id
        LEFT JOIN mo AS current_mo ON current_moitem.moid = current_mo.id
        LEFT JOIN woitem ON woitem.woid = wo.id AND woitem.typeid = 20
        LEFT JOIN part ON woitem.partid = part.id
        LEFT JOIN woitem AS staging_woitem ON staging_woitem.partid = part.id AND staging_woitem.typeid = 10
        LEFT JOIN wo AS staging_wo ON staging_woitem.woid = staging_wo.id
        LEFT JOIN moitem AS staging_moitem ON staging_wo.moitemid = staging_moitem.id
        LEFT JOIN mo AS staging_mo ON staging_moitem.moid = staging_mo.id
        WHERE wo.num IS NOT NULL
            AND wo.statusid IN (10, 30, 40)
            AND staging_wo.num IS NOT NULL
            AND staging_wo.id != wo.id
            AND current_mo.id = staging_mo.id
    `;

    const moQuery = `
        SELECT DISTINCT
            mo.num AS mo_num,
            mo.id AS mo_id,
            mo.statusid AS mo_status,
            part.num AS part_num,
            moitem.description AS description,
            moitem.qtytofulfill AS qty,
            bom.num AS bom_num
        FROM mo
        LEFT JOIN moitem ON moitem.moid = mo.id
        LEFT JOIN part ON moitem.partid = part.id
        LEFT JOIN bom ON moitem.bomid = bom.id
        WHERE moitem.typeid = 50
            AND moitem.parentid IS NULL
            AND mo.id IN (
                SELECT DISTINCT mo.id
                FROM wo
                LEFT JOIN moitem ON wo.moitemid = moitem.id
                LEFT JOIN mo ON moitem.moid = mo.id
                WHERE wo.num IS NOT NULL AND wo.statusid IN (10, 30, 40)
            )
        ORDER BY mo.num
    `;

    try {
        debugLog('info', 'Starting to load work orders...');

        // Load WOs
        const woResults = JSON.parse(runQuery(woQuery));
        allWorkOrders = woResults;
        debugLog('success', `Loaded ${allWorkOrders.length} work orders`);

        // Load staging dependencies
        const depResults = JSON.parse(runQuery(depQuery));
        stagingDependencies = depResults;
        debugLog('success', `Loaded ${stagingDependencies.length} staging dependencies`);

        // Load MO finished goods
        const moResults = JSON.parse(runQuery(moQuery));
        manufacturingOrders = moResults;
        debugLog('success', `Loaded ${manufacturingOrders.length} MO finished goods`);

        // Filter old fulfilled MOs
        filterOldFulfilledMOs();

        // Populate MO filter
        populateMOFilter();

        // Initialize timeline
        initTimeline();

        showLoading(false);
    } catch (error) {
        debugLog('error', 'Error loading work orders', error.toString());
        showToast('Error loading work orders: ' + error.toString(), 'error', true);
        showLoading(false);
        showEmptyState(true);
    }
}

// ============================================
// Filter Completed/Closed MOs
// ============================================
function filterOldFulfilledMOs() {
    const filteredOutMOs = new Set();

    // Group WOs by MO
    const wosByMO = {};
    allWorkOrders.forEach(wo => {
        if (!wosByMO[wo.mo_num]) {
            wosByMO[wo.mo_num] = [];
        }
        wosByMO[wo.mo_num].push(wo);
    });

    // Check each MO
    Object.keys(wosByMO).forEach(moNum => {
        const moInfo = manufacturingOrders.find(mo => mo.mo_num === moNum);

        if (moInfo && moInfo.mo_status) {
            // Filter out Fulfilled (60), Closed Short (70), and Void (80)
            if (moInfo.mo_status === 60 || moInfo.mo_status === 70 || moInfo.mo_status === 80) {
                filteredOutMOs.add(moNum);
                const statusName = moInfo.mo_status === 60 ? 'Fulfilled' :
                                   moInfo.mo_status === 70 ? 'Closed Short' : 'Void';
                debugLog('info', `Filtering out MO ${moNum} - status ${statusName} (${moInfo.mo_status})`);
            }
        }
    });

    // Remove filtered MOs from allWorkOrders
    allWorkOrders = allWorkOrders.filter(wo => !filteredOutMOs.has(wo.mo_num));

    debugLog('success', `Filtered out ${filteredOutMOs.size} MOs (Fulfilled/Closed Short/Void)`);
}

// ============================================
// Populate MO Filter
// ============================================
function populateMOFilter() {
    const moFilter = document.getElementById('moFilter');
    const moFilterOffcanvas = document.getElementById('moFilterOffcanvas');
    const uniqueMOs = [...new Set(allWorkOrders.map(wo => wo.mo_num))].sort();

    const allOption = '<option value="all">All MOs</option>';
    moFilter.innerHTML = allOption;
    moFilterOffcanvas.innerHTML = allOption;

    uniqueMOs.forEach(moNum => {
        const moInfo = manufacturingOrders.find(mo => mo.mo_num === moNum);
        const partNum = moInfo ? moInfo.part_num : '';
        const bomNum = moInfo ? moInfo.bom_num : '';
        const qty = moInfo ? moInfo.qty : '';

        let optionText = `MO ${moNum}`;
        if (partNum) {
            optionText += ` - ${partNum}`;
        }
        if (bomNum) {
            optionText += ` (BOM: ${bomNum})`;
        }
        if (qty) {
            optionText += ` [Qty: ${qty}]`;
        }

        const option = document.createElement('option');
        option.value = moNum;
        option.textContent = optionText;
        moFilter.appendChild(option);

        const optionOffcanvas = document.createElement('option');
        optionOffcanvas.value = moNum;
        optionOffcanvas.textContent = optionText;
        moFilterOffcanvas.appendChild(optionOffcanvas);
    });

    // Sync main filter with offcanvas
    moFilter.addEventListener('change', function() {
        moFilterOffcanvas.value = this.value;
        rebuildTimeline();
    });

    moFilterOffcanvas.addEventListener('change', function() {
        moFilter.value = this.value;
        rebuildTimeline();
    });
}

// ============================================
// Undo/Redo Functions
// ============================================

function saveStateForUndo() {
    // Create a deep copy of current state
    const state = {
        allWorkOrders: JSON.parse(JSON.stringify(allWorkOrders)),
        filteredWorkOrders: JSON.parse(JSON.stringify(filteredWorkOrders)),
        stagingDependencies: JSON.parse(JSON.stringify(stagingDependencies)),
        timestamp: Date.now()
    };

    // Add to undo stack
    undoStack.push(state);

    // Limit stack size
    if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift(); // Remove oldest
    }

    // Clear redo stack when new action is performed
    redoStack = [];

    // Update button states
    updateUndoRedoButtons();

    debugLog('info', `State saved for undo (stack size: ${undoStack.length})`);
}

function restoreState(state) {
    // Restore data arrays
    allWorkOrders = JSON.parse(JSON.stringify(state.allWorkOrders));
    filteredWorkOrders = JSON.parse(JSON.stringify(state.filteredWorkOrders));
    stagingDependencies = JSON.parse(JSON.stringify(state.stagingDependencies));

    // Rebuild timeline items with restored data
    items = buildItems();
    timeline.setItems(items);

    // Update conflicts and arrows
    updateConflictHighlighting();

    debugLog('success', 'State restored');
}

function undo() {
    if (undoStack.length === 0) {
        debugLog('warning', 'Nothing to undo');
        return;
    }

    // Save current state to redo stack first
    const currentState = {
        allWorkOrders: JSON.parse(JSON.stringify(allWorkOrders)),
        filteredWorkOrders: JSON.parse(JSON.stringify(filteredWorkOrders)),
        stagingDependencies: JSON.parse(JSON.stringify(stagingDependencies)),
        timestamp: Date.now()
    };
    redoStack.push(currentState);

    // Pop from undo stack and restore
    const previousState = undoStack.pop();
    restoreState(previousState);

    // Update button states
    updateUndoRedoButtons();

    debugLog('success', `Undo performed (undo stack: ${undoStack.length}, redo stack: ${redoStack.length})`);
}

function redo() {
    if (redoStack.length === 0) {
        debugLog('warning', 'Nothing to redo');
        return;
    }

    // Save current state to undo stack first
    const currentState = {
        allWorkOrders: JSON.parse(JSON.stringify(allWorkOrders)),
        filteredWorkOrders: JSON.parse(JSON.stringify(filteredWorkOrders)),
        stagingDependencies: JSON.parse(JSON.stringify(stagingDependencies)),
        timestamp: Date.now()
    };
    undoStack.push(currentState);

    // Pop from redo stack and restore
    const nextState = redoStack.pop();
    restoreState(nextState);

    // Update button states
    updateUndoRedoButtons();

    debugLog('success', `Redo performed (undo stack: ${undoStack.length}, redo stack: ${redoStack.length})`);
}

function updateUndoRedoButtons() {
    const undoBtn = document.getElementById('undoBtn');
    const redoBtn = document.getElementById('redoBtn');

    if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.title = undoStack.length > 0 ? `Undo (${undoStack.length} actions)` : 'Nothing to undo';
    }

    if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.title = redoStack.length > 0 ? `Redo (${redoStack.length} actions)` : 'Nothing to redo';
    }
}

// ============================================
// Helper Functions
// ============================================

function getStatusClass(wo) {
    if (wo.wo_status === 10) return 'status-entered';
    if (wo.wo_status === 30) return 'status-started';
    if (wo.wo_status === 40) return 'status-fulfilled';
    return '';
}

function getMOStatusClass(moNum) {
    const wos = allWorkOrders.filter(wo => wo.mo_num === moNum);
    const statuses = wos.map(wo => wo.wo_status);

    if (statuses.includes(30)) return 'status-started';
    if (statuses.every(s => s === 40)) return 'status-fulfilled';
    if (statuses.every(s => s === 10)) return 'status-entered';
    return '';
}

function lightenColor(hex, percent) {
    // Remove # if present
    hex = hex.replace('#', '');

    // Convert to RGB
    let r = parseInt(hex.substring(0, 2), 16);
    let g = parseInt(hex.substring(2, 4), 16);
    let b = parseInt(hex.substring(4, 6), 16);

    // Lighten
    r = Math.min(255, Math.floor(r + (255 - r) * percent));
    g = Math.min(255, Math.floor(g + (255 - g) * percent));
    b = Math.min(255, Math.floor(b + (255 - b) * percent));

    // Convert back to hex
    return '#' + [r, g, b].map(x => {
        const hex = x.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
    }).join('');
}

function skipWeekends(date) {
    const skipWeekendsEnabled = document.getElementById('skipWeekendsOffcanvas').checked;
    if (!skipWeekendsEnabled) return date;

    const m = moment(date);
    const dayOfWeek = m.day();

    // If Saturday (6), move to Monday (+2 days)
    if (dayOfWeek === 6) {
        return m.add(2, 'days').toDate();
    }
    // If Sunday (0), move to Monday (+1 day)
    if (dayOfWeek === 0) {
        return m.add(1, 'day').toDate();
    }

    return date;
}

// ============================================
// Build Groups Based on View Mode
// ============================================

function buildMOGroups() {
    const moGroups = [];
    const moNums = [...new Set(filteredWorkOrders.map(wo => wo.mo_num))].sort();

    moNums.forEach(moNum => {
        const moInfo = manufacturingOrders.find(mo => mo.mo_num === moNum);

        // Build MO label with part number, BOM number, and quantity
        const partNum = moInfo ? moInfo.part_num : '';
        const bomNum = moInfo ? moInfo.bom_num : '';
        const qty = moInfo ? moInfo.qty : '';

        let moLabel = `<strong>MO ${moNum}</strong>`;
        if (partNum) {
            moLabel += ` - ${partNum}`;
        }
        if (bomNum) {
            moLabel += ` (BOM: ${bomNum})`;
        }
        if (qty) {
            moLabel += ` [Qty: ${qty}]`;
        }

        // MO header group
        moGroups.push({
            id: `mo_${moNum}`,
            content: moLabel,
            nestedGroups: [`mo_${moNum}_wos`]
        });

        // Nested group for WOs
        moGroups.push({
            id: `mo_${moNum}_wos`,
            content: `   Work Orders`
        });
    });

    return moGroups;
}

function buildCategoryGroups() {
    // Get unique categories and count WOs in each
    const categoryMap = {};
    filteredWorkOrders.forEach(wo => {
        const category = wo.calendar_category || 'Unassigned';
        const color = wo.category_color || 'CCCCCC';

        if (!categoryMap[category]) {
            categoryMap[category] = {
                count: 0,
                color: color,
                wos: []
            };
        }
        categoryMap[category].count++;
        categoryMap[category].wos.push(wo);
    });

    // Build groups with color backgrounds
    const catGroups = [];
    Object.keys(categoryMap).sort().forEach(category => {
        const info = categoryMap[category];
        const bgColor = '#' + info.color;
        const lightBgColor = lightenColor(bgColor, 0.85);

        catGroups.push({
            id: `cat_${category}`,
            content: `${category} (${info.count})`,
            className: 'category-label',
            // Store color in a data attribute for later application
            treeLevel: 1,
            // Store the color info so we can apply it after render
            categoryColor: lightBgColor
        });
    });

    return catGroups;
}

// ============================================
// Detect Conflicts
// ============================================

function detectConflicts() {
    const conflicts = new Set();
    const allowSameDay = document.getElementById('allowSameDayStart').classList.contains('active');

    debugLog('info', `Detecting conflicts (allowSameDay: ${allowSameDay})...`);

    filteredWorkOrders.forEach(wo => {
        // Find dependencies for this WO
        const deps = stagingDependencies.filter(d => d.wo_id === wo.wo_id);

        deps.forEach(dep => {
            const stagingFinish = moment(dep.staging_wo_finish);
            const currentStart = moment(wo.date_scheduled_start);

            let isConflict = false;
            if (allowSameDay) {
                isConflict = stagingFinish.isAfter(currentStart, 'day');
            } else {
                isConflict = stagingFinish.isSameOrAfter(currentStart, 'day');
            }

            if (isConflict) {
                conflicts.add(wo.wo_id);
                debugLog('warning', `CONFLICT: WO ${wo.wo_num} starts ${wo.date_scheduled_start} but depends on WO ${dep.staging_wo_num} which finishes ${dep.staging_wo_finish}`);
            }
        });
    });

    debugLog('info', `Detected ${conflicts.size} conflicts`);
    return conflicts;
}

// ============================================
// Build Items Based on View Mode
// ============================================

function buildItems() {
    const timelineItems = [];
    const conflicts = detectConflicts();

    if (viewMode === 'mo') {
        // Add MO headers
        const moNums = [...new Set(filteredWorkOrders.map(wo => wo.mo_num))].sort();

        moNums.forEach(moNum => {
            const wos = filteredWorkOrders.filter(wo => wo.mo_num === moNum);
            if (wos.length === 0) return;

            const starts = wos.map(wo => new Date(wo.date_scheduled_start));
            const ends = wos.map(wo => new Date(wo.date_scheduled));
            const moStart = new Date(Math.min(...starts));
            const moEnd = new Date(Math.max(...ends));

            timelineItems.push({
                id: `mo_header_${moNum}`,
                group: `mo_${moNum}`,
                content: `MO ${moNum}`,
                start: moStart,
                end: moEnd,
                type: 'range',
                className: `mo-header ${getMOStatusClass(moNum)}`,
                title: `Manufacturing Order ${moNum}`,
                editable: {
                    updateTime: false,  // MO headers should NOT be editable
                    updateGroup: false,
                    remove: false
                }
            });
        });

        // Add WOs
        filteredWorkOrders.forEach(wo => {
            const hasConflict = conflicts.has(wo.wo_id);
            const className = hasConflict ? 'conflict' : getStatusClass(wo);

            timelineItems.push({
                id: `wo_${wo.wo_id}`,
                group: `mo_${wo.mo_num}_wos`,
                content: `WO ${wo.wo_num}`,
                start: wo.date_scheduled_start,
                end: wo.date_scheduled,
                type: 'range',
                className: `${className} wo-item-${wo.wo_id}`,
                title: `WO ${wo.wo_num}\nMO ${wo.mo_num}\nCategory: ${wo.calendar_category}\nPart: ${wo.part_num} (${wo.qty_target})\nStatus: ${wo.wo_status_name}`,
                editable: {
                    updateTime: true,  // Explicitly enable drag and resize for this item
                    updateGroup: false,
                    remove: false
                },
                woData: wo
            });
        });

    } else {
        // Category view - all WOs grouped by category
        filteredWorkOrders.forEach(wo => {
            const category = wo.calendar_category || 'Unassigned';
            const hasConflict = conflicts.has(wo.wo_id);
            const className = hasConflict ? 'conflict' : getStatusClass(wo);

            timelineItems.push({
                id: `wo_${wo.wo_id}`,
                group: `cat_${category}`,
                content: `WO ${wo.wo_num} (MO ${wo.mo_num})`,
                start: wo.date_scheduled_start,
                end: wo.date_scheduled,
                type: 'range',
                className: `${className} wo-item-${wo.wo_id}`,
                title: `WO ${wo.wo_num}\nMO ${wo.mo_num}\nCategory: ${category}\nPart: ${wo.part_num} (${wo.qty_target})\nStatus: ${wo.wo_status_name}`,
                editable: {
                    updateTime: true,  // Explicitly enable drag and resize for this item
                    updateGroup: false,
                    remove: false
                },
                woData: wo
            });
        });
    }

    return timelineItems;
}

// ============================================
// Apply Filters
// ============================================

function applyFilters() {
    const moFilter = document.getElementById('moFilter').value;

    filteredWorkOrders = allWorkOrders.filter(wo => {
        // MO filter
        if (moFilter !== 'all' && wo.mo_num !== moFilter) {
            return false;
        }

        // Status filter
        if (activeStatusFilter !== null) {
            if (activeStatusFilter === 'conflict') {
                const conflicts = detectConflicts();
                if (!conflicts.has(wo.wo_id)) {
                    return false;
                }
            } else if (wo.wo_status !== parseInt(activeStatusFilter)) {
                return false;
            }
        }

        return true;
    });

    // Update statistics
    updateStatistics();
}

// ============================================
// Update Statistics
// ============================================

function updateStatistics() {
    const uniqueMOs = new Set(filteredWorkOrders.map(wo => wo.mo_num));
    const conflicts = detectConflicts();

    document.getElementById('totalWOs').textContent = filteredWorkOrders.length;
    document.getElementById('totalMOs').textContent = uniqueMOs.size;
    document.getElementById('totalDeps').textContent = stagingDependencies.length;
    document.getElementById('totalConflicts').textContent = conflicts.size;
}

// ============================================
// Initialize Timeline
// ============================================

function initTimeline() {
    const container = document.getElementById('visualization');

    // Apply filters
    applyFilters();

    if (filteredWorkOrders.length === 0) {
        showEmptyState(true);
        return;
    }

    showEmptyState(false);

    // Build groups and items
    groups = buildMOGroups();
    items = buildItems();

    // Timeline options
    const options = {
        // Row stacking configuration
        stack: true,
        stackSubgroups: true,

        // Editable configuration - ENABLE DRAG/RESIZE
        editable: {
            add: false,         // Don't allow adding new items
            updateTime: true,   // Allow dragging to change time (enables both move AND resize)
            updateGroup: false, // Don't allow dragging between groups (WO can't change category/MO)
            remove: false,      // Don't allow deleting
            overrideItems: true // Allow individual items to override editable settings
        },

        // Selection configuration
        selectable: true,
        multiselect: false,

        // Snap to day boundaries for cleaner interactions, skip weekends if enabled
        snap: function(date, scale, step) {
            const day = 24 * 60 * 60 * 1000;
            const snappedDate = new Date(Math.round(date / day) * day);
            return skipWeekends(snappedDate);
        },

        // Orientation
        orientation: 'top',

        // Zoom and move
        zoomable: true,
        moveable: true,
        zoomMin: 1000 * 60 * 60 * 24 * 7,  // 1 week minimum zoom
        zoomMax: 1000 * 60 * 60 * 24 * 180, // 6 months maximum zoom

        // Time axis format with day-of-week labels
        format: {
            minorLabels: {
                day: 'ddd D',
                weekday: 'ddd D',
                week: 'w'
            },
            majorLabels: {
                day: 'MMMM YYYY',
                week: 'MMMM YYYY',
                month: 'YYYY'
            }
        },

        // Force timeline to show individual days
        timeAxis: {
            scale: 'day',
            step: 1
        },

        // Margins
        margin: {
            item: {
                horizontal: 10,
                vertical: 5
            }
        },

        // Set initial view to show current week (with some buffer)
        start: moment().startOf('week').subtract(1, 'week').toDate(),
        end: moment().endOf('week').add(3, 'weeks').toDate(),

        // Callbacks for edits
        onMove: handleWOMove,
        onMoving: handleWOMoving,
        onUpdate: handleWOUpdate
    };

    // Create timeline
    timeline = new vis.Timeline(container, items, groups, options);

    // Add today marker
    timeline.addCustomTime(new Date(), 'today');
    timeline.setCustomTimeMarker('Today', 'today', false);

    // Add double-click event to open MO screen
    timeline.on('doubleClick', function(properties) {
        if (properties.item) {
            const itemId = properties.item;

            // Check if it's a WO (not MO header)
            if (itemId.startsWith('wo_')) {
                const woId = parseInt(itemId.replace('wo_', ''));
                const wo = filteredWorkOrders.find(w => w.wo_id === woId);

                if (wo) {
                    debugLog('info', `Double-clicked WO ${wo.wo_num} - opening MO ${wo.mo_num}`);

                    try {
                        // Use the Fishbowl openModule function (same as v1)
                        openModule("Manufacture Order", wo.mo_num);
                    } catch (error) {
                        debugLog('error', 'Error opening MO', error.toString());
                        showToast('Error opening MO ' + wo.mo_num + ': ' + error.toString(), 'error', true);
                    }
                }
            } else if (itemId.startsWith('mo_header_')) {
                // Double-clicked MO header directly
                const moNum = itemId.replace('mo_header_', '');

                debugLog('info', `Double-clicked MO header ${moNum}`);

                try {
                    // Use the Fishbowl openModule function
                    openModule("Manufacture Order", moNum);
                } catch (error) {
                    debugLog('error', 'Error opening MO', error.toString());
                    showToast('Error opening MO ' + moNum + ': ' + error.toString(), 'error', true);
                }
            }
        }
    });

    // Render dependency arrows and apply colors
    setTimeout(() => {
        renderDependencyArrows();
    }, 300);

    // Apply category colors after render with longer timeout to ensure DOM is ready
    if (viewMode === 'category') {
        setTimeout(() => {
            applyCategoryColors();
        }, 800);
    }

    // Re-render arrows and colors on timeline events
    timeline.on('changed', () => {
        renderDependencyArrows();
        if (viewMode === 'category') {
            applyCategoryColors();
        }
        highlightWeekends();
    });

    // Reapply category colors after any redraw (critical for vis-timeline)
    if (viewMode === 'category') {
        timeline.on('rangechanged', applyCategoryColors);
        timeline.on('changed', applyCategoryColors);
    }

    // Reapply weekend highlighting after any redraw (critical for vis-timeline)
    timeline.on('rangechanged', highlightWeekends);
    timeline.on('changed', highlightWeekends);

    // Initial weekend highlighting
    setTimeout(() => {
        highlightWeekends();
    }, 500);

    debugLog('success', `Timeline initialized in ${viewMode} view with ${filteredWorkOrders.length} WOs`);
}

// ============================================
// Highlight Weekends
// ============================================
function highlightWeekends() {
    const container = document.getElementById('visualization');
    if (!container || !timeline) return;

    setTimeout(() => {
        // Get the current visible time range
        const timeWindow = timeline.getWindow();
        const start = moment(timeWindow.start).startOf('day');
        const end = moment(timeWindow.end).endOf('day');

        // Find all weekends in the visible range
        const weekendDates = [];
        let current = start.clone();
        while (current.isSameOrBefore(end)) {
            const dayOfWeek = current.day(); // 0 = Sunday, 6 = Saturday
            if (dayOfWeek === 0 || dayOfWeek === 6) {
                weekendDates.push(current.format('YYYY-MM-DD'));
            }
            current.add(1, 'day');
        }

        // Find all grid columns and check their timestamps
        const timeAxisColumns = container.querySelectorAll('.vis-time-axis .vis-grid.vis-vertical');
        const backgroundColumns = container.querySelectorAll('.vis-panel.vis-background .vis-vertical');

        let weekendsHighlighted = 0;

        timeAxisColumns.forEach((column, index) => {
            // Check if this column has a title attribute with the date
            const title = column.getAttribute('title');
            if (title) {
                const columnDate = moment(title).format('YYYY-MM-DD');
                if (weekendDates.includes(columnDate)) {
                    column.style.backgroundColor = '#f5f5f5';

                    // Also apply to background column
                    if (backgroundColumns[index]) {
                        backgroundColumns[index].style.backgroundColor = '#f5f5f5';
                    }
                    weekendsHighlighted++;
                }
            } else {
                // Fallback: check label text for day names
                const label = column.querySelector('.vis-text');
                if (label) {
                    const text = label.textContent.trim();
                    if (text.startsWith('Sat') || text.startsWith('Sun')) {
                        column.style.backgroundColor = '#f5f5f5';

                        if (backgroundColumns[index]) {
                            backgroundColumns[index].style.backgroundColor = '#f5f5f5';
                        }
                        weekendsHighlighted++;
                    }
                }
            }
        });

        debugLog('info', `Highlighted ${weekendsHighlighted} weekend columns`);
    }, 0);
}

// ============================================
// Apply Category Colors to Labels and Background Rows
// ============================================
function applyCategoryColors() {
    if (viewMode !== 'category') {
        debugLog('info', 'Skipping colors - not in category view');
        return;
    }

    debugLog('info', `Applying category colors (${groups.length} groups)...`);

    setTimeout(() => {
        // vis-timeline 7.7.3 doesn't add data-groupid, so use index-based matching
        // Our category-label class helps us find the right elements
        const labels = document.querySelectorAll('.vis-label.category-label');
        const bgGroups = document.querySelectorAll('.vis-panel.vis-background .vis-group');

        debugLog('info', `Found ${labels.length} category labels, ${bgGroups.length} background groups (${groups.length} groups in data)`);

        groups.forEach((group, index) => {
            if (!group.categoryColor) return;

            const color = group.categoryColor;
            debugLog('info', `Applying ${color} to group ${index} (${group.id})`);

            // Apply to label by index (with !important to override vis styles)
            if (labels[index]) {
                labels[index].style.setProperty('background-color', color, 'important');
                const computed = window.getComputedStyle(labels[index]).backgroundColor;
                debugLog('success', `   Label: set ${color}, computed ${computed}`);
            } else {
                debugLog('warning', `   Label ${index} not found`);
            }

            // Apply to background group by index
            if (bgGroups[index]) {
                bgGroups[index].style.setProperty('background-color', color, 'important');
                const computed = window.getComputedStyle(bgGroups[index]).backgroundColor;
                debugLog('success', `   Background: set ${color}, computed ${computed}`);
            } else {
                debugLog('warning', `   Background ${index} not found`);
            }
        });

        debugLog('success', `Category colors applied to ${labels.length} labels`);
    }, 100);
}

// ============================================
// Render Dependency Arrows
// ============================================
function renderDependencyArrows() {
    debugLog('info', 'Rendering dependency arrows...');

    // Remove existing arrow SVG if it exists
    const existingSvg = document.getElementById('dependencyArrowsSvg');
    if (existingSvg) {
        existingSvg.remove();
    }

    const container = document.getElementById('visualization');
    if (!container) {
        debugLog('error', 'Container not found for dependency arrows');
        return;
    }

    // Create SVG overlay
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.id = 'dependencyArrowsSvg';
    svg.style.position = 'absolute';
    svg.style.top = '0';
    svg.style.left = '0';
    svg.style.width = '100%';
    svg.style.height = '100%';
    svg.style.pointerEvents = 'none';
    svg.style.zIndex = '1';

    container.style.position = 'relative';
    container.appendChild(svg);

    // Get timeline dimensions
    const timelineContent = container.querySelector('.vis-content');
    if (!timelineContent) return;

    const allowSameDay = document.getElementById('allowSameDayStart').classList.contains('active');

    let arrowsRendered = 0;
    let conflictArrows = 0;

    // Draw arrows for each dependency
    stagingDependencies.forEach(dep => {
        // Find the source (staging) and target (consuming) WO elements by class name
        const sourceItem = container.querySelector(`.vis-item.wo-item-${dep.staging_wo_id}`);
        const targetItem = container.querySelector(`.vis-item.wo-item-${dep.wo_id}`);

        if (!sourceItem || !targetItem) return;

        // Get positions
        const sourceRect = sourceItem.getBoundingClientRect();
        const targetRect = targetItem.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();

        // Calculate arrow start/end points (relative to container)
        const startX = sourceRect.right - containerRect.left;
        const startY = sourceRect.top + sourceRect.height / 2 - containerRect.top;
        const endX = targetRect.left - containerRect.left;
        const endY = targetRect.top + targetRect.height / 2 - containerRect.top;

        // Check if this dependency is in conflict
        const stagingFinish = moment(dep.staging_wo_finish);
        const currentStart = moment(dep.wo_start);

        let isConflict = false;
        if (allowSameDay) {
            isConflict = stagingFinish.isAfter(currentStart, 'day');
        } else {
            isConflict = stagingFinish.isSameOrAfter(currentStart, 'day');
        }

        // Draw arrow with right angles
        const color = isConflict ? '#e74c3c' : '#95a5a6';
        const strokeWidth = isConflict ? 2 : 1.5;

        // Create path with right-angle turns
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

        // Calculate right-angle path
        const horizontalOffset = 10; // Small offset from the bar
        const midX = (startX + endX) / 2;

        // Path: start  right  down/up  right  end
        let pathData;
        if (Math.abs(endY - startY) < 5) {
            // Same row or very close - simple straight line
            pathData = `M ${startX} ${startY} L ${endX} ${endY}`;
        } else {
            // Different rows - right angle path
            pathData = `M ${startX} ${startY}
                        L ${startX + horizontalOffset} ${startY}
                        L ${startX + horizontalOffset} ${endY}
                        L ${endX} ${endY}`;
        }

        path.setAttribute('d', pathData);
        path.setAttribute('stroke', color);
        path.setAttribute('stroke-width', strokeWidth);
        path.setAttribute('fill', 'none');
        path.setAttribute('class', 'dependency-arrow');
        path.setAttribute('data-source-id', dep.staging_wo_id);
        path.setAttribute('data-target-id', dep.wo_id);
        path.setAttribute('marker-end', `url(#arrowhead-${isConflict ? 'conflict' : 'normal'})`);

        svg.appendChild(path);
        arrowsRendered++;
        if (isConflict) conflictArrows++;
    });

    debugLog('info', `Rendered ${arrowsRendered} dependency arrows (${conflictArrows} conflicts)`);

    // Add arrowhead markers
    addArrowheadMarkers(svg);

    // Add hover event listeners to WO items
    addArrowHoverListeners(container);
}

function addArrowHoverListeners(container) {
    // Find all WO items
    const woItems = container.querySelectorAll('.vis-item.vis-range');

    woItems.forEach(woItem => {
        // Extract WO ID from class name (wo-item-123)
        const classMatch = woItem.className.match(/wo-item-(\d+)/);
        if (!classMatch) return;

        const woId = classMatch[1];

        // Add mouseenter event
        woItem.addEventListener('mouseenter', function() {
            // Find all arrows connected to this WO
            const arrows = container.querySelectorAll(
                `.dependency-arrow[data-source-id="${woId}"], .dependency-arrow[data-target-id="${woId}"]`
            );

            arrows.forEach(arrow => {
                arrow.classList.add('highlighted');
            });
        });

        // Add mouseleave event
        woItem.addEventListener('mouseleave', function() {
            // Remove highlight from all arrows
            const arrows = container.querySelectorAll('.dependency-arrow.highlighted');
            arrows.forEach(arrow => {
                arrow.classList.remove('highlighted');
            });
        });
    });
}

function addArrowheadMarkers(svg) {
    // Create defs element for markers
    let defs = svg.querySelector('defs');
    if (!defs) {
        defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        svg.appendChild(defs);
    }

    // Normal arrowhead (smaller)
    const markerNormal = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
    markerNormal.setAttribute('id', 'arrowhead-normal');
    markerNormal.setAttribute('markerWidth', '6');
    markerNormal.setAttribute('markerHeight', '6');
    markerNormal.setAttribute('refX', '5');
    markerNormal.setAttribute('refY', '2');
    markerNormal.setAttribute('orient', 'auto');

    const pathNormal = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    pathNormal.setAttribute('d', 'M0,0 L0,4 L5,2 z');
    pathNormal.setAttribute('fill', '#95a5a6');
    markerNormal.appendChild(pathNormal);
    defs.appendChild(markerNormal);

    // Conflict arrowhead (smaller)
    const markerConflict = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
    markerConflict.setAttribute('id', 'arrowhead-conflict');
    markerConflict.setAttribute('markerWidth', '6');
    markerConflict.setAttribute('markerHeight', '6');
    markerConflict.setAttribute('refX', '5');
    markerConflict.setAttribute('refY', '2');
    markerConflict.setAttribute('orient', 'auto');

    const pathConflict = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    pathConflict.setAttribute('d', 'M0,0 L0,4 L5,2 z');
    pathConflict.setAttribute('fill', '#e74c3c');
    markerConflict.appendChild(pathConflict);
    defs.appendChild(markerConflict);
}

// ============================================
// Handle WO Move/Resize Events
// ============================================

function handleWOMoving(item, callback) {
    // Called while dragging - allow the move
    callback(item);
}

function handleWOMove(item, callback) {
    // Extract WO ID from item id (format: "wo_123")
    const woId = parseInt(item.id.replace('wo_', ''));

    debugLog('info', `WO moved: ${item.content}`, {
        woId: woId,
        newStart: moment(item.start).format('YYYY-MM-DD'),
        newEnd: moment(item.end).format('YYYY-MM-DD')
    });

    const newStart = moment(item.start).format('YYYY-MM-DD');
    const newEnd = moment(item.end).format('YYYY-MM-DD');

    // Save state for undo BEFORE making changes
    saveStateForUndo();

    // Save old dates BEFORE updating (needed for shift calculation)
    const movedWO = filteredWorkOrders.find(wo => wo.wo_id === woId);
    const oldStart = movedWO ? movedWO.date_scheduled_start : null;
    const oldEnd = movedWO ? movedWO.date_scheduled : null;

    // Update the underlying data arrays FIRST
    const updateWODates = (wo) => {
        if (wo.wo_id === woId) {
            wo.date_scheduled_start = newStart;
            wo.date_scheduled = newEnd;
            debugLog('success', `Updated WO ${wo.wo_num} in data array`);
        }
        return wo;
    };

    allWorkOrders = allWorkOrders.map(updateWODates);
    filteredWorkOrders = filteredWorkOrders.map(updateWODates);

    // CRITICAL: Also update stagingDependencies array with new dates
    stagingDependencies = stagingDependencies.map(dep => {
        // If this WO is a staging WO (provides parts to others), update its finish date
        if (dep.staging_wo_id === woId) {
            dep.staging_wo_finish = newEnd;
            debugLog('info', `Updated staging dependency: WO ${dep.staging_wo_num} new finish: ${newEnd}`);
        }
        // If this WO consumes parts (depends on others), update its start date
        if (dep.wo_id === woId) {
            dep.wo_start = newStart;
            debugLog('info', `Updated consuming dependency: WO ${dep.wo_num} new start: ${newStart}`);
        }
        return dep;
    });

    // TODO: Update database
    // const updateQuery = `
    //     UPDATE wo
    //     SET datescheduledtostart = '${newStart}',
    //         datescheduled = '${newEnd}'
    //     WHERE id = ${woId}
    // `;
    // runUpdate(updateQuery);

    // Confirm the move
    callback(item);

    // If shift deps enabled, shift dependent WOs
    if (document.getElementById('shiftDependentWOs').classList.contains('active')) {
        shiftDependentWOs(item, woId, oldStart, oldEnd);
    }

    // Just update conflicts without full rebuild
    updateConflictHighlighting();
}

function handleWOUpdate(item, callback) {
    // Handle resize/update the same way
    handleWOMove(item, callback);
}

function shiftDependentWOs(movedItem, movedWoId, oldStartDate = null, oldEndDate = null) {
    debugLog('info', `Shifting dependent WOs for WO ID ${movedWoId}...`);

    // Calculate the time delta (how much the WO was moved)
    // Use passed old dates if available, otherwise use current data
    const oldStart = oldStartDate ? moment(oldStartDate) : moment(movedItem.start);
    const newStart = moment(movedItem.start);
    const oldEnd = oldEndDate ? moment(oldEndDate) : moment(movedItem.end);
    const newEnd = moment(movedItem.end);

    const startDelta = newStart.diff(oldStart, 'days');
    const endDelta = newEnd.diff(oldEnd, 'days');

    debugLog('info', `WO moved by ${startDelta} days (start) and ${endDelta} days (end)`);

    // Find all WOs that depend on this WO (WOs where this WO is the staging WO)
    const dependentWOs = stagingDependencies
        .filter(dep => dep.staging_wo_id === movedWoId)
        .map(dep => dep.wo_id);

    if (dependentWOs.length === 0) {
        debugLog('info', 'No dependent WOs to shift');
        return;
    }

    debugLog('info', `Found ${dependentWOs.length} dependent WOs to shift`);

    // Shift each dependent WO (only if it would cause a conflict)
    const itemsToUpdate = [];
    const allowSameDay = document.getElementById('allowSameDayStart').classList.contains('active');

    dependentWOs.forEach(depWoId => {
        const depWO = filteredWorkOrders.find(wo => wo.wo_id === depWoId);
        if (!depWO) return;

        // Check if this WO would have a conflict with the moved WO
        const stagingFinish = moment(newEnd);
        const currentStart = moment(depWO.date_scheduled_start);

        let wouldConflict = false;
        if (allowSameDay) {
            wouldConflict = stagingFinish.isAfter(currentStart, 'day');
        } else {
            wouldConflict = stagingFinish.isSameOrAfter(currentStart, 'day');
        }

        // Only shift if it would cause a conflict
        if (!wouldConflict) {
            debugLog('info', `Skipping WO ${depWO.wo_num} - no conflict`);
            return;
        }

        // Save old dates for this dependent WO before shifting
        const depOldStart = depWO.date_scheduled_start;
        const depOldEnd = depWO.date_scheduled;

        // Calculate new dates and skip weekends
        let newDepStart = moment(depWO.date_scheduled_start).add(startDelta, 'days').toDate();
        newDepStart = skipWeekends(newDepStart);
        const newDepStartStr = moment(newDepStart).format('YYYY-MM-DD');

        let newDepEnd = moment(depWO.date_scheduled).add(endDelta, 'days').toDate();
        newDepEnd = skipWeekends(newDepEnd);
        const newDepEndStr = moment(newDepEnd).format('YYYY-MM-DD');

        debugLog('info', `Shifting WO ${depWO.wo_num}: ${depOldStart}  ${newDepStartStr} (conflict detected)`);

        // Update the data arrays
        const updateWODates = (wo) => {
            if (wo.wo_id === depWoId) {
                wo.date_scheduled_start = newDepStartStr;
                wo.date_scheduled = newDepEndStr;
            }
            return wo;
        };

        allWorkOrders = allWorkOrders.map(updateWODates);
        filteredWorkOrders = filteredWorkOrders.map(updateWODates);

        // Update staging dependencies
        stagingDependencies = stagingDependencies.map(dep => {
            if (dep.staging_wo_id === depWoId) {
                dep.staging_wo_finish = newDepEndStr;
            }
            if (dep.wo_id === depWoId) {
                dep.wo_start = newDepStartStr;
            }
            return dep;
        });

        // Find the timeline item and update it
        const timelineItem = timeline.itemsData.get(`wo_${depWoId}`);
        if (timelineItem) {
            timelineItem.start = newDepStartStr;
            timelineItem.end = newDepEndStr;
            itemsToUpdate.push(timelineItem);
        }

        // Recursively shift dependents of this WO
        shiftDependentWOs({ start: newDepStartStr, end: newDepEndStr }, depWoId, depOldStart, depOldEnd);
    });

    // Update all shifted items in the timeline at once
    if (itemsToUpdate.length > 0) {
        timeline.itemsData.update(itemsToUpdate);
        debugLog('success', `Shifted ${itemsToUpdate.length} dependent WOs`);
    }
}

function updateConflictHighlighting() {
    // Re-detect conflicts and update item classes
    const conflicts = detectConflicts();

    // Get current items
    const currentItems = timeline.itemsData.get();

    currentItems.forEach(item => {
        if (item.id.startsWith('wo_')) {
            const woId = parseInt(item.id.replace('wo_', ''));
            const hasConflict = conflicts.has(woId);

            // Update class - PRESERVE the wo-item-{wo_id} class for arrow rendering!
            if (hasConflict) {
                item.className = `conflict wo-item-${woId}`;
            } else {
                const wo = filteredWorkOrders.find(w => w.wo_id === woId);
                if (wo) {
                    item.className = `${getStatusClass(wo)} wo-item-${woId}`;
                }
            }
        }
    });

    // Update items in timeline
    timeline.itemsData.update(currentItems);

    // Update statistics
    updateStatistics();

    // Re-render dependency arrows with longer timeout to ensure DOM updates complete
    setTimeout(() => renderDependencyArrows(), 300);

    debugLog('info', `Updated conflict highlighting - ${conflicts.size} conflicts found`);
}

// ============================================
// Switch View Mode
// ============================================

function switchView(newMode) {
    if (newMode === viewMode) return;

    viewMode = newMode;

    // Update button states
    document.getElementById('moViewBtn').classList.toggle('active', viewMode === 'mo');
    document.getElementById('categoryViewBtn').classList.toggle('active', viewMode === 'category');

    debugLog('info', `Switched to ${viewMode} view`);

    // Rebuild timeline
    rebuildTimeline();
}

// ============================================
// Rebuild Timeline (after filter/toggle)
// ============================================

function rebuildTimeline() {
    if (!timeline) return;

    // Apply filters
    applyFilters();

    if (filteredWorkOrders.length === 0) {
        showEmptyState(true);
        return;
    }

    showEmptyState(false);

    // Rebuild groups and items
    groups = viewMode === 'mo' ? buildMOGroups() : buildCategoryGroups();
    items = buildItems();

    // Update timeline
    timeline.setGroups(groups);
    timeline.setItems(items);

    // Re-render dependency arrows
    setTimeout(() => {
        renderDependencyArrows();
    }, 300);

    // Apply category colors with longer timeout
    if (viewMode === 'category') {
        setTimeout(() => {
            applyCategoryColors();
        }, 800);
    }

    // Highlight weekends
    setTimeout(() => {
        highlightWeekends();
    }, 500);

    debugLog('info', `Timeline rebuilt with ${filteredWorkOrders.length} WOs in ${viewMode} view`);
}

// ============================================
// Status Filter Toggle
// ============================================

function toggleStatusFilter(status) {
    if (activeStatusFilter === status) {
        activeStatusFilter = null;
    } else {
        activeStatusFilter = status;
    }

    // Update visual state
    document.querySelectorAll('.legend-item.clickable').forEach(item => {
        if (item.getAttribute('data-status') === activeStatusFilter) {
            item.classList.add('active');
        } else {
            item.classList.remove('active');
        }
    });

    debugLog('info', `Status filter: ${activeStatusFilter || 'none'}`);

    rebuildTimeline();
}

// ============================================
// Event Listeners
// ============================================

document.addEventListener('DOMContentLoaded', function() {
    // View toggle buttons
    document.getElementById('moViewBtn').addEventListener('click', () => switchView('mo'));
    document.getElementById('categoryViewBtn').addEventListener('click', () => switchView('category'));

    // Timeline controls
    document.getElementById('zoomInBtn').addEventListener('click', () => {
        if (timeline) timeline.zoomIn(0.2);
    });

    document.getElementById('zoomOutBtn').addEventListener('click', () => {
        if (timeline) timeline.zoomOut(0.2);
    });

    document.getElementById('fitBtn').addEventListener('click', () => {
        if (timeline) timeline.fit();
    });

    document.getElementById('todayBtn').addEventListener('click', () => {
        if (timeline) timeline.moveTo(new Date());
    });

    // Status filter
    document.querySelectorAll('.legend-item.clickable').forEach(item => {
        item.addEventListener('click', function() {
            const status = this.getAttribute('data-status');
            toggleStatusFilter(status);
        });
    });

    // Icon toggle buttons (converted from checkboxes)
    document.getElementById('shiftDependentWOs').addEventListener('click', function() {
        this.classList.toggle('active');
        const isActive = this.classList.contains('active');
        document.getElementById('shiftDependentWOsOffcanvas').checked = isActive;
        debugLog('info', `Shift dependent WOs: ${isActive}`);
    });

    document.getElementById('allowSameDayStart').addEventListener('click', function() {
        this.classList.toggle('active');
        const isActive = this.classList.contains('active');
        document.getElementById('allowSameDayStartOffcanvas').checked = isActive;
        debugLog('info', `Allow same-day start: ${isActive}`);
        rebuildTimeline();
    });

    // Sync offcanvas toggles with main toggles
    document.getElementById('shiftDependentWOsOffcanvas').addEventListener('change', function() {
        const shiftBtn = document.getElementById('shiftDependentWOs');
        if (this.checked) {
            shiftBtn.classList.add('active');
        } else {
            shiftBtn.classList.remove('active');
        }
        debugLog('info', `Shift dependent WOs: ${this.checked}`);
    });

    document.getElementById('allowSameDayStartOffcanvas').addEventListener('change', function() {
        const allowBtn = document.getElementById('allowSameDayStart');
        if (this.checked) {
            allowBtn.classList.add('active');
        } else {
            allowBtn.classList.remove('active');
        }
        debugLog('info', `Allow same-day start: ${this.checked}`);
        rebuildTimeline();
    });

    // Refresh button in offcanvas
    document.getElementById('refreshBtn').addEventListener('click', function() {
        rebuildTimeline();
        // Close offcanvas
        const offcanvas = bootstrap.Offcanvas.getInstance(document.getElementById('settingsOffcanvas'));
        if (offcanvas) offcanvas.hide();
    });

    // Undo/Redo buttons
    document.getElementById('undoBtn').addEventListener('click', undo);
    document.getElementById('redoBtn').addEventListener('click', redo);

    // Keyboard shortcuts for undo/redo
    document.addEventListener('keydown', function(e) {
        // Ctrl+Z or Cmd+Z for undo
        if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
            e.preventDefault();
            undo();
        }
        // Ctrl+Y or Cmd+Y or Ctrl+Shift+Z for redo
        if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
            e.preventDefault();
            redo();
        }
    });

    // Load data
    debugLog('info', 'Initialization complete - loading work orders...');
    loadWorkOrders();
});

</script>
</body>
</html>
